<!-- Creator     : groff version 1.18.1 -->
<!-- CreationDate: Fri Feb 11 22:17:07 2005 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title>The table driven code generator from</title>
</head>
<body>

<h1 align=center>The table driven code generator from</h1>
<a href="#1. Introduction">1. Introduction</a><br>
<a href="#2. Global overview of the workings of the code generator.">2. Global overview of the workings of the code generator.</a><br>
<a href="#3. Description of the machine table">3. Description of the machine table</a><br>
<a href="#3.1. Some constants">3.1. Some constants</a><br>
<a href="#3.2. Register definition">3.2. Register definition</a><br>
<a href="#3.3. Stack token definition">3.3. Stack token definition</a><br>
<a href="#3.4. Token expressions">3.4. Token expressions</a><br>
<a href="#3.5. Expressions">3.5. Expressions</a><br>
<a href="#3.6. Code rules">3.6. Code rules</a><br>
<a href="#3.6.1. The EM pattern">3.6.1. The EM pattern</a><br>
<a href="#3.6.2. The stack pattern">3.6.2. The stack pattern</a><br>
<a href="#3.6.3. The code part">3.6.3. The code part</a><br>
<a href="#3.6.3.1. Stack cleanup">3.6.3.1. Stack cleanup</a><br>
<a href="#3.6.3.2. Register allocation">3.6.3.2. Register allocation</a><br>
<a href="#3.6.3.3. Code">3.6.3.3. Code</a><br>
<a href="#3.6.4. Stack replacement">3.6.4. Stack replacement</a><br>
<a href="#3.6.5. EM replacement">3.6.5. EM replacement</a><br>
<a href="#3.6.6. Cost">3.6.6. Cost</a><br>
<a href="#3.6.7. Examples">3.6.7. Examples</a><br>
<a href="#3.7. Move code rules">3.7. Move code rules</a><br>
<a href="#3.8. Test code rules">3.8. Test code rules</a><br>
<a href="#3.9. Stacking code rules.">3.9. Stacking code rules.</a><br>
<a href="#4. The files mach.h and mach.c">4. The files mach.h and mach.c</a><br>
<a href="#4.1. Types in the code generator">4.1. Types in the code generator</a><br>
<a href="#4.2. Global variables to work with">4.2. Global variables to work with</a><br>
<a href="#4.3. Macros in mach.h">4.3. Macros in mach.h</a><br>
<a href="#4.3.1. Example mach.h for the PDP-11">4.3.1. Example mach.h for the PDP-11</a><br>
<a href="#4.4. Functions in mach.c">4.4. Functions in mach.c</a><br>
<a href="#4.4.1. Example mach.c for the PDP-11">4.4.1. Example mach.c for the PDP-11</a><br>
<a href="#5. Coercions">5. Coercions</a><br>
<a href="#6. Internal workings of the code generator.">6. Internal workings of the code generator.</a><br>
<a href="#6.1. Description of tables.c and tables.h contents">6.1. Description of tables.c and tables.h contents</a><br>
<a href="#6.1.1. Tables.c">6.1.1. Tables.c</a><br>
<a href="#6.1.2. tables.h">6.1.2. tables.h</a><br>
<a href="#6.2. Other important data structures">6.2. Other important data structures</a><br>
<a href="#6.3. A tour through the sources">6.3. A tour through the sources</a><br>
<a href="#6.3.1. codegen.c">6.3.1. codegen.c</a><br>
<a href="#6.3.1.1. DO_NEXTEM">6.3.1.1. DO_NEXTEM</a><br>
<a href="#6.3.1.2. DO_COERC">6.3.1.2. DO_COERC</a><br>
<a href="#6.3.1.3. DO_XMATCH">6.3.1.3. DO_XMATCH</a><br>
<a href="#6.3.1.4. DO_MATCH">6.3.1.4. DO_MATCH</a><br>
<a href="#6.3.1.5. DO_REMOVE">6.3.1.5. DO_REMOVE</a><br>
<a href="#6.3.1.6. DO_DEALLOCATE">6.3.1.6. DO_DEALLOCATE</a><br>
<a href="#6.3.1.7. DO_REALLOCATE">6.3.1.7. DO_REALLOCATE</a><br>
<a href="#6.3.1.8. DO_ALLOCATE">6.3.1.8. DO_ALLOCATE</a><br>
<a href="#6.3.1.9. DO_LOUTPUT">6.3.1.9. DO_LOUTPUT</a><br>
<a href="#6.3.1.10. DO_ROUTPUT">6.3.1.10. DO_ROUTPUT</a><br>
<a href="#6.3.1.11. DO_MOVE">6.3.1.11. DO_MOVE</a><br>
<a href="#6.3.1.12. DO_ERASE">6.3.1.12. DO_ERASE</a><br>
<a href="#6.3.1.13. DO_TOKREPLACE">6.3.1.13. DO_TOKREPLACE</a><br>
<a href="#6.3.1.14. DO_EMREPLACE">6.3.1.14. DO_EMREPLACE</a><br>
<a href="#6.3.1.15. DO_COST">6.3.1.15. DO_COST</a><br>
<a href="#6.3.1.16. DO_RETURN">6.3.1.16. DO_RETURN</a><br>
<a href="#6.3.2. compute.c">6.3.2. compute.c</a><br>
<a href="#6.3.3. equiv.c">6.3.3. equiv.c</a><br>
<a href="#6.3.4. fillem.c">6.3.4. fillem.c</a><br>
<a href="#6.3.5. gencode.c">6.3.5. gencode.c</a><br>
<a href="#6.3.6. glosym.c">6.3.6. glosym.c</a><br>
<a href="#6.3.7. main.c">6.3.7. main.c</a><br>
<a href="#6.3.8. move.c">6.3.8. move.c</a><br>
<a href="#6.3.9. nextem.c">6.3.9. nextem.c</a><br>
<a href="#6.3.10. reg.c">6.3.10. reg.c</a><br>
<a href="#6.3.11. salloc.c">6.3.11. salloc.c</a><br>
<a href="#6.3.12. state.c">6.3.12. state.c</a><br>
<a href="#6.3.13. subr.c">6.3.13. subr.c</a><br>
<a href="#6.3.13.1. match">6.3.13.1. match</a><br>
<a href="#6.3.13.2. instance,cinstance">6.3.13.2. instance,cinstance</a><br>
<a href="#6.3.13.3. eqtoken">6.3.13.3. eqtoken</a><br>
<a href="#6.3.13.4. distance">6.3.13.4. distance</a><br>
<a href="#6.3.13.5. split">6.3.13.5. split</a><br>
<a href="#6.3.13.6. docoerc">6.3.13.6. docoerc</a><br>
<a href="#6.3.13.7. stackupto">6.3.13.7. stackupto</a><br>
<a href="#6.3.13.8. findcoerc">6.3.13.8. findcoerc</a><br>
<a href="#6.3.14. var.c">6.3.14. var.c</a><br>

<hr>

<p><b>the Amsterdam Compiler Kit</b></p>

<p align=center><i><small>ABSTRACT</small></i></p>

<p align=center><i><small>Hans van
Staveren</small></i><small><br>
Dept. of Mathematics and Computer Science<br>
Vrije Universiteit<br>
Amsterdam, The Netherlands</small></p>

<p><small>It is possible to automate the process of
compiler building to a great extent using collections of
tools. The Amsterdam Compiler Kit is such a collection of
tools. This document provides a description of the internal
workings of the table driven code generator in the Amsterdam
Compiler Kit, and a description of syntax and semantics of
the driving table.</small></p>

<p><small>&gt;&gt;&gt; NOTE &lt;&lt;&lt;<br>
This document pertains to the <b>old</b> code generator.
Refer to the &quot;Second Revised Edition&quot; for the new
code generator.</small></p>
<a name="1. Introduction"></a>
<h2>1. Introduction</h2>

<p><small>Part of the Amsterdam Compiler Kit is a code
generator system consisting of a code generator generator
(<i>cgg</i> for short) and some machine independent C code.
<i>Cgg</i> reads a machine description table and creates two
files, tables.h and tables.c. These are then used together
with other C code to produce a code generator for the
machine at hand.</small></p>

<p><small>This in turn reads compact EM code and produces
assembly code. The remainder of this document will first
broadly describe the working of the code generator, then a
description of the machine table follows after which the
internal workings of the code generator will be
explained.</small></p>

<p><small>The reader is assumed to have at least a vague
notion about the semantics of the intermediary EM code.
Someone wishing to write a table for a new machine should be
thoroughly acquainted with EM code and the assembly code of
the machine at hand.</small></p>
<a name="2. Global overview of the workings of the code generator."></a>
<h2>2. Global overview of the workings of the code generator.</h2>

<p><small>The code generator or <i>cg</i> tries to generate
good code by simulating the runtime stack of the program
compiled and delaying emission of code as long as possible.
It also keeps track of register contents, which enables it
to eliminate redundant moves, and tries to eliminate
redundant tests by keeping information about condition code
status, if applicable for the machine.</small></p>

<p><small><i>Cg</i> maintains a &lsquo;fakestack&rsquo;
containing &lsquo;tokens&rsquo; that are built by executing
the pseudo code contained in the code rules given by the
table writer. One can think of the fakestack as a logical
extension of the real stack the program compiled will have
when run. During code generation tokens will be kept on the
fakestack as long as possible but when they are moved to the
real stack, by generating code for the push, all tokens
above*</small></p>


<p align=center><small><img src="grohtml-99261.png"></small></p>

<p><small>the tokens pushed will be pushed also, so that
the fakestack will not contain holes.</small></p>

<p><small>The main loop of <i>cg</i> is this:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>1)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>find a pattern of EM instructions starting at the
current one to generate code for. This pattern will usually
be of length one but longer patterns can be
used.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>2)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Select one of the possibly many stack patterns
that go with this EM pattern on the basis of heuristics
and/or lookahead.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>3)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Force the current fakestack contents to match the
pattern. This may involve copying tokens to registers,
making dummy transformations, e.g. to transform a
&quot;local&quot; into an &quot;register offsetted&quot; or
might even cause to have the complete fakestack contents put
to the real stack and then back into registers if no
suitable transformations were provided by the table
writer.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>4)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Execute the pseudocode associated with the code
rule just selected, this may cause registers to be
allocated, code to be emitted etc..</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>5)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Put tokens onto the fakestack to reflect the
result of the operation.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>6)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Insert some EM instructions into the stream, this
is possible but not common.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>7)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Account for the cost. The cost is kept in a
(space, time) vector and lookahead decisions are based on a
linear combination of these.</small></p>
</td>
</table>

<p><small>The table that drives <i>cg</i> is not read in
every time, but instead is used at compiletime of <i>cg</i>
to set parameters and to load pseudocode tables. A program
called <i>cgg</i> reads the table and produces large lists
of numbers that are compiled together with machine
independent code to produce a code generator for the machine
at hand.</small></p>
<a name="3. Description of the machine table"></a>
<h2>3. Description of the machine table</h2>

<p><small>The machine description table consists of the
following sections:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>1)</small></p>
</td>
<td width="6%"></td>
<td width="40%">

<p><small>Constant definitions</small></p>
</td>
<td width="49%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>2)</small></p>
</td>
<td width="6%"></td>
<td width="40%">

<p><small>Register definitions</small></p>
</td>
<td width="49%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>3)</small></p>
</td>
<td width="6%"></td>
<td width="34%">

<p><small>Token definitions</small></p>
</td>
<td width="55%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>4)</small></p>
</td>
<td width="6%"></td>
<td width="56%">

<p><small>Token expression definitions</small></p>
</td>
<td width="33%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>5)</small></p>
</td>
<td width="6%"></td>
<td width="20%">

<p><small>Code rules</small></p>
</td>
<td width="69%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>6)</small></p>
</td>
<td width="6%"></td>
<td width="32%">

<p><small>Move definitions</small></p>
</td>
<td width="57%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>7)</small></p>
</td>
<td width="6%"></td>
<td width="32%">

<p><small>Test definitions</small></p>
</td>
<td width="57%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>8)</small></p>
</td>
<td width="6%"></td>
<td width="40%">

<p><small>Stacking definitions</small></p>
</td>
<td width="49%">
</td>
</table>

<p><small>Input is in free format, white space and newlines
may be used at will to improve legibility. Identifiers used
in the table have the same syntax as C identifiers, upper
and lower case considered different, all characters
significant. There is however one exception: identifiers
must be more than one character long for parsing reasons. C
style comments are accepted</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><small>/* this is a comment */</small></p>
</table>

<p><small>and #define macros may be used if the need
arises.</small></p>
<a name="3.1. Some constants"></a>
<h2>3.1. Some constants</h2>

<p><small>Before anything else three constants must be
defined, all with the syntax NAME=value, value being an
integer. These constants are:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>EM_WSIZE</small></p>
</td>
<td width="4%"></td>
<td width="80%">

<p><small>Number of bytes in a machine word. This is the
number of bytes a simple <b>loc</b> instruction will put on
the stack.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>EM_PSIZE</small></p>
</td>
<td width="4%"></td>
<td width="80%">

<p><small>Number of bytes in a pointer. This is the number
of bytes a <b>lal</b> instruction will put on the
stack.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>EM_BSIZE</small></p>
</td>
<td width="4%"></td>
<td width="80%">

<p><small>Number of bytes in the hole between AB and LB. If
the calling sequence just saves PC and LB this size will be
twice the pointersize.</small></p>
</td>
</table>

<p><small>EM_WSIZE and EM_PSIZE are checked when a program
is compiled with the resulting code generator. EM_BSIZE is
used by <i>cg</i> to add to the offset of instructions
dealing with locals having positive offsets, i.e.
parameters.</small></p>

<p><small>Optionally one can give here the factors with
which the size and time parts of the cost function have to
be multiplied to ensure they have the same order of
magnitude. This can be done as</small></p>
<pre><small>     TIMEFACTOR = C1/C2
     SIZEFACTOR = C3/C4
</small></pre>

<p><small>Above numbers must be read as rational numbers.
Defaults are 1/1 for both of them. These constants set the
default size/time tradeoff in the code generator, so if
TIMEFACTOR and SIZEFACTOR are both 1 the code generator will
choose at random between two codesequences where one has
cost (10,4) and the other has cost (8,6). See also the
description of the cost field below.</small></p>

<p><small>Also optional is the definition of a printformat
for integers in the codefile. This is given as</small></p>
<pre><small>     FORMAT = string
</small></pre>

<p><small>The default for string is &quot;%ld&quot;. For
example on the PDP 11 one can use</small></p>
<pre><small>     FORMAT= &quot;0%lo&quot;
</small></pre>

<p><small>to satisfy the old UNIX assembler that reads
octal unless followed by a period, and the ACK assembler
that follows C conventions.</small></p>
<a name="3.2. Register definition"></a>
<h2>3.2. Register definition</h2>

<p><small>The next part of the tables describes the various
registers of the machine and defines identifiers to be used
in later parts of the tables. Example for the
PDP-11:</small></p>
<pre><small>REGISTERS:
R0 = ( &quot;r0&quot;,2), REG.
R1 = ( &quot;r1&quot;,2), REG, ODDREG.
R2 = ( &quot;r2&quot;,2), REG.
R3 = ( &quot;r3&quot;,2), REG, ODDREG.
R4 = ( &quot;r4&quot;,2), REG.
LB = ( &quot;r5&quot;,2), LOCALBASE.
R01= ( &quot;r0&quot;,4,R0,R1), REGPAIR.
R23= ( &quot;r2&quot;,4,R2,R3), REGPAIR.
FR0= ( &quot;r0&quot;,4), FREG.
FR1= ( &quot;r1&quot;,4), FREG.
FR2= ( &quot;r2&quot;,4), FREG.
FR3= ( &quot;r3&quot;,4), FREG.
DR0= ( &quot;r0&quot;,8,FR0), DREG.
DR1= ( &quot;r1&quot;,8,FR1), DREG.
DR2= ( &quot;r2&quot;,8,FR2), DREG.
DR3= ( &quot;r3&quot;,8,FR3), DREG.
</small></pre>

<p><small>The identifier before the &rsquo;=&rsquo; sign is
the name of the register as used further on in the table.
The string is the name of the register as far as the
assembler is concerned. The number is the size of the
register in bytes. Identifiers following the number but
within the parentheses are previously defined registernames
that are contained in the register being defined. The
identifiers following the closing parenthesis are properties
of the register. So for example R23 is a register with
assembler name r2, 4 bytes long, contains the registers R2
and R3 and has the property REGPAIR.</small></p>

<p><small>It might seem wise to list each and every
property of a register, so one might give R0 the extra
property MFPTREG named after the not too well known MFPT
instruction on newer PDP-11 types, but this is not a good
idea. Every extra property means the registerset is more
unorthogonal and <i>cg</i> execution time is influenced by
that, because it has to take into account a larger set of
registers that are not equivalent.</small></p>

<p><small>There is a predefined property SCRATCH that is
dynamic, i.e. a register can have the property SCRATCH one
time, and loose it the next. A register has the property
SCRATCH when it has a reference count of one. One needs to
be able to discriminate between SCRATCH registers and
others, because it is only allowed to do arithmetic on
SCRATCH registers.</small></p>
<a name="3.3. Stack token definition"></a>
<h2>3.3. Stack token definition</h2>

<p><small>The next part describes all possible tokens that
can reside on the fakestack during code generation.
Attributes of a token are described in the form of a C
struct declaration, this is followed by the size in bytes of
the token, optionally followed by the cost of the token when
used as an addressing mode and the format to be used on
output.</small></p>

<p><small>Tokens should usually be declared for every
addressing mode of the machine at hand and for every size
directly usable in a machine instruction. Example for the
PDP-11 (incomplete):</small></p>
<pre><small>TOKENS:
</small></pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><small>IREG2 =</small></p>
</td>
<td width="10%"></td>
<td width="10%">
</td>
<td width="10%">

<p><small>{ REGISTER reg; } 2 &quot;*%[reg]&quot; /*
indirect register */</small></p>
</td>
<td width="59%">
</td>
<tr valign="top" align="left">
<td width="10%">

<p><small>REGCONST =</small></p>
</td>
<td width="10%"></td>
<td width="10%"></td>
<td width="10%">

<p><small>{ REGISTER reg; STRING off; } 2 /* not really
addressable */</small></p>
</td>
<td width="59%">
</td>
<tr valign="top" align="left">
<td width="10%">

<p><small>REGOFF2 =</small></p>
</td>
<td width="10%"></td>
<td width="10%">

<p><small>{ REGISTER reg; STRING off; } 2
&quot;%[off](%[reg])&quot;</small></p>
</td>
<td width="10%"></td>
<td width="59%">
</td>
<tr valign="top" align="left">
<td width="10%">

<p><small>IREGOFF2 =</small></p>
</td>
<td width="10%"></td>
<td width="10%"></td>
<td width="10%">

<p><small>{ REGISTER reg; STRING off; } 2
&quot;*%[off](%[reg])&quot;</small></p>
</td>
<td width="59%">
</td>
<tr valign="top" align="left">
<td width="10%">

<p><small>CONST =</small></p>
</td>
<td width="10%"></td>
<td width="10%">
</td>
<td width="10%">

<p><small>{ INT off; } 2 cost=(2,850)
&quot;$%[off].&quot;</small></p>
</td>
<td width="59%">
</td>
<tr valign="top" align="left">
<td width="10%">

<p><small>EXTERN2 =</small></p>
</td>
<td width="10%"></td>
<td width="10%">

<p><small>{ STRING off; } 2 &quot;%[off]&quot;</small></p>
</td>
<td width="10%"></td>
<td width="59%">
</td>
<tr valign="top" align="left">
<td width="10%">

<p><small>IEXTERN2 =</small></p>
</td>
<td width="10%"></td>
<td width="10%"></td>
<td width="10%">

<p><small>{ STRING off; } 2 &quot;*%[off]&quot;</small></p>
</td>
<td width="59%">
</td>
<tr valign="top" align="left">
<td width="10%">

<p><small>PAIRSIGNED =</small></p>
</td>
<td width="10%"></td>
<td width="10%"></td>
<td width="10%">

<p><small>{ REGISTER regeven,regodd; } 2
&quot;%[regeven]&quot;</small></p>
</td>
<td width="59%">
</td>
</table>

<p><small>Types allowed in the struct are REGISTER, INT and
STRING. Tokens without a printformat should never be
output.</small></p>

<p><small>Notice that tokens need not correspond to
addressing modes, the REGCONST token listed above, meaning
the sum of the contents of the register and the constant,
has no corresponding addressing mode on the PDP-11, but is
included so that a sequence of add constant, load indirect,
can be handled efficiently. This REGCONST token is needed as
part of the path</small></p>
<pre><small>     REGISTER -&gt; REGCONST -&gt; REGOFF
</small></pre>

<p><small>of which the first and the last &quot;exist&quot;
and the middle is needed only as an intermediate
step.</small></p>
<a name="3.4. Token expressions"></a>
<h2>3.4. Token expressions</h2>

<p><small>Usually machines have certain collections of
addressing modes that can be used with certain instructions.
The stack patterns in the table are lists of these
collections and since it is cumbersome to write out these
long lists every time, there is a section here to give names
to these collections. Please note that it is not forbidden
to write out a token expression in the remainder of the
table, but for clarity it is usually better not to. Example
for the PDP-11 (incomplete):</small></p>
<pre><small>TOKENEXPRESSIONS:
SOURCE2 = REG + IREG2 + REGOFF2 + IREGOFF2 + CONST + EXTERN2 +
</small></pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p><small>IEXTERN2</small></p>
</td>
<td width="79%">
</td>
</table>

<p><small>SREG = REG * SCRATCH</small></p>

<p><small>Permissible in the expressions are all PASCAL set
operators, i.e.</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">

<p><small>+</small></p>
</td>
<td width="8%"></td>
<td width="18%">

<p><small>set union</small></p>
</td>
<td width="71%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">

<p><small>-</small></p>
</td>
<td width="8%"></td>
<td width="28%">

<p><small>set difference</small></p>
</td>
<td width="61%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">

<p><small>*</small></p>
</td>
<td width="8%"></td>
<td width="32%">

<p><small>set intersection</small></p>
</td>
<td width="57%">
</td>
</table>

<p><small>Every tokenidentifier is also a token expression
identifier denoting the singleton collection of tokens
containing just itself. Every register property as defined
above is also a token expression matching all registers with
that property when on the fakestack. The standard token
expression identifier ALL denotes the collection of all
tokens.</small></p>
<a name="3.5. Expressions"></a>
<h2>3.5. Expressions</h2>

<p><small>Throughout the rest of the table expressions can
be used in some places. This section will give the syntax
and semantics of expressions. There are four types of
expressions: integer, string, register and undefined. Type
checking is performed by <i>cgg</i>. An operator with at
least one undefined operand returns undefined except for the
defined() function mentioned below. An undefined expression
is interpreted as FALSE when it is needed as a truth value.
Basic terms in an expression are</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%">

<p><small>number</small></p>
</td>
<td width="20%"></td>
<td width="68%">

<p><small>A number is a constant of type
integer.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%">

<p><small>string</small></p>
</td>
<td width="20%"></td>
<td width="68%">

<p><small>A string within double quotes is a constant of
type string. All the normal C style escapes may be used
within the string.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>REGIDENT</small></p>
</td>
<td width="16%"></td>
<td width="68%">

<p><small>The name of a register is a constant of type
register.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>$<i>i</i></small></p>
</td>
<td width="28%"></td>
<td width="68%">

<p><small>A dollarsign followed by a number is the
representation of the argument of EM instruction . The type
of the operand is dependent on the instruction, sometimes it
is integer, sometimes it is string. It is undefined when the
instruction has no operand.</small></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="31%"></td>
<td width="68%">
<p><small>Although an exhaustive list could be given
describing all the types the following rule of thumb will
suffice. If it is unimaginable for the operand of the
instruction ever to be something different from a plain
integer, the type is integer, otherwise it is string.<i><br>
Cg</i> makes all necessary conversions, like adding EM_BSIZE
to positive arguments of instructions dealing with locals,
prepending underlines to global names, converting codelabels
into a unique representation etc. Details about this can be
found in the section about machine dependent C
code.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p><small>%[1]</small></p>
</td>
<td width="24%"></td>
<td width="68%">

<p><small>This in general means the token mentioned first
in the stack pattern. When used inside an expression the
token must be a simple register. Type of this is
register.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>%[1.off]</small></p>
</td>
<td width="16%"></td>
<td width="68%">

<p><small>This means field &quot;off&quot; of the first
stack pattern token. Type is the same as that of field
&quot;off&quot;. To use this expression implies a check that
all tokens in the token expression used have the same
attributes.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%">

<p><small>%[1.1]</small></p>
</td>
<td width="20%"></td>
<td width="68%">

<p><small>This is the first subregister of the first token.
Previous comments apply.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p><small>%[b]</small></p>
</td>
<td width="24%"></td>
<td width="60%">

<p><small>The second allocated register.</small></p>
</td>
<td width="7%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%">

<p><small>%[a.2]</small></p>
</td>
<td width="20%"></td>
<td width="68%">

<p><small>The second subregister of the first allocated
register.</small></p>
</td>
</table>

<p><small>All normal C operators apply to integers, the +
operator serves for string concatenation and register
expressions can only be compared to each other. Furthermore
there are some special &quot;functions&quot;:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%">

<p><small>tostring(e)</small></p>
</td>
<td width="10%"></td>
<td width="68%">

<p><small>Converts an integer expression e to a
string.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%">

<p><small>defined(e)</small></p>
</td>
<td width="12%"></td>
<td width="68%">

<p><small>Returns 1 if expression e is defined, 0
otherwise.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%">

<p><small>samesign(e1,e2)</small></p>
</td>
<td width="2%"></td>
<td width="68%">

<p><small>Returns 1 if integer expression e1 and e2 have
the same sign.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%">

<p><small>sfit(e1,e2)</small></p>
</td>
<td width="10%"></td>
<td width="68%">

<p><small>Returns 1 if integer expression e1 fits as a
signed integer into a field of e2 bits, 0
otherwise.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%">

<p><small>ufit(e1,e2)</small></p>
</td>
<td width="10%"></td>
<td width="68%">

<p><small>Same as above but now for unsigned
e1.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>rom(a,n)</small></p>
</td>
<td width="16%"></td>
<td width="68%">

<p><small>Integer expression giving the n&rsquo;th argument
from the <b>rom</b> descriptor pointed at by the a&rsquo;th
EM instruction. Undefined if that descriptor does not
exist.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">

<p><small>loww(a)</small></p>
</td>
<td width="18%"></td>
<td width="68%">

<p><small>Returns the lower half of the argument of the
a&rsquo;th EM instruction. This is used to split the
arguments of a <b>ldc</b> instruction.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>highw(a)</small></p>
</td>
<td width="16%"></td>
<td width="40%">

<p><small>Same for upper half.</small></p>
</td>
<td width="27%">
</td>
</table>
<a name="3.6. Code rules"></a>
<h2>3.6. Code rules</h2>

<p><small>The largest section of the tables consists of the
code generation rules. They specify EM patterns, stack
patterns, code to be generated etc. Syntax is</small></p>
<pre><small>code rule : EM pattern &rsquo;|&rsquo; stack pattern &rsquo;|&rsquo; code &rsquo;|&rsquo;
</small></pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p><small>stack replacement &rsquo;|&rsquo; EM replacement
&rsquo;|&rsquo; cost ;</small></p>
</td>
<td width="79%">
</td>
</table>

<p><small>All parts are optional, however there must be at
least one pattern present. If the empattern is missing the
rule becomes a rewriting rule or <i>coercion</i> to be used
when code generation cannot continue because of an invalid
stack pattern. The code rules are preceded by the
word</small></p>
<pre><small>     CODE:
</small></pre>

<p><small>The next paragraphs describe the various parts in
detail.</small></p>
<a name="3.6.1. The EM pattern"></a>
<h2>3.6.1. The EM pattern</h2>

<p><small>The EM pattern consists of a list of EM mnemonics
followed by a boolean expression. Examples:</small></p>
<pre><small><b>     loe
</b></small></pre>

<p><small>will match a single <b>loe</b>
instruction,</small></p>
<pre><small><b>     loc loc cif</b> $1==2 &amp;&amp; $2==8
</small></pre>

<p><small>is a pattern that will match</small></p>
<pre><small><b>     loc</b> 2
<b>     loc</b> 8
<b>     cif
</b></small></pre>

<p><small>and</small></p>
<pre><small><b>     lol inc stl</b> $1==$3
</small></pre>

<p><small>will match for example</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="6" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><small><b>lol</b> 6</small></p>
<td width="9%"></td>
<td width="20%">

<p><small><b>lol</b> -2</small></p>
</td>
<td width="20%">
</td>
<td width="20%">

<p><small><b>lol</b> 4<b><br>
inc</b></small></p>
</td>
<td width="20%"></td>
<td width="9%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="20%">

<p><small><b>inc</b></small></p>
</td>
<td width="20%">

<p><small>but <i>not</i></small></p>
</td>
<td width="20%">

<p><small><b>inc<br>
stl</b> 6</small></p>
</td>
<td width="20%"></td>
<td width="9%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="20%">

<p><small><b>stl</b> -2</small></p>
</td>
<td width="20%">
</td>
<td width="20%">

<p><small><b>stl</b> -4</small></p>
</td>
<td width="20%"></td>
<td width="9%">
</td>
</table>

<p><small>A missing boolean expression evaluates to
TRUE.</small></p>

<p><small>When the EM pattern is the same as in the
previous code rule the pattern should be given as
&lsquo;...&rsquo;. The code generator will match the longest
EM pattern on every occasion, if two patterns of the same
length match the first in the table will be chosen, while
all patterns of length greater than or equal to three are
considered to be of the same length.</small></p>
<a name="3.6.2. The stack pattern"></a>
<h2>3.6.2. The stack pattern</h2>

<p><small>The stack pattern is a list of token expressions,
usually token expression identifiers for clarity. No boolean
expression is allowed here. The first expression is the one
that matches the top of the stack.</small></p>

<p><small>The pattern can be followed by the word STACK in
which case the pattern only matches if there is nothing else
on the fakestack. The code generator will stack everything
not matched at the start of the rule.</small></p>

<p><small>The pattern can be preceded with the
word</small></p>
<pre><small>     nocoercions:
</small></pre>

<p><small>which tells the code generator not to try to
coerce to the pattern but only to use it when it is already
there. There are two reasons for this construction,
correctness and speed. It is needed for correctness when the
pattern contains a register that is not transparent when
data is moved through it.</small></p>

<p><small>Example: on the PDP-11 the shortest code
for</small></p>
<pre><small><b>     lae</b> a
<b>     loi</b> 8
<b>     lae</b> b
<b>     sti</b> 8
</small></pre>

<p><small>is</small></p>
<pre><small>     movf _a,fr0
     movf fr0,_b
</small></pre>

<p><small>assuming that the floating point processor is in
double precision mode and fr0 is free. Unfortunately this is
not correct since a trap can occur on certain kinds of data.
This could happen if there was a pattern for <b>sti</b> 8
that allowed one to move a floating point register not
preceded by nocoercions: . The code generator would then
find that moving the 8-byte global _a to a floating point
register and then storing it to _b was the cheapest,
assuming that the space/time knob was turned far enough to
space. It is unfortunate that the type information is no
longer present, since if _a really is a floating point
number the move could be made without error.</small></p>

<p><small>The second reason for the nocoercions: construct
is speed. When the code generator has a long list of
possible stack patterns for one EM pattern it can waste a
lot of time trying to find coercions to all of them, while
the mere presence of such a long list indicates that the
table writer has given a lot of special cases. In this case
prepending all the special cases by nocoercions: will stop
the code generator from trying to find things there
aren&rsquo;t.</small></p>
<a name="3.6.3. The code part"></a>
<h2>3.6.3. The code part</h2>

<p><small>The code part consists of three parts, stack
cleanup, register allocation and code to generate. All of
these may be omitted.</small></p>
<a name="3.6.3.1. Stack cleanup"></a>
<h2>3.6.3.1. Stack cleanup</h2>

<p><small>The stack cleanup part describes certain
stacktokens that should neither remain on the fakestack, nor
remembered as contents of registers. This is usually only
required with store operations. The entire fakestack, except
for the part matched in the stack pattern, is searched for
tokens matching the expression and they are copied to the
real stack. Every register that contains the stacktoken is
marked as empty.</small></p>

<p><small>Syntax is</small></p>
<pre><small>     remove(token expression) <i>or
</i>     remove(token expression, boolean expression)
</small></pre>

<p><small>Example:</small></p>
<pre><small>     remove(REGOFF2,%[reg] != LB || %[off] == $1)
</small></pre>

<p><small>is part of a remove() call for use in the
<b>stl</b> code rule. It removes all register offsetted
tokens where the register is not the localbase plus the
local wherein the store is done. The necessity for this can
be seen from the following example:</small></p>
<pre><small><b>     lol</b> 4
<b>     inl</b> 4
<b>     stl</b> 6
</small></pre>

<p><small>Without a proper remove() call in the rule for
<b>inl</b> code would be generated as here</small></p>
<pre><small>     inc 4(r5)
     mov 4(r5),6(r5)
</small></pre>

<p><small>so local 6 would be given the new value of local
4 instead of the old as the EM code prescribed.</small></p>

<p><small>When generating something like a branch
instruction it might be needed to empty the fakestack
completely. This can of course be done with</small></p>
<pre><small>     remove(ALL)
</small></pre>
<a name="3.6.3.2. Register allocation"></a>
<h2>3.6.3.2. Register allocation</h2>

<p><small>The register allocation part describes the kind
of registers needed. Syntax for allocate() is</small></p>
<pre><small>     allocate(itemlist)
</small></pre>

<p><small>where itemlist is a list of three kinds of
things:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>1)</small></p>
</td>
<td width="6%"></td>
<td width="74%">

<p><small>a tokendescription, for example %[1].</small></p>
</td>
<td width="15%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>This will instruct the code generator to
temporarily decrement the reference count of all registers
contained in the token, so that they are available for
allocation in this allocate() call if they were only used in
that token. See example below.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>2)</small></p>
</td>
<td width="6%"></td>
<td width="40%">

<p><small>a register property.</small></p>
</td>
<td width="49%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>This will allocate a register with that property.
The register will be marked as empty at this point.
Lookahead will be performed if necessary.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>3)</small></p>
</td>
<td width="6%"></td>
<td width="80%">

<p><small>a register property with
initialization.</small></p>
</td>
<td width="9%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>This will allocate the register as in 2) but will
also initialize it. This eases the task of the code
generator because it can find a register already filled with
the right value if it exists.</small></p>
</td>
</table>

<p><small>Examples:</small></p>
<pre><small>     allocate(OREG)
</small></pre>

<p><small>will allocate an odd register, while</small></p>
<pre><small>     allocate(REG={REGOFF2,LB,$1})
</small></pre>

<p><small>will allocate a register while simultaneously
filling it with the asked value.<br>
Inside the coercion from SOURCE2 to REGISTER in the PDP-11
table the following allocate() can be found.</small></p>
<pre><small>     allocate(%[1],REG=%[1])
</small></pre>

<p><small>This tells the code generator that registers
contained in %[1] can be used again and asks to fill the
register allocated with %[1]. So if
%[1]={REGOFF2,R3,&quot;4&quot;} and R3 has a reference count
of 1 the following code might be generated.</small></p>
<pre><small>     mov 4(r3),r3
</small></pre>

<p><small>In the rest of the line the registers allocated
can be named by %[a] and %[b.1],%[b.2], i.e. with lower case
letters in order of allocation.</small></p>

<p><small>Warning:</small></p>
<pre><small>     allocate(R3)
</small></pre>

<p><small>is not the way to allocate R3. R3 is not a
register property, so it will be seen as a token description
and the effect is that R3 will have its reference count
decremented.</small></p>
<a name="3.6.3.3. Code"></a>
<h2>3.6.3.3. Code</h2>

<p><small>Code to be generated is specified as a list of
items of the following kind:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>1)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>a string in double quotes (&quot;This is a
string&quot;).</small></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>This is copied to the codefile and a newline ( \n
) is appended. Inside the string all normal C string
conventions are allowed, and substitutions can be made of
the following sorts.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">

<p><small>a)</small></p>
</td>
<td width="6%"></td>
<td width="80%">

<p><small>$1, $2 etc. These are the operands of the
corresponding EM instructions and are printed according to
their type. To put a real &rsquo;$&rsquo; inside the string
it must be doubled (&rsquo;$$&rsquo;).</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">

<p><small>b)</small></p>
</td>
<td width="6%"></td>
<td width="80%">

<p><small>%[1], %[2.reg], %[b.1] etc. These have their
obvious meaning. If they describe a complete token ( %[1] )
the printformat for the token is used. If they stand for a
basic term in an expression they will be printed according
to their type. To put a real &rsquo;%&rsquo; inside the
string it must be doubled (&rsquo;%%&rsquo;).</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="4%">

<p><small>c)</small></p>
</td>
<td width="6%"></td>
<td width="80%">

<p><small>%( arbitrary expression %). This allows inclusion
of arbitrary expressions inside strings. Usually not needed
very often, so that the awkward notation is not too bad.
Note that %(%[1]%) is equivalent to %[1].</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>2)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>a move() call. This has the following
syntax:</small></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<pre><small>     move(token description, token description)
</small></pre>
<!-- INDENTATION -->
<p><small>Moves are handled specially since that enables the
code generator to keep track of register contents.
Example:</small></p>
<!-- INDENTATION -->
<pre><small>     move(R3,{REGOFF2,LB,$1})
</small></pre>
<!-- INDENTATION -->
<p><small>will generate code to move R3 to $1(r5) except
when R3 already was a copy of $1(r5). Then the code will be
omitted. The rules describing how to move things to each
other can be found in the MOVES section described
below.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>3)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>an erase() call. This has the following
syntax:</small></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<pre><small>     erase(register expression)
</small></pre>
<!-- INDENTATION -->
<p><small>This tells the code generator that the register
mentioned no longer has any useful value. This is
<i>necessary</i> after code in the table has changed the
contents of registers. For example, after an add to a
register the register must be erased, because the contents
do no longer match any token.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>4)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>For machines that have condition codes, alas most
of them do, there are provisions to remember condition code
setting and prevent needless testing. To set the condition
code to a token put in the code the following
call:</small></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<pre><small>     test(token)
</small></pre>
<!-- INDENTATION -->
<p><small>where token can be all of the standard forms that
can also be used in move(). This will generate a test if the
condition codes were not already set to that token. It is
also possible to tell <i>cg</i> that a certain operation,
like a preceding add has set the condition codes to some
token with the call</small></p>
<!-- INDENTATION -->
<pre><small>     setcc(token)
</small></pre>
<!-- INDENTATION -->
<p><small>So a sequence of a setcc and a test on the same
token will generate no code. Another allowed call within the
code is</small></p>
<!-- INDENTATION -->
<pre><small>     samecc
</small></pre>
<!-- INDENTATION -->
<p><small>which tells the code generator that condition
codes were unaffected in this rule. If no setcc or samecc
has been given the default is</small></p>
<!-- INDENTATION -->
<pre><small>     nocc
</small></pre>
<!-- INDENTATION -->
<p><small>when a piece of code contained strings, which
tells the code generator that the condition codes have no
useful value any more.</small></p></td>
</table>
<a name="3.6.4. Stack replacement"></a>
<h2>3.6.4. Stack replacement</h2>

<p><small>The stack replacement is a possibly empty list of
items to be pushed onto the fakestack. Three kinds of items
are possible:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>1)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>An item of the form %[1]. This will push the
stacktoken mentioned back onto the stack
unchanged.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>2)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>A register expression. This will push the
register mentioned onto the fakestack.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>3)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>An item of the form { REGOFF2,%[1.reg],$1 }. This
generates a token with tokenidentifier REGOFF2 and
attributes in order of declaration.</small></p>
</td>
</table>

<p><small>All tokens matched by the stack pattern at the
beginning of the code rule are first removed and their
registers deallocated. Items are pushed in the order of
appearance. This means that the last item will be on the top
of the stack after the push. So if the stack pattern
contained two token expressions and they must be pushed back
unchanged, they have to be specified as stack
replacement</small></p>
<pre><small>     %[2] %[1]
</small></pre>

<p><small>and not the other way around.</small></p>
<a name="3.6.5. EM replacement"></a>
<h2>3.6.5. EM replacement</h2>

<p><small>In exceptional cases it might be useful to leave
part of an empattern undone. For example, a <b>sdl</b>
instruction might be split into two <b>stl</b> instructions
when there is no 4-byte quantity on the stack. The
emreplacement part allows one to express this.
Example:</small></p>
<pre><small><b>     stl</b> $1 <b>stl</b> $1+2
</small></pre>

<p><small>The instructions are inserted in the stream so
that they can match the first part of a pattern in the next
step. Note that since the code generator traverses the EM
instructions in a strict linear fashion, it is impossible to
let the EM replacement match later parts of a pattern. So if
there is a pattern</small></p>
<pre><small><b>     loc stl</b> $1==0
</small></pre>

<p><small>and the input is</small></p>
<pre><small><b>     loc</b> 0 <b>sdl</b> 4
</small></pre>

<p><small>the <b>loc</b> 0 will be processed first, then
the <b>sdl</b> might be split into two <b>stl</b>&rsquo;s
but the pattern cannot match now.</small></p>
<a name="3.6.6. Cost"></a>
<h2>3.6.6. Cost</h2>

<p><small>The cost field can be specified when there is
more than one code rule with the same empattern. If the code
generator has a choice between two possibilities to generate
code it will choose the cheapest according to the cost
field. The cost for a code generation is the sum of the
costs of all the coercions needed, plus the cost for freeing
registers plus the cost of the code rule itself.</small></p>

<p><small>The format of the costfield is</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="6" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><small>( nbytes, time )</small></p>
<td width="9%"></td>
<td width="10%">
</td>
<td width="30%"></td>
<td width="10%">

<p><small>or</small></p>
</td>
<td width="10%"></td>
<td width="29%">
</td>
</table>

<p><small>( nbytes, time ) + %[<i>i</i>]</small></p>

<p><small>with time in the metric desired, like nanoseconds
or states. See constants section above. The %[<i>i</i>] in
the second example is used for adding the cost of a certain
address mode used in the code generated. This can of course
be repeated if desired. The cost of the address mode must
then be specified in the token definition
section.</small></p>
<a name="3.6.7. Examples"></a>
<h2>3.6.7. Examples</h2>

<p><small>A list of examples for the PDP-11 is given here.
Far from being complete it gives examples of most kinds of
instructions.</small></p>
<pre><small><b>adi</b> $1==2 | SREG,SOURCE2 |
</small></pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p><small>&quot;add %[2],%[1]&quot; erase(%[1])
setcc(%[1])</small></p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p><small>| %[1] | | (2,450) + %[2]</small></p>
</td>
<td width="79%">
</td>
</table>

<p><small>... | SOURCE2,SREG |</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>&quot;add %[1],%[2]&quot; erase(%[2])
setcc(%[2])</small></p>
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>| %[2] | | (2,450) + %[1]</small></p>
</td>
</table>

<p><small>is an example of the use of the &lsquo;...&rsquo;
construct and shows how to place erase() and setcc()
calls.</small></p>
<pre><small><b>dvi</b> $1==2 | SOURCE2,SPAIRSIGNED |
</small></pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p><small>&quot;div %[1],%[2]&quot; erase(%[2])</small></p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p><small>| %[2.regeven] | |</small></p>
</td>
<td width="79%">
</td>
</table>

<p><small><b>cmi tgt</b> $1==2 | SOURCE2,SOURCE2 |
allocate(REG={CONST,0})</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>&quot;cmp %[2],%[1];ble 1f;inc %[a];1:&quot;
erase(%[a])</small></p>
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>| %[a] | |</small></p>
</td>
</table>

<p><small><b>cal</b> | STACK |</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>&quot;jsr pc,$1&quot;</small></p>
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>| | |</small></p>
</td>
</table>

<p><small><b>lol</b> | | | { REGOFF2, LB, $1 } |
|</small></p>

<p><small><b>stl</b> | SOURCE2 |</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>remove(REGOFF2,%[off]==$1)</small></p>
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>move(%[1],{REGOFF2,LB,$1})</small></p>
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>| | |</small></p>
</td>
</table>

<p><small>| SOURCE2 |</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>allocate(%[1],REGPAIR)</small></p>
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>move(%[1],%[a.2])</small></p>
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>test(%[a.2])</small></p>
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">

<p><small>&quot;sxt %[a.even]&quot; | { PAIRSIGNED, %[a.1],
%[a.2] }| |</small></p>
</td>
</table>

<p><small>This coercion shows how to use the move and test
calls. At first one might think that the testcall is
unnecessary, since the move will have set the condition
codes, but the move may never have been executed if the
register already contained the value, in which case it is
necessary to do the test. If the move was executed the test
will be omitted.</small></p>
<pre><small>| SOURCE2 | allocate(%[1],REG=%[1]) | %[a] | |


<b>sdl</b> | SOURCE2 | | %[1] | <b>stl</b> $1 <b>stl</b> $1+2 |


<b>exg</b> $1==2 | SOURCE2 SOURCE2 | | %[1] %[2] | |
</small></pre>

<p><small>This last example again shows the difference in
the order of the stack pattern and the stack
replacement.</small></p>
<a name="3.7. Move code rules"></a>
<h2>3.7. Move code rules</h2>

<p><small>When issuing a move() call as described above or
a register allocation with initialization, the code
generator has to know which instruction to use for the move.
The code will of course only be generated if it cannot be
omitted. This is listed in the move section of the tables by
giving a list of tuples:</small></p>
<pre><small>     ( source, destination, codepart [ , costfield ] )
</small></pre>

<p><small>where the square brackets mean the costfield is
optional. Example for the PDP-11</small></p>
<pre><small>     MOVES:
     ( CONST %[off]==0 , SOURCE2, &quot;clr %[2]&quot; )
     ( SOURCE2, SOURCE2, &quot;mov %[1],%[2]&quot; )
</small></pre>

<p><small>The moves are scanned from top to bottom, so the
first one that matches will be chosen.</small></p>
<a name="3.8. Test code rules"></a>
<h2>3.8. Test code rules</h2>

<p><small>When issuing a test() call as described above,
the code generator has to know which instruction to use for
the test. The code will only be generated if the condition
codes were not already set to the token. This is listed in
the test section of the tables by giving a list of
tuples:</small></p>
<pre><small>     ( source, codepart [ , costfield ] )
</small></pre>

<p><small>Example for the PDP-11</small></p>
<pre><small>     TESTS:
     ( SOURCE2, &quot;tst %[1]&quot;)
     ( DREG, &quot;tstf %[1]\ncfcc&quot;)
</small></pre>

<p><small>The tests are scanned from top to bottom, so the
first one that matches will be chosen.</small></p>
<a name="3.9. Stacking code rules."></a>
<h2>3.9. Stacking code rules.</h2>

<p><small>When the code generator has to stack a token it
must know which code to use. Since it must at all times be
possible to empty the fakestack even when no registers are
free, it is mandatory that all tokens used must have a rule
attached for stacking them without using a scratch register.
Since however this might be clumsy and a register might in
practice be available it is also possible to give rules
which use a register. On the Intel 8086 for example, there
is no instruction to push a constant without using a
register, and the code needed to do it without, must use
global data and as such is very complicated and wasteful of
memory and time. It can therefore be left to be used in
extreme cases, while in general the constant is pushed
through a register. The stacking rules are listed in the
stack section of the table as a list of tuples:</small></p>
<pre><small>     (source, [ register property ] , codepart [ , costfield ] )
</small></pre>

<p><small>Example for the Intel 8086:</small></p>
<pre><small>     STACKS:
     (CONST, REG, move(%[1],%[a]) &quot;push %[a]&quot;)
     (REG ,, &quot;push %[1]&quot;)
</small></pre>
<a name="4. The files mach.h and mach.c"></a>
<h2>4. The files mach.h and mach.c</h2>

<p><small>The table writer must also supply two files
containing machine dependent declarations and C code. These
files are mach.h and mach.c.</small></p>
<a name="4.1. Types in the code generator"></a>
<h2>4.1. Types in the code generator</h2>

<p><small>Three different types of integer coexist in the
code generator and their range depends on the machine at
hand. The type &rsquo;int&rsquo; is used for things like
labelcounters that won&rsquo;t require more than 16 bits
precision. The type &rsquo;word&rsquo; is used among others
to assemble datawords and is of type &rsquo;long&rsquo;. The
type &rsquo;full&rsquo; is used for addresses and is of type
&rsquo;long&rsquo; if EM_WSIZE&gt;2 or
EM_PSIZE&gt;2.</small></p>

<p><small>In macro and function definitions in later
paragraphs implicit typing will be used for parameters, that
is parameters starting with an &rsquo;s&rsquo; will be of
type string, and the letters
&rsquo;i&rsquo;,&rsquo;w&rsquo;,&rsquo;f&rsquo; will stand
for int, word and full respectively.</small></p>
<a name="4.2. Global variables to work with"></a>
<h2>4.2. Global variables to work with</h2>

<p><small>Some global variables are present in the code
generator that can be manipulated by the routines in mach.h
and mach.c.</small></p>

<p><small>The declarations are:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="40%">

<p><small>FILE *codefile;</small></p>
</td>
<td width="60%">

<p><small>/* code is emitted on this stream */</small></p>
</td>
<tr valign="top" align="left">
<td width="40%">

<p><small>word part_word;</small></p>
</td>
<td width="60%">

<p><small>/* words to be output are put together here
*/</small></p>
</td>
<tr valign="top" align="left">
<td width="40%">

<p><small>int part_size;</small></p>
</td>
<td width="60%">

<p><small>/* number of bytes already put in part_word
*/</small></p>
</td>
<tr valign="top" align="left">
<td width="40%">

<p><small>char str[];</small></p>
</td>
<td width="60%">

<p><small>/* Last string read in */</small></p>
</td>
<tr valign="top" align="left">
<td width="40%">

<p><small>long argval;</small></p>
</td>
<td width="60%">

<p><small>/* Last int read and kept */</small></p>
</td>
</table>
<a name="4.3. Macros in mach.h"></a>
<h2>4.3. Macros in mach.h</h2>

<p><small>In the file mach.h a collection of macros is
defined that have to do with formatting of assembly code for
the machine at hand. Some of these macros can of course be
left undefined in which case the macro calls are left in the
source and will be treated as function calls. These
functions can then be defined in <i>mach.c</i>.</small></p>

<p><small>The macros to be defined are:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>ex_ap(s)</small></p>
</td>
<td width="16%"></td>
<td width="68%">

<p><small>Must print the magic incantations that will mark
the symbol to be exported to other modules. This is the
translation of the EM <b>exa</b> and <b>exp</b>
instructions.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>in_ap(s)</small></p>
</td>
<td width="16%"></td>
<td width="68%">

<p><small>Same to import the symbol. Translation of
<b>ina</b> and <b>inp</b>.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%">

<p><small>newplb(s)</small></p>
</td>
<td width="14%"></td>
<td width="68%">

<p><small>Must print the definition of procedure label
<i>s</i>. If left undefined the newilb() macro is used
instead.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%">

<p><small>newilb(s)</small></p>
</td>
<td width="14%"></td>
<td width="68%">

<p><small>Must print the definition of instruction label
<i>s</i>.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%">

<p><small>newdlb(s)</small></p>
</td>
<td width="14%"></td>
<td width="68%">

<p><small>Must print the definition of data label
<i>s</i>.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%">

<p><small>dlbdlb(s1,s2)</small></p>
</td>
<td width="6%"></td>
<td width="68%">

<p><small>Must define data label <i>s1</i> to be equal to
<i>s2</i>.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="24%">

<p><small>newlbss(s,f)</small></p>
</td>
<td width="8%"></td>
<td width="68%">

<p><small>Must declare a piece of memory initialized to
BSS_INIT(see below) of length <i>f</i> and with label
<i>s</i>.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">

<p><small>cst_fmt</small></p>
</td>
<td width="18%"></td>
<td width="68%">

<p><small>Format to be used when converting constant
arguments of EM instructions to string. Argument to be
formatted will be &rsquo;full&rsquo;.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">

<p><small>off_fmt</small></p>
</td>
<td width="18%"></td>
<td width="68%">

<p><small>Format to be used for integer part of
label+constant, argument will be
&rsquo;full&rsquo;.</small></p>
</td>
</table>

<p><small>fmt_ilb(ip,il,s)</small></p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="31%"></td>
<td width="68%">
<p><small>Must use the numbers <i>ip</i> and <i>il</i> which
are a procedure number and a label number respectively and
copy a string to <i>s</i> that must be unique for that
combination. This procedure is optional, if it is not given
ilb_fmt must be defined as below.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">

<p><small>ilb_fmt</small></p>
</td>
<td width="18%"></td>
<td width="68%">

<p><small>Format to be used for creation of unique
instruction labels. Arguments will be a unique procedure
number (int) and the label number (int).</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">

<p><small>dlb_fmt</small></p>
</td>
<td width="18%"></td>
<td width="68%">

<p><small>Format to be used for printing numeric data
labels. Argument will be &rsquo;int&rsquo;.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">

<p><small>hol_fmt</small></p>
</td>
<td width="18%"></td>
<td width="68%">

<p><small>Format to be used for generation of labels for
space generated by a <b>hol</b> pseudo. Argument will be
&rsquo;int&rsquo;.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">

<p><small>hol_off</small></p>
</td>
<td width="18%"></td>
<td width="68%">

<p><small>Format to be used for printing of the address of
an element in <b>hol</b> space. Arguments will be the offset
in the <b>hol</b> block (word) and the number of the
<b>hol</b> (int).</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%">

<p><small>con_cst(w)</small></p>
</td>
<td width="12%"></td>
<td width="68%">

<p><small>Must generate output that will assemble into one
machineword.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%">

<p><small>con_ilb(s)</small></p>
</td>
<td width="12%"></td>
<td width="68%">

<p><small>Must generate output that will put the address of
the instruction label into the datastream.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%">

<p><small>con_dlb(s)</small></p>
</td>
<td width="12%"></td>
<td width="68%">

<p><small>Must generate output that will put the address of
the data label into the datastream.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%">

<p><small>fmt_id(sf,st)</small></p>
</td>
<td width="6%"></td>
<td width="68%">

<p><small>Must take the string in <i>sf</i> which is a
nonnumeric global label, and transform it into a copy made
to <i>st</i> which will not collide with reserved assembler
words and system labels. This procedure is optional, if it
is not given the id_first macro is used as defined
below.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>id_first</small></p>
</td>
<td width="16%"></td>
<td width="68%">

<p><small>Must be a character. This is prepended to all
nonnumeric global labels if their length is shorter than the
maximum allowed(currently 8) or if they already start with
that character. This is to avoid conflicts of user labels
with system labels.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>BSS_INIT</small></p>
</td>
<td width="16%"></td>
<td width="68%">

<p><small>Must be a constant. This is the value filled in
all the words not initialized explicitly. This is loader and
system dependent. If omitted no initialization is
assumed.</small></p>
</td>
</table>
<a name="4.3.1. Example mach.h for the PDP-11"></a>
<h2>4.3.1. Example mach.h for the PDP-11</h2>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>#define ex_ap(y)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">

<p><small>fprintf(codefile,&quot;\t.globl
%s\n&quot;,y)</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define in_ap(y)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">

<p><small>/* nothing */</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define newplb(x)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">


<p><small>fprintf(codefile,&quot;%s:\n&quot;,x)</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define newilb(x)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">


<p><small>fprintf(codefile,&quot;%s:\n&quot;,x)</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define newdlb(x)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">


<p><small>fprintf(codefile,&quot;%s:\n&quot;,x)</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define</small></p>
</td>
<td width="16%">

<p><small>dlbdlb(x,y)</small></p>
</td>
<td width="16%"></td>
<td width="16%">


<p><small>fprintf(codefile,&quot;%s=%s\n&quot;,x,y)</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define newlbss(l,x)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">


<p><small>fprintf(codefile,&quot;%s:.=.+%d.\n&quot;,l,x);</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define cst_fmt</small></p>
</td>
<td width="16%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>&quot;$%d.&quot;</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define off_fmt</small></p>
</td>
<td width="16%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>&quot;%d.&quot;</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define ilb_fmt</small></p>
</td>
<td width="16%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>&quot;I%x_%x&quot;</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define dlb_fmt</small></p>
</td>
<td width="16%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>&quot;_%d&quot;</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define</small></p>
</td>
<td width="16%">

<p><small>hol_fmt</small></p>
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>&quot;hol%d&quot;</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define hol_off</small></p>
</td>
<td width="16%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>&quot;%ld.+hol%d&quot;</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define con_cst(x)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">


<p><small>fprintf(codefile,&quot;%ld.\n&quot;,x)</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define con_ilb(x)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">

<p><small>fprintf(codefile,&quot;%s\n&quot;,x)</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define con_dlb(x)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">

<p><small>fprintf(codefile,&quot;%s\n&quot;,x)</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define id_first</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">

<p><small>&rsquo;_&rsquo;</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="16%">

<p><small>#define BSS_INIT</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%">

<p><small>0</small></p>
</td>
<td width="35%">
</td>
</table>
<a name="4.4. Functions in mach.c"></a>
<h2>4.4. Functions in mach.c</h2>

<p><small>In mach.c some functions must be supplied, mostly
manipulating data resulting from pseudoinstructions. The
specifications are given here, implicit typing of parameters
as above.</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="36%">

<p><small>con_part(isz,word)</small></p>
</td>
<td width="4%"></td>
<td width="60%">

<p><small>This function must manipulate the globals
part_word and part_size to append the isz bytes contained in
word to the output stream. If part_word is full, i.e.
part_size==EM_WSIZE the function part_flush() may be called
to empty the buffer. This is the function that must go
through the trouble of doing byte order in words
correct.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%">

<p><small>con_mult(w_size)</small></p>
</td>
<td width="8%"></td>
<td width="60%">

<p><small>This function must take the string str[] and
create an integer from the string of size w_size and
generate code to assemble global data for that integer. Only
the sizes for which arithmetic is implemented need be
handled, so if 200-byte integer division is not implemented,
200-byte integer global data do not have to be implemented.
Here one must take care of word order in long
integers.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%">

<p><small>con_float()</small></p>
</td>
<td width="18%"></td>
<td width="60%">

<p><small>This function must generate code to assemble a
floating point number of which the size is contained in
argval and the ASCII representation in str[].</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="34%">

<p><small>prolog(f_nlocals)</small></p>
</td>
<td width="6%"></td>
<td width="60%">

<p><small>This function is called at the start of every
procedure. Function prolog code must be generated, and room
made for local variables for a total of f_nlocals
bytes.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="24%">

<p><small>mes(w_mesno)</small></p>
</td>
<td width="16%"></td>
<td width="60%">

<p><small>This function is called when a <b>mes</b> pseudo
is seen that is not handled by the machine independent part.
The example below probably shows all the table writer ever
has to know about that.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%">

<p><small>segname[]</small></p>
</td>
<td width="22%"></td>
<td width="60%">

<p><small>This is not a function, but an array of four
strings. These strings are put out whenever the code
generator switches segments. Segments are SEGTXT, SEGCON,
SEGROM and SEGBSS in that order.</small></p>
</td>
</table>
<a name="4.4.1. Example mach.c for the PDP-11"></a>
<h2>4.4.1. Example mach.c for the PDP-11</h2>

<p><small>As an example of the sort of code expected, the
mach.c for the PDP-11 is presented here.</small></p>
<pre><small>/*
 * machine dependent back end routines for the PDP-11
 */


con_part(sz,w) register sz; word w; {


</small></pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">

<p><small>while (part_size % sz)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>part_size++;</small></p>
</td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">

<p><small>if (part_size == EM_WSIZE)</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>part_flush();</small></p>
</td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">

<p><small>if (sz == 1) {</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>w &amp;= 0xFF;</small></p>
</td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>if (part_size)</small></p>
</td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>w &lt;&lt;= 8;</small></p>
</td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>part_word |= w;</small></p>
</td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">

<p><small>} else {</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>assert(sz == 2);</small></p>
</td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>part_word = w;</small></p>
</td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">

<p><small>}</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="35%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="16%">

<p><small>part_size += sz;</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="35%">
</td>
</table>

<p><small>}</small></p>

<p><small>con_mult(sz) word sz; {</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>long l;</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>if (sz != 4)</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>fatal(&quot;bad icon/ucon
size&quot;);</small></p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>l = atol(str);</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">


<p><small>fprintf(codefile,&quot;\t%o;%o\n&quot;,(int)(l&gt;&gt;16),(int)l);</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
</table>

<p><small>}</small></p>

<p><small>con_float() {</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>double f;</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>register short *p,i;</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>/*</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>* This code is correct only when the code
generator is</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>* run on a PDP-11 or VAX-11 since it assumes
native</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>* floating point format is PDP-11
format.</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>*/</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>if (argval != 4 &amp;&amp; argval !=
8)</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>fatal(&quot;bad fcon size&quot;);</small></p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>f = atof(str);</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>p = (short *) &amp;f;</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>i = *p++;</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>if (argval == 8) {</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">


<p><small>fprintf(codefile,&quot;\t%o;%o;&quot;,i,*p++);</small></p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>i = *p++;</small></p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>}</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">


<p><small>fprintf(codefile,&quot;\t%o;%o\n&quot;,i,*p++);</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
</table>

<p><small>}</small></p>

<p><small>prolog(nlocals) full nlocals; {</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>fprintf(codefile,&quot;mov r5,-(sp)\nmov
sp,r5\n&quot;);</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>if (nlocals == 0)</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>return;</small></p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>if (nlocals == 2)</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>fprintf(codefile,&quot;tst
-(sp)\n&quot;);</small></p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>else</small></p>
</td>
<td width="16%"></td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>fprintf(codefile,&quot;sub
$%d.,sp\n&quot;,nlocals);</small></p>
</td>
<td width="51%">
</td>
</table>

<p><small>}</small></p>

<p><small>mes(type) word type; {</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="7" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>int argt ;</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>switch ( (int)type ) {</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>case ms_ext :</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>for (;;) {</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>switch ( argt=getarg(</small></p>
</td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>ptyp(sp_cend)|ptyp(sp_pnam)|sym_ptyp) )
{</small></p>
</td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>case sp_cend :</small></p>
</td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>return ;</small></p>
</td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>default:</small></p>
</td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>strarg(argt) ;</small></p>
</td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>fprintf(codefile,&quot;.globl %s\n&quot;,argstr)
;</small></p>
</td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>break ;</small></p>
</td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">
</td>
<td width="16%">

<p><small>}</small></p>
</td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>}</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>default :</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>while ( getarg(any_ptyp) != sp_cend )
;</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">
</td>
<td width="16%">

<p><small>break ;</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="19%">
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="0%"></td>
<td width="16%">

<p><small>}</small></p>
</td>
<td width="16%"></td>
<td width="16%"></td>
<td width="16%"></td>
<td width="19%">
</td>
</table>

<p><small>}</small></p>

<p><small>char *segname[] = {</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="84%">

<p><small>&quot;.text&quot;, /* SEGTXT */</small></p>
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="84%">

<p><small>&quot;.data&quot;, /* SEGCON */</small></p>
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="84%">

<p><small>&quot;.data&quot;, /* SEGROM */</small></p>
</td>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="84%">

<p><small>&quot;.bss&quot; /* SEGBSS */</small></p>
</td>
</table>

<p><small>};</small></p>
<a name="5. Coercions"></a>
<h2>5. Coercions</h2>

<p><small>A central part in code generation is taken by the
<i>coercions</i>. It is the responsibility of the table
writer to provide all necessary coercions so that code
generation can continue. The very minimal set of coercions
are the coercions to unstack every token expression, in
combination with the rules to stack every token.</small></p>

<p><small>If these are present the code generator can
always make the necessary transformations by stacking and
unstacking. Of course for codequality it is usually best to
provide extra coercions to prevent this stacking to take
place. <i>Cg</i> discriminates three types of
coercions:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>1)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Unstacking coercions. This category can use the
allocate() call in its code.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>2)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Splitting coercions, these are the coercions that
split larger tokens into smaller ones.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>3)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Transforming coercions, these are the coercions
that transform a token into another one of the same size.
This category can use the allocate() call in its
code.</small></p>
</td>
</table>

<p><small>When a stack configuration does not match the
stack pattern <i>coercions</i> are searched for in the
following order:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>1)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>First tokens are split if necessary to get their
sizes right.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>2)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Then transforming coercions are found that will
make the pattern match.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>3)</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Finally if the stack pattern is longer than the
fakestack contents unstacking coercions will be used to fill
up the pattern.</small></p>
</td>
</table>

<p><small>At any point, when coercions are missing so code
generation could not continue, the offending tokens are
stacked.</small></p>
<a name="6. Internal workings of the code generator."></a>
<h2>6. Internal workings of the code generator.</h2>
<a name="6.1. Description of tables.c and tables.h contents"></a>
<h2>6.1. Description of tables.c and tables.h contents</h2>

<p><small>In this section the intermediate files will be
described that are produced by <i>cgg</i> and compiled with
machine independent code to produce a code
generator.</small></p>
<a name="6.1.1. Tables.c"></a>
<h2>6.1.1. Tables.c</h2>

<p><small>Tables.c contains a large number of initialized
array&rsquo;s of all sorts. Description of each
follows:</small></p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>byte code rules[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>Pseudo code interpreted by the code generator.
Always starts with some opcode followed by operands
depending on the opcode. Integers in this table are between
0 and 32767 and have a one byte encoding if between 0 and
127.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>char stregclass[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>Number of computed static register class per
register. Two registers are in the same class if they have
the same properties and don&rsquo;t share a common
subregister.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>struct reginfo machregs[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>Info per register. Initialized with representation
string, size, members of the register and set of registers
affected when this one is changed. Also contains room for
runtime information, like contents and reference
count.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>tkdef_t tokens[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>Information per tokentype. Initialized with size,
cost, type of operands and formatstring.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>node_t enodes[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>List of triples representing expressions for the
code generator.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>string code strings[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>List of strings. All strings are put in a list and
checked for duplication, so only one copy per string will
reside here.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>set_t machsets[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>List of token expression sets. Bit 0 of the set is
used for the SCRATCH property of registers, bit 1 upto NREG
are for the corresponding registers and bit NREG+1 upto the
end are for corresponding tokens.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>inst_t tokeninstances[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>List of descriptions for building tokens. Contains
type of rule for building one, plus operands depending on
the type.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>move_t moves[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>List of move rules. Contains token expressions for
source and destination plus cost and index for code
rule.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>byte pattern[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>EM patterns. This is structured internally as
chains of patterns, each chain pointed at by pathash[].
After each pattern the list of possible code rules is
given.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>int pathash[256]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>Indices into pattern[] for all patterns with a
certain low order byte of the hashing
function.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>c1_t c1coercs[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>List of rules to stack tokens. Contains token
expressions, register needed, cost and code
rule.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>c2_t c2coercs[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>List of splitting coercions. Token expressions,
split factor, replacements and code rule.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>c3_t c3coercs[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>List of one to one coercions. Token expressions,
register needed, replacement and code rule.</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p><small>struct reginfo **reglist[]</small></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p><small>List of lists of pointers to register information.
For every property the list is here to find the registers
corresponding to it.</small></p></td>
</table>
<a name="6.1.2. tables.h"></a>
<h2>6.1.2. tables.h</h2>

<p><small>In tables.h various derived constants for the
tables are given. They are then used to determine array
sizes in the actual code generator, plus loop termination in
some cases.</small></p>
<a name="6.2. Other important data structures"></a>
<h2>6.2. Other important data structures</h2>

<p><small>During code generation some other data structures
are used and here is a short description of some of the
important ones.</small></p>

<p><small>Tokens are kept in the code generator as a struct
consisting of one integer <i>t_token</i> which is -1 if the
token is a register, and the number of the token otherwise,
plus an array of <i>TOKENSIZE</i> unions <i>t_att</i> of
which the first is the register number in case of a
register.</small></p>

<p><small>The fakestack is an array of these tokens, there
is a global variable <i>stackheight</i>.</small></p>

<p><small>The results of expressions are kept in a struct
<i>result</i> with elements <i>e_typ</i>, giving the type of
the expression: <i>EV_INT</i>, <i>EV_REG</i> or
<i>EV_STR</i>, and a union <i>e_v</i> which contains the
real result.</small></p>
<a name="6.3. A tour through the sources"></a>
<h2>6.3. A tour through the sources</h2>
<a name="6.3.1. codegen.c"></a>
<h2>6.3.1. codegen.c</h2>

<p><small>The file codegen.c contains one large function
consisting of one giant switch statement. It is the
interpreter for the code generator pseudo code as contained
in code rules[]. This function can call itself recursively
when doing lookahead. Arguments are:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><small>codep</small></p>
</td>
<td width="10%"></td>
<td width="80%">

<p><small>Pointer into code rules, pseudo program
counter.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p><small>ply</small></p>
</td>
<td width="14%"></td>
<td width="78%">

<p><small>Number of EM pattern lookahead
allowed.</small></p>
</td>
<td width="1%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">

<p><small>toplevel</small></p>
</td>
<td width="4%"></td>
<td width="80%">

<p><small>Boolean telling whether this is the toplevel
codegen() or a deeper incarnation.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%">

<p><small>costlimit</small></p>
</td>
<td width="2%"></td>
<td width="80%">

<p><small>A cutoff value to limit searches. If the cost
crosses costlimit the incarnation can terminate.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%">

<p><small>forced</small></p>
</td>
<td width="8%"></td>
<td width="80%">

<p><small>A register number if nonzero. This is used inside
coercions to force the allocate() call to allocate a
register determined by earlier lookahead.</small></p>
</td>
</table>

<p><small>The instructions inplemented in the
switch:</small></p>
<a name="6.3.1.1. DO_NEXTEM"></a>
<h2>6.3.1.1. DO_NEXTEM</h2>

<p><small>Matches the next EM pattern and does lookahead if
necessary to find the best code rule associated with this
pattern. Heuristics are used to determine best code rule
when possible. This is done by calling the distance()
function.</small></p>
<a name="6.3.1.2. DO_COERC"></a>
<h2>6.3.1.2. DO_COERC</h2>

<p><small>This sets the code generator in the state to do a
from stack coercion.</small></p>
<a name="6.3.1.3. DO_XMATCH"></a>
<h2>6.3.1.3. DO_XMATCH</h2>

<p><small>This is done when a match no longer has to be
checked. Used when the nocoercions: trick is used in the
table.</small></p>
<a name="6.3.1.4. DO_MATCH"></a>
<h2>6.3.1.4. DO_MATCH</h2>

<p><small>This is the big one inside this function. It has
the task to transform the contents of the current fakestack
to match the pattern given after it.</small></p>

<p><small>Since the code generator does not know combining
coercions, i.e. there is no way to make a big token out of
two smaller ones, the first thing done is to stack every
token that is too small. After that all tokens too big are
split if possible to the right size.</small></p>

<p><small>Next the coercions are sought that would
transform tokens in place to the right one, plus the
coercions that would pop tokens of the stack. Each of those
might need a register, so a list of registers is generated
and at the end of looking for coercions the function
<i>tuples()</i> is called to generate the list of all
possible <i>n</i>-tuples, where <i>n</i> equals the number
of registers needed.</small></p>

<p><small>Lookahead is now performed if the number of
tuples is greater than one. If no possibility is found
within the costlimit, the fakestack is made smaller by
pushing the bottom token, and this process is repeated until
either a way is found or the fakestack is completely empty
and there is still no way to make the match.</small></p>

<p><small>If there is a way the corresponding coercions are
executed and the code is finished.</small></p>
<a name="6.3.1.5. DO_REMOVE"></a>
<h2>6.3.1.5. DO_REMOVE</h2>

<p><small>Here the remove() call is executed, all tokens
matched by the token expression plus boolean expression are
pushed. In the current implementation there is no attempt to
move those tokens to registers, but that is a possible
future extension.</small></p>
<a name="6.3.1.6. DO_DEALLOCATE"></a>
<h2>6.3.1.6. DO_DEALLOCATE</h2>

<p><small>This one temporarily decrements by one the
reference count of all registers contained in the token
given as argument.</small></p>
<a name="6.3.1.7. DO_REALLOCATE"></a>
<h2>6.3.1.7. DO_REALLOCATE</h2>

<p><small>Here all temporary deallocates are made
undone.</small></p>
<a name="6.3.1.8. DO_ALLOCATE"></a>
<h2>6.3.1.8. DO_ALLOCATE</h2>

<p><small>This is the part that allocates a register and
decides which one to use. If the <i>forced</i> argument was
given its task is simple, otherwise some work must be done.
First the list of possible registers is scanned, all free
registers noted and it is noted whether any of those
registers is already containing the initialization. If no
registers are available some fakestack token is stacked and
the process is repeated.</small></p>

<p><small>After that if an exact match was found, the list
of registers is reduced to one register matching exactly out
of every register class. Now lookahead is performed if
necessary and the register chosen. If an initialization was
given the corresponding move is performed, otherwise the
register is marked empty.</small></p>
<a name="6.3.1.9. DO_LOUTPUT"></a>
<h2>6.3.1.9. DO_LOUTPUT</h2>

<p><small>This prints a string and an expression. Only done
on toplevel.</small></p>
<a name="6.3.1.10. DO_ROUTPUT"></a>
<h2>6.3.1.10. DO_ROUTPUT</h2>

<p><small>Prints a string and a new line. Only on
toplevel.</small></p>
<a name="6.3.1.11. DO_MOVE"></a>
<h2>6.3.1.11. DO_MOVE</h2>

<p><small>Calls the move() function in the code generator
to implement the move() function in the table.</small></p>
<a name="6.3.1.12. DO_ERASE"></a>
<h2>6.3.1.12. DO_ERASE</h2>

<p><small>Marks the register that is its argument as
empty.</small></p>
<a name="6.3.1.13. DO_TOKREPLACE"></a>
<h2>6.3.1.13. DO_TOKREPLACE</h2>

<p><small>This is the token replacement part. It is also
called if there is no token replacement because it has some
other functions as well.</small></p>

<p><small>First the tokens that will be pushed on the
fakestack are computed and stored in a temporary array. Then
the tokens that were matched in this rule are popped and
their embedded registers have their reference count
decremented. After that the replacement tokens are
pushed.</small></p>

<p><small>Finally all registers allocated in this rule have
their reference count decremented. If they were not pushed
on the fakestack they will be available again in the next
code rule.</small></p>
<a name="6.3.1.14. DO_EMREPLACE"></a>
<h2>6.3.1.14. DO_EMREPLACE</h2>

<p><small>Places replacement EM instructions back into the
instruction stream.</small></p>
<a name="6.3.1.15. DO_COST"></a>
<h2>6.3.1.15. DO_COST</h2>

<p><small>Accounts for cost as given in the code
rule.</small></p>
<a name="6.3.1.16. DO_RETURN"></a>
<h2>6.3.1.16. DO_RETURN</h2>

<p><small>Returns from this level of codegen(). Is used at
the end of coercions, move rules etc..</small></p>
<a name="6.3.2. compute.c"></a>
<h2>6.3.2. compute.c</h2>

<p><small>This module computes the various expressions as
given in the enodes[] array. Nothing very special happens
here, it is just a recursive function computing leaves of
expressions and applying the operator.</small></p>
<a name="6.3.3. equiv.c"></a>
<h2>6.3.3. equiv.c</h2>

<p><small>In this module the tuples() function is
implemented. It is given the number of registers needed and
a list of register lists and it constructs a list of tuples
where the <i>n</i>&rsquo;th register comes from the
<i>n</i>&rsquo;th list. Before the list is constructed
however the dynamic register classes are computed. Two
registers are in the same dynamic class if they are in the
same static class and their contents is the
same.</small></p>

<p><small>After that the permute() recursive function is
called to generate the list of tuples. After construction a
generated tuple is added to the list if it is not already
pairwise in the same class or if the register relations are
not the same, i.e. if the first and second register share a
common subregister in one tuple and not in the other they
are considered different.</small></p>
<a name="6.3.4. fillem.c"></a>
<h2>6.3.4. fillem.c</h2>

<p><small>This is the routine that does the reading of EM
instructions and the handling of pseudos. The mach.c module
provided by the table writer is included at the end of this
module. The routine fillemlines() is called by nextem() at
toplevel to make sure there are enough instruction to match.
It fills the EM instruction buffer up to 5 places from the
end to keep room for EM replacement instructions, or up to a
pseudo.</small></p>

<p><small>The dopseudo() function performs the function of
the pseudo last encountered. If the pseudo is a <b>rom</b>
the corresponding label is saved with the contents of the
<b>rom</b> to be available to the code generator later. The
rest of the routines are small service routines for either
input or data output.</small></p>
<a name="6.3.5. gencode.c"></a>
<h2>6.3.5. gencode.c</h2>

<p><small>This module contains routines called by codegen()
to generate the real code to the codefile. The function
gencode() gets a string as argument and copies it to
codefile while processing certain embedded control
characters implementing the $2 and [1.reg] escapes. The
function genexpr() prints the expression given as argument.
It is used to implement the %( expr %) escape. The prtoken()
function interprets the tokenformat as given in the tokens[]
array.</small></p>
<a name="6.3.6. glosym.c"></a>
<h2>6.3.6. glosym.c</h2>

<p><small>This module maintains a list of global symbols
that have a <b>rom</b> pseudo associated. There are
functions to enter a symbol and to find a
symbol.</small></p>
<a name="6.3.7. main.c"></a>
<h2>6.3.7. main.c</h2>

<p><small>Main routine of the code generator. Processes
arguments and flags. Flags available are:</small></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p><small>-d</small></p>
</td>
<td width="6%"></td>
<td width="90%">

<p><small>Sets debug mode if the code generator was not
compiled with the NDEBUG macro defined. Debug mode gives
very long output on stderr indicating all steps of the code
generation process including nesting of the codegen()
function.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p><small>-p<i>n</i></small></p>
</td>
<td width="4%"></td>
<td width="90%">

<p><small>Sets the lookahead depth to <i>n</i>, the
<i>p</i> stands for ply, a well known word in chess playing
programs.</small></p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p><small>-w<i>n</i></small></p>
</td>
<td width="4%"></td>
<td width="90%">

<p><small>Sets the weight percentage for size in the cost
function to <i>n</i> percent. Uses Euclides algorithm to
simplify rationals.</small></p>
</td>
</table>
<a name="6.3.8. move.c"></a>
<h2>6.3.8. move.c</h2>

<p><small>Function to implement the move() pseudo function
in the tables, register initialization and the setcc and
test pseudo functions. First tests are made to try to
prevent the move from really happening. The condition code
register is treated special here. After that, if there is an
after that, the move rule is found and the code
executed.</small></p>
<a name="6.3.9. nextem.c"></a>
<h2>6.3.9. nextem.c</h2>

<p><small>The entry point of this module is nextem(). It
hashes the next three EM instructions, and uses the low
order byte of the hash as an index into the array pathash[],
to find a chain of patterns in the array pattern[], that are
all tried for a match.</small></p>

<p><small>The function trypat() does most of the work
checking patterns. When a pattern is found to match all
instructions the operands of the instruction are placed into
the dollar[] array. Then the boolean expression is tried. If
it matches the function can return, leaving the operands
still in the dollar[] array, so later in the code rule they
can still be used.</small></p>
<a name="6.3.10. reg.c"></a>
<h2>6.3.10. reg.c</h2>

<p><small>Collection of routines to handle registers.
Reference count routines are here, chrefcount() and
getrefcount(), plus routines to erase a single register or
all of them, erasereg() and cleanregs().</small></p>

<p><small>If NDEBUG hasn&rsquo;t been defined, here is also
the routine that checks if the reference count kept with the
register information is in agreement with the number of
times it occurs on the fakestack.</small></p>
<a name="6.3.11. salloc.c"></a>
<h2>6.3.11. salloc.c</h2>

<p><small>Module for string allocation and garbage
collection. Contains entry points myalloc(), a routine
calling malloc() and checking whether room is left,
myfree(), just free(), popstr() a function called from
state.c to free all strings made since the last saved
status. Furthermore there is salloc() which has the size of
the string as parameter and returns a pointer to the
allocated space, while keeping a copy of the pointer for
garbage allocation purposes.</small></p>

<p><small>The function garbage_collect is called from
codegen() at toplevel every now and then, and checks all
places where strings may reside to mark strings as being in
use. Strings not in use are returned to the pool of free
space.</small></p>
<a name="6.3.12. state.c"></a>
<h2>6.3.12. state.c</h2>

<p><small>Set of routines called to save current status,
restore a previous saved state and to free the room occupied
by a saved state. A list of structs is kept here to save the
state. If this is not done, small allocates will take space
from the holes big enough for state saves, and as a result
every new state save will need a new struct. The code
generator runs out of room very rapidly under these
conditions.</small></p>
<a name="6.3.13. subr.c"></a>
<h2>6.3.13. subr.c</h2>

<p><small>Random set of leftover routines.</small></p>
<a name="6.3.13.1. match"></a>
<h2>6.3.13.1. match</h2>

<p><small>Computes whether a certain token matches a
certain token expression. Just computes a bitnumber
according to the algorithm explained with machsets[], and
tests the bit and the boolean expression if it is
there.</small></p>
<a name="6.3.13.2. instance,cinstance"></a>
<h2>6.3.13.2. instance,cinstance</h2>

<p><small>These two functions compute a token from a
description. They differ very slight, cinstance() is used to
compute the result of a coercion in a certain context and
therefore has more arguments, which it uses instead of the
global information instance() works on.</small></p>
<a name="6.3.13.3. eqtoken"></a>
<h2>6.3.13.3. eqtoken</h2>

<p><small>eqtoken computes whether two tokens can be
considered identical. Used to check register contents during
moves mainly.</small></p>
<a name="6.3.13.4. distance"></a>
<h2>6.3.13.4. distance</h2>

<p><small>This is the heuristic function that computes a
distance from the current fakestack contents to the token
pattern in the table. It likes exact matches most, then
matches where at least the sizes are correct and if the
sizes are not correct it likes too large sizes more than too
small, since splitting a token is easier than combining
one.</small></p>
<a name="6.3.13.5. split"></a>
<h2>6.3.13.5. split</h2>

<p><small>This function tries to find a splitting coercion
and executes it immediately when found. The fakestack is
shuffled thoroughly when this happens, so pieces below the
token that must be split are saved first.</small></p>
<a name="6.3.13.6. docoerc"></a>
<h2>6.3.13.6. docoerc</h2>

<p><small>This function executes a coercion that was found.
The same shuffling is done, so the top of the stack is again
saved.</small></p>
<a name="6.3.13.7. stackupto"></a>
<h2>6.3.13.7. stackupto</h2>

<p><small>This function gets a pointer into the fakestack
and must stack every token including the one pointed at up
to the bottom of the fakestack. The first stacking rule
possible is used, so rules using registers must come
first.</small></p>
<a name="6.3.13.8. findcoerc"></a>
<h2>6.3.13.8. findcoerc</h2>

<p><small>Looks for a one to one coercion, if found it
returns a pointer to it and leaves a list of possible
registers to use in the global variable curreglist. This is
used by codegen().</small></p>
<a name="6.3.14. var.c"></a>
<h2>6.3.14. var.c</h2>

<p><small>Global variables used by more than one module.
External definitions are in extern.h.</small></p>
<hr>
</body>
</html>

<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Feb  5 21:46:47 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LLgen, an extended LL(1) parser generator</title>

</head>
<body>

<h1 align="center">LLgen, an extended LL(1) parser generator</h1>

<a href="#1. Introduction">1. Introduction</a><br>
<a href="#2. The Extended Context-Free Syntax">2. The Extended Context-Free Syntax</a><br>
<a href="#3. Grammar Specifications">3. Grammar Specifications</a><br>
<a href="#4. Actions">4. Actions</a><br>
<a href="#5. Error Recovery">5. Error Recovery</a><br>
<a href="#6. Ambiguities and conflicts">6. Ambiguities and conflicts</a><br>
<a href="#7. The LLgen working environment">7. The LLgen working environment</a><br>
<a href="#8. Programs with more than one parser">8. Programs with more than one parser</a><br>
<a href="#References">References</a><br>
<a href="#References">References</a><br>
<a href="#Appendix A : LLgen Input Syntax">Appendix A : LLgen Input Syntax</a><br>
<a href="#Appendix B : An example">Appendix B : An example</a><br>
<a href="#Appendix C. How to use LLgen.">Appendix C. How to use LLgen.</a><br>

<hr>


<p align="center"><i>Ceriel J. H. Jacobs</i> <br>
Dept. of Mathematics and Computer Science <br>
Vrije Universiteit <br>
Amsterdam, The Netherlands</p>


<p align="center" style="margin-top: 1em"><i>ABSTRACT</i></p>

<p style="margin-top: 1em"><i>LLgen</i> provides a tool for
generating an efficient recursive descent parser with no
backtrack from an Extended Context Free syntax. The
<i>LLgen</i> user specifies the syntax, together with code
describing actions associated with the parsing process.
<i>LLgen</i> turns this specification into a number of
subroutines that handle the parsing process.</p>

<p style="margin-top: 1em">The grammar may be ambiguous.
<i>LLgen</i> contains both static and dynamic facilities to
resolve these ambiguities.</p>

<p style="margin-top: 1em">The specification can be split
into several files, for each of which <i>LLgen</i> generates
an output file containing the corresponding part of the
parser. Furthermore, only output files that differ from
their previous version are updated. Other output files are
not affected in any way. This allows the user to recompile
only those output files that have changed.</p>

<p style="margin-top: 1em">The subroutine produced by
<i>LLgen</i> calls a user supplied routine that must return
the next token. This way, the input to the parser can be
split into single characters or higher level tokens.</p>

<p style="margin-top: 1em">An error recovery mechanism is
generated almost completely automatically. It is based on so
called <b>default choices</b>, which are implicitly or
explicitly specified by the user.</p>

<p style="margin-top: 1em"><i>LLgen</i> has succesfully
been used to create recognizers for Pascal, C, and
Modula-2.</p>

<h2>1. Introduction
<a name="1. Introduction"></a>
</h2>


<p style="margin-top: 1em"><i>LLgen</i> provides a tool for
generating an efficient recursive descent parser with no
backtrack from an Extended Context Free syntax. A parser
generated by <i>LLgen</i> will be called <i>LLparse</i> for
the rest of this document. It is assumed that the reader has
some knowledge of LL(1) grammars and recursive descent
parsers. For a survey on the subject, see reference (1).</p>

<p style="margin-top: 1em">Extended LL(1) parsers are an
extension of LL(1) parsers. They are derived from an
Extended Context-Free (ECF) syntax instead of a Context-Free
(CF) syntax. ECF syntax is described in section 2. Section 3
provides an outline of a specification as accepted by
<i>LLgen</i> and also discusses the lexical conventions of
grammar specification files. Section 4 provides a
description of the way the <i>LLgen</i> user can associate
actions with the syntax. These actions must be written in
the programming language C, <small><small>2</small></small>
which also is the target language of <i>LLgen</i>. The error
recovery technique is discussed in section 5. This section
also discusses what the user can do about it. Section 6
discusses the facilities <i>LLgen</i> offers to resolve
ambiguities and conflicts. <i>LLgen</i> offers facilities to
resolve them both at parser generation time and during the
execution of <i>LLparse</i>. Section 7 discusses the
<i>LLgen</i> working environment. It also discusses the
lexical analyzer that must be supplied by the user. This
lexical analyzer must read the input stream and break it up
into basic input items, called <b>tokens</b> for the rest of
this document. Appendix A gives a summary of the
<i>LLgen</i> input syntax. Appendix B gives an example. It
is very instructive to compare this example with the one
given in reference (3). It demonstrates the struggle
<i>LLparse</i> and other LL(1) parsers have with
expressions. Appendix C gives an example of the <i>LLgen</i>
features allowing the user to recompile only those output
files that have changed, using the <i>make</i> program.
<small><small>4</small></small></p>

<h2>2. The Extended Context-Free Syntax
<a name="2. The Extended Context-Free Syntax"></a>
</h2>


<p style="margin-top: 1em">The extensions of an ECF syntax
with respect to an ordinary CF syntax are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">


<p style="margin-top: 1em">1.</p></td>
<td width="16%"></td>
<td width="80%">


<p style="margin-top: 1em">An ECF syntax contains the
repetition operator: &quot;N&quot; (N represents a positive
integer).</p> </td></tr>
<tr valign="top" align="left">
<td width="4%">


<p style="margin-top: 1em">2.</p></td>
<td width="16%"></td>
<td width="80%">


<p style="margin-top: 1em">An ECF syntax contains the
closure set operator without and with upperbound:
&quot;*&quot; and &quot;*N&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="4%">


<p style="margin-top: 1em">3.</p></td>
<td width="16%"></td>
<td width="80%">


<p style="margin-top: 1em">An ECF syntax contains the
positive closure set operator without and with upperbound:
&quot;+&quot; and &quot;+N&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="4%">


<p style="margin-top: 1em">4.</p></td>
<td width="16%"></td>
<td width="80%">


<p style="margin-top: 1em">An ECF syntax contains the
optional operator: &quot;?&quot;, which is a shorthand for
&quot;*1&quot;.</p> </td></tr>
<tr valign="top" align="left">
<td width="4%">


<p style="margin-top: 1em">5.</p></td>
<td width="16%"></td>
<td width="80%">


<p style="margin-top: 1em">An ECF syntax contains
parentheses &quot;[&quot; and &quot;]&quot; which can be
used for grouping.</p></td></tr>
</table>

<p style="margin-top: 1em">We can describe the syntax of an
ECF syntax with an ECF syntax :</p>

<p style="margin-left:10%; margin-top: 1em">grammar : rule
+ <br>
;</p>

<p style="margin-top: 1em">This grammar rule states that a
grammar consists of one or more rules.</p>

<p style="margin-left:10%; margin-top: 1em">rule :
nonterminal &rsquo;:&rsquo; productionrule &rsquo;;&rsquo;
<br>
;</p>

<p style="margin-top: 1em">A rule consists of a left hand
side, the nonterminal, followed by &quot;:&quot;, the
<b>produce symbol</b>, followed by a production rule,
followed by a &quot;;&quot;, indicating the end of the
rule.</p>

<p style="margin-left:10%; margin-top: 1em">productionrule
: production [ &rsquo;|&rsquo; production ]* <br>
;</p>

<p style="margin-top: 1em">A production rule consists of
one or more alternative productions separated by
&quot;|&quot;. This symbol is called the <b>alternation
symbol</b>.</p>

<p style="margin-left:10%; margin-top: 1em">production :
term * <br>
;</p>

<p style="margin-top: 1em">A production consists of a
possibly empty list of terms. So, empty productions are
allowed.</p>

<p style="margin-left:10%; margin-top: 1em">term : element
repeats <br>
;</p>

<p style="margin-top: 1em">A term is an element, possibly
with a repeat specification.</p>

<p style="margin-left:10%; margin-top: 1em">element :
LITERAL <br>
| IDENTIFIER <br>
| &rsquo;[&rsquo; productionrule &rsquo;]&rsquo; <br>
;</p>

<p style="margin-top: 1em">An element can be a LITERAL,
which basically is a single character between apostrophes,
it can be an IDENTIFIER, which is either a nonterminal or a
token, and it can be a production rule between square
parentheses.</p>

<p style="margin-left:10%; margin-top: 1em">repeats :
&rsquo;?&rsquo; <br>
| [ &rsquo;*&rsquo; | &rsquo;+&rsquo; ] NUMBER ? <br>
| NUMBER ? <br>
;</p>

<p style="margin-top: 1em">These are the repeat
specifications discussed above. Notice that this
specification may be empty.</p>

<p style="margin-top: 1em">The class of ECF languages is
identical with the class of CF languages. However, in many
cases recursive definitions of language features can now be
replaced by iterative ones. This tends to reduce the number
of nonterminals and gives rise to very efficient recursive
descent parsers.</p>

<h2>3. Grammar Specifications
<a name="3. Grammar Specifications"></a>
</h2>


<p style="margin-top: 1em">The major part of a <i>LLgen</i>
grammar specification consists of an ECF syntax
specification. Names in this syntax specification refer to
either tokens or nonterminal symbols. <i>LLgen</i> requires
token names to be declared as such. This way it can be
avoided that a typing error in a nonterminal name causes it
to be accepted as a token name. The token declarations will
be discussed later. A name will be regarded as a nonterminal
symbol, unless it is declared as a token name. If there is
no production rule for a nonterminal symbol, <i>LLgen</i>
will complain.</p>

<p style="margin-top: 1em">A grammar specification may also
include some C routines, for instance the lexical analyzer
and an error reporting routine. Thus, a grammar
specification file can contain declarations, grammar rules
and C-code.</p>

<p style="margin-top: 1em">Blanks, tabs and newlines are
ignored, but may not appear in names or keywords. Comments
may appear wherever a name is legal (which is almost
everywhere). They are enclosed in /* ... */, as in C.
Comments do not nest.</p>

<p style="margin-top: 1em">Names may be of arbitrary
length, and can be made up of letters, underscore
&quot;_&quot; and non-initial digits. Upper and lower case
letters are distinct. Only the first 50 characters are
significant. Notice however, that the names for the tokens
will be used by the C-preprocessor. The number of
significant characters therefore depends on the underlying
C-implementation. A safe rule is to make the identifiers
distinct in the first six characters, case ignored.</p>

<p style="margin-top: 1em">There are two kinds of tokens:
those that are declared and are denoted by a name, and
literals.</p>

<p style="margin-top: 1em">A literal consists of a
character enclosed in apostrophes &quot;&rsquo;&quot;. The
&quot;\&quot; is an escape character within literals. The
following escapes are recognized :</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-684021.png" alt="Image grohtml-684021.png"></p>

<p style="margin-top: 1em">Names representing tokens must
be declared before they are used. This can be done using the
&quot;<b>%token</b>&quot; keyword, by writing</p>

<p style="margin-top: 1em">%token name1, name2, . . . ;</p>

<p style="margin-top: 1em"><i>LLparse</i> is designed to
recognize special nonterminal symbols called <b>start
symbols</b>. <i>LLgen</i> allows for more than one start
symbol. Thus, grammars with more than one entry point are
accepted. The start symbols must be declared explicitly
using the &quot;<b>%start</b>&quot; keyword. It can be used
whenever a declaration is legal, f.i.:</p>

<p style="margin-top: 1em">%start LLparse, specification
;</p>

<p style="margin-top: 1em">declares
&quot;specification&quot; as a start symbol and associates
the identifier &quot;LLparse&quot; with it.
&quot;LLparse&quot; will now be the name of the C-function
that must be called to recognize
&quot;specification&quot;.</p>

<h2>4. Actions
<a name="4. Actions"></a>
</h2>


<p style="margin-top: 1em"><i>LLgen</i> allows arbitrary
insertions of actions within the right hand side of a
production rule in the ECF syntax. An action consists of a
number of C statements, enclosed in the brackets
&quot;{&quot; and &quot;}&quot;.</p>

<p style="margin-top: 1em"><i>LLgen</i> generates a parsing
routine for each rule in the grammar. The actions supplied
by the user are just inserted in the proper place. There may
also be declarations before the statements in the action, as
the &quot;{&quot; and &quot;}&quot; are copied into the
target code along with the action. The scope of these
declarations terminates with the closing bracket
&quot;}&quot; of the action.</p>

<p style="margin-top: 1em">In addition to actions, it is
also possible to declare local variables in the parsing
routine, which can then be used in the actions. Such a
declaration consists of a number of C variable declarations,
enclosed in the brackets &quot;{&quot; and &quot;}&quot;. It
must be placed right in front of the &quot;:&quot; in the
grammar rule. The scope of these local variables consists of
the complete grammar rule.</p>

<p style="margin-top: 1em">In order to facilitate
communication between the actions and <i>LLparse</i>, the
parsing routines can be given C-like parameters. Each
parameter must be declared separately, and each of these
declarations must end with a semicolon. For the last
parameter, the semicolon is optional.</p>

<p style="margin-top: 1em">So, for example</p>

<p style="margin-top: 1em">expr(int *pval;) { int fact; } :
<br>
/* <br>
* Rule with one parameter, a pointer to an int. <br>
* Parameter specifications are ordinary C declarations. <br>
* One local variable, of type int. <br>
*/ <br>
factor (&amp;fact) { *pval = fact; } <br>
/* <br>
* factor is another nonterminal symbol. <br>
* One actual parameter is supplied. <br>
* Notice that the parameter passing mechanism is that <br>
* of C. <br>
*/ <br>
[ &rsquo;+&rsquo; factor (&amp;fact) { *pval += fact; } ]*
<br>
/* <br>
* remember the &rsquo;*&rsquo; means zero or more times <br>
*/ <br>
;</p>

<p style="margin-top: 1em">is a rule to recognize a number
of factors, separated by &quot;+&quot;, and to compute their
sum.</p>

<p style="margin-top: 1em"><i>LLgen</i> generates C code,
so the parameter passing mechanism is that of C, as is shown
in the example above.</p>

<p style="margin-top: 1em">Actions often manipulate
attributes of the token just read. For instance, when an
identifier is read, its name must be looked up in a symbol
table. Therefore, <i>LLgen</i> generates code such that at a
number of places in the grammar rule it is defined which
token has last been read. After a token, the last token read
is this token. After a &quot;[&quot; or a &quot;|&quot;, the
last token read is the next token to be accepted by
<i>LLparse</i>. At all other places, it is undefined which
token has last been read. The last token read is available
in the global integer variable <i>LLsymb</i>.</p>

<p style="margin-top: 1em">The user may also specify C-code
wherever a <i>LLgen</i>-declaration is legal. Again, this
code must be enclosed in the brackets &quot;{&quot; and
&quot;}&quot;. This way, the user can define global
declarations and C-functions. To avoid name-conflicts with
identifiers generated by <i>LLgen</i>, <i>LLparse</i> only
uses names beginning with &quot;LL&quot;; the user should
avoid such names.</p>

<h2>5. Error Recovery
<a name="5. Error Recovery"></a>
</h2>


<p style="margin-top: 1em">The error recovery technique
used by <i>LLgen</i> is a modification of the one presented
in reference (5). It is based on <b>default choices</b>,
which just are what the word says, default choices at every
point in the grammar where there is a choice. Thus, in an
alternation, one of the productions is marked as a default
choice, and in a term with a non-fixed repetition
specification there will also be a default choice (between
doing the term (once more) and continuing with the rest of
the production in which the term appears).</p>

<p style="margin-top: 1em">When <i>LLparse</i> detects an
error after having parsed the string
<img src="grohtml-68402-2.png" alt="Image grohtml-68402-2.png">
, the default choices enable it to compute one syntactically
correct continuation, consisting of the tokens
<img src="grohtml-68402-3.png" alt="Image grohtml-68402-3.png">
, such that
<img src="grohtml-68402-4.png" alt="Image grohtml-68402-4.png">
is a string of tokens that is a member of the language
defined by the grammar. Notice, that the computation of this
continuation must terminate, which implies that the default
choices may not invoke recursive rules.</p>

<p style="margin-top: 1em">At each point in this
continuation, a certain number of other tokens could also be
syntactically correct, f.i. the token
<img src="grohtml-68402-5.png" alt="Image grohtml-68402-5.png">
is syntactically correct at point
<img src="grohtml-68402-6.png" alt="Image grohtml-68402-6.png">
in this continuation, if the string
<img src="grohtml-68402-7.png" alt="Image grohtml-68402-7.png">
is a string of the language defined by the grammar for some
string
<img src="grohtml-68402-8.png" alt="Image grohtml-68402-8.png">
and i &gt;= 0.</p>

<p style="margin-top: 1em">The set
<img src="grohtml-68402-9.png" alt="Image grohtml-68402-9.png">
containing all these tokens (including
<img src="grohtml-68402-10.png" alt="Image grohtml-68402-10.png">
) is computed. Next, <i>LLparse</i> discards zero or more
tokens from its input, until a token
<img src="grohtml-68402-11.png" alt="Image grohtml-68402-11.png">
&isin;
<img src="grohtml-68402-12.png" alt="Image grohtml-68402-12.png">
is found. The error is then corrected by inserting i (i
&gt;= 0) tokens
<img src="grohtml-68402-13.png" alt="Image grohtml-68402-13.png">
, such that the string
<img src="grohtml-68402-14.png" alt="Image grohtml-68402-14.png">
is a string of the language defined by the grammar, for some
<img src="grohtml-68402-15.png" alt="Image grohtml-68402-15.png">
. Then, normal parsing is resumed.</p>

<p style="margin-top: 1em">The above is difficult to
implement in a recursive decent parser, and is not the way
<i>LLparse</i> does it, but the effect is the same. In fact,
<i>LLparse</i> maintains a list of tokens that may not be
discarded, which is adjusted as <i>LLparse</i> proceeds.
This list is just a representation of the set
<img src="grohtml-68402-16.png" alt="Image grohtml-68402-16.png">
mentioned above. When an error occurs, <i>LLparse</i>
discards tokens until a token
<img src="grohtml-68402-17.png" alt="Image grohtml-68402-17.png">
that is a member of this list is found. Then, it continues
parsing, following the default choices, inserting tokens
along the way, until this token
<img src="grohtml-68402-18.png" alt="Image grohtml-68402-18.png">
is legal. The selection of the default choices must
guarantee that this will always happen.</p>

<p style="margin-top: 1em">The default choices are
explicitly or implicitly specified by the user. By default,
the default choice in an alternation is the alternative with
the shortest possible terminal production. The user can
select one of the other productions in the alternation as
the default choice by putting the keyword
&quot;<b>%default</b>&quot; in front of it.</p>

<p style="margin-top: 1em">By default, for terms with a
repetition count containing &quot;*&quot; or &quot;?&quot;
the default choice is to continue with the rest of the rule
in which the term appears, and</p>

<p style="margin-top: 1em">term+</p>

<p style="margin-top: 1em">is treated as</p>

<p style="margin-top: 1em">term term* .</p>

<p style="margin-top: 1em">It is also clear, that it can
never be the default choice to do the term (once more),
because this could cause the parser to loop, inserting
tokens forever. However, when the user does not want the
parser to skip tokens that would not have been skipped if
the term would have been the default choice, the skipping of
such a term can be prevented by using the keyword
&quot;<b>%persistent</b>&quot;. For instance, the rule</p>

<p style="margin-top: 1em">commandlist : command* ;</p>

<p style="margin-top: 1em">could be changed to</p>

<p style="margin-top: 1em">commandlist : [ %persistent
command ]* ;</p>

<p style="margin-top: 1em">The effects of this in case of a
syntax error are twofold: The set
<img src="grohtml-68402-19.png" alt="Image grohtml-68402-19.png">
mentioned above will be extended as if &quot;command&quot;
were in the default production, so that fewer tokens will be
skipped. Also, if the first token that is not skipped is a
member of the subset of
<img src="grohtml-68402-20.png" alt="Image grohtml-68402-20.png">
arising from the grammar rule for &quot;command&quot;,
<i>LLparse</i> will enter that rule. So, in fact the default
choice is determined dynamically (by <i>LLparse</i>). Again,
<i>LLgen</i> checks (statically) that <i>LLparse</i> will
always terminate, and if not, <i>LLgen</i> will
complain.</p>

<p style="margin-top: 1em">An important property of this
error recovery method is that, once a rule is started, it
will be finished. This means that all actions in the rule
will be executed normally, so that the user can be sure that
there will be no inconsistencies in his data structures
because of syntax errors. Also, as the method is in fact
error correcting, the actions in a rule only have to deal
with syntactically correct input.</p>

<h2>6. Ambiguities and conflicts
<a name="6. Ambiguities and conflicts"></a>
</h2>


<p style="margin-top: 1em">As <i>LLgen</i> generates a
recursive descent parser with no backtrack, it must at all
times be able to determine what to do, based on the current
input symbol. Unfortunately, this cannot be done for all
grammars. Two kinds of conflicts can arise :</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">


<p style="margin-top: 1em">1)</p></td>
<td width="16%"></td>
<td width="80%">


<p style="margin-top: 1em">the grammar rule is of the form
&quot;production1 | production2&quot;, and <i>LLparse</i>
cannot decide which production to chose. This we call an
<b>alternation conflict</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="4%">


<p style="margin-top: 1em">2)</p></td>
<td width="16%"></td>
<td width="80%">


<p style="margin-top: 1em">the grammar rule is of the form
&quot;[ productionrule ]...&quot;, where ... specifies a
non-fixed repetition count, and <i>LLparse</i> cannot decide
whether to choose &quot;productionrule&quot; once more, or
to continue. This we call a <b>repetition conflict</b>.</p></td></tr>
</table>

<p style="margin-top: 1em">There can be several causes for
conflicts: the grammar may be ambiguous, or the grammar may
require a more complex parser than <i>LLgen</i> can
construct. The conflicts can be examined by inspecting the
verbose (-<b>v</b>) option output file. The conflicts can be
resolved by rewriting the grammar or by using <b>conflict
resolvers</b>. The mechanism described here is based on the
attributed parsing of reference (6).</p>

<p style="margin-top: 1em">An alternation conflict can be
resolved by putting an <b>if condition</b> in front of the
first conflicting production. It consists of a
&quot;<b>%if</b>&quot; followed by a C-expression between
parentheses. <i>LLparse</i> will then evaluate this
expression whenever a token is met at this point on which
there is a conflict, so the conflict will be resolved
dynamically. If the expression evaluates to non-zero, the
first conflicting production is chosen, otherwise one of the
remaining ones is chosen.</p>

<p style="margin-top: 1em">An alternation conflict can also
be resolved using the keywords &quot;<b>%prefer</b>&quot; or
&quot;<b>%avoid</b>&quot;. &quot;<b>%prefer</b>&quot; is
equivalent in behaviour to &quot;<b>%if</b> (1)&quot;.
&quot;<b>%avoid</b>&quot; is equivalent to &quot;<b>%if</b>
(0)&quot;. In these cases however,
&quot;<b>%prefer</b>&quot; and &quot;<b>%avoid</b>&quot;
should be used, as they resolve the conflict statically and
thus give rise to better C-code.</p>

<p style="margin-top: 1em">A repetition conflict can be
resolved by putting a <b>while condition</b> right after the
opening parentheses. This while condition consists of a
&quot;<b>%while</b>&quot; followed by a C-expression between
parentheses. Again, <i>LLparse</i> will then evaluate this
expression whenever a token is met at this point on which
there is a conflict. If the expression evaluates to
non-zero, the repeating part is chosen, otherwise the parser
continues with the rest of the rule. Appendix B will give an
example of these features.</p>

<p style="margin-top: 1em">A useful aid in writing conflict
resolvers is the &quot;<b>%first</b>&quot; keyword. It is
used to declare a C-macro that forms an expression returning
1 if the parameter supplied can start a specified
nonterminal, f.i.:</p>

<p style="margin-top: 1em">%first fmac, nonterm ;</p>

<p style="margin-top: 1em">declares &quot;fmac&quot; as a
macro with one parameter, whose value is a token number. If
the parameter X can start the nonterminal
&quot;nonterm&quot;, &quot;fmac(X)&quot; is true, otherwise
it is false.</p>

<h2>7. The LLgen working environment
<a name="7. The LLgen working environment"></a>
</h2>


<p style="margin-top: 1em"><i>LLgen</i> generates a number
of files: one for each input file, and two other files:
<i>Lpars.c</i> and <i>Lpars.h</i>. <i>Lpars.h</i> contains
&quot;#-define&quot;s for the tokennames. <i>Lpars.c</i>
contains the error recovery routines and tables. Only those
output files that differ from their previous version are
updated. See appendix C for a possible application of this
feature.</p>

<p style="margin-top: 1em">The names of the output files
are constructed as follows: in the input file name, the
suffix after the last point is replaced by a &quot;c&quot;.
If no point is present in the input file name,
&quot;.c&quot; is appended to it. <i>LLgen</i> checks that
the filename constructed this way in fact represents a
previous version, or does not exist already.</p>

<p style="margin-top: 1em">The user must provide some
environment to obtain a complete program. Routines called
<i>main</i> and <i>LLmessage</i> must be defined. Also, a
lexical analyzer must be provided.</p>

<p style="margin-top: 1em">The routine <i>main</i> must be
defined, as it must be in every C-program. It should
eventually call one of the startsymbol routines.</p>

<p style="margin-top: 1em">The routine <i>LLmessage</i>
must accept one parameter, whose value is a token number,
zero or -1. <br>
A zero parameter indicates that the current token (the one
in the external variable <i>LLsymb</i>) is deleted. <br>
A -1 parameter indicates that the parser expected end of
file, but didn&rsquo;t get it. The parser will then skip
tokens until end of file is detected. <br>
A parameter that is a token number (a positive parameter)
indicates that this token is to be inserted in front of the
token currently in <i>LLsymb</i>. The user can give the
token the proper attributes. Also, the user must take care,
that the token currently in <i>LLsymb</i> is again returned
by the <b>next</b> call to the lexical analyzer, with the
proper attributes. So, the lexical analyzer must have a
facility to push back one token.</p>

<p style="margin-top: 1em">The user may also supply his own
error recovery routines, or handle errors differently. For
this purpose, the name of a routine to be called when an
error occurs may be declared using the keyword
<b>%onerror</b>. This routine takes two parameters. The
first one is either the token number of the token expected,
or 0. In the last case, the error occurred at a choice. In
both cases, the routine must ensure that the next call to
the lexical analyser returns the token that replaces the
current one. Of course, that could well be the current one,
in which case <i>LLparse</i> recovers from the error. The
second parameter contains a list of tokens that are not
skipped at the error point. The list is in the form of a
null-terminated array of integers, whose address is
passed.</p>

<p style="margin-top: 1em">The user must supply a lexical
analyzer to read the input stream and break it up into
tokens, which are passed to <i>LLparse.</i> It should be an
integer valued function, returning the token number. The
name of this function can be declared using the
&quot;<b>%lexical</b>&quot; keyword. This keyword can be
used wherever a declaration is legal and may appear only
once in the grammar specification, f.i.:</p>

<p style="margin-top: 1em">%lexical scanner ;</p>

<p style="margin-top: 1em">declares &quot;scanner&quot; as
the name of the lexical analyzer. The default name for the
lexical analyzer is &quot;yylex&quot;. The reason for this
funny name is that a useful tool for constructing lexical
analyzers is the <i>Lex</i> program,
<small><small>7</small></small> which generates a routine of
that name.</p>

<p style="margin-top: 1em">The token numbers are chosen by
<i>LLgen</i>. The token number for a literal is the
numerical value of the character in the local character set.
If the tokens have a name, the &quot;#&nbsp;define&quot;
mechanism of C is used to give them a value and to allow the
lexical analyzer to return their token numbers symbolically.
These &quot;#&nbsp;define&quot;s are collected in the file
<i>Lpars.h</i> which can be &quot;#&nbsp;include&quot;d in
any file that needs the token-names. The maximum token
number chosen is defined in the macro
<i>LL_MAXTOKNO</i>.</p>

<p style="margin-top: 1em">The lexical analyzer must signal
the end of input to <i>LLparse</i> by returning a number
less than or equal to zero.</p>

<h2>8. Programs with more than one parser
<a name="8. Programs with more than one parser"></a>
</h2>


<p style="margin-top: 1em"><i>LLgen</i> offers a simple
facility for having more than one parser in a program: in
this case, the user can change the names of global
procedures, variables, etc, by giving a different prefix,
like this:</p>

<p style="margin-top: 1em">%prefix XX ;</p>

<p style="margin-top: 1em">The effect of this is that all
global names start with XX instead of LL, for the parser
that has this prefix. This holds for the variables
<i>LLsymb</i>, which now is called <i>XXsymb</i>, for the
routine <i>LLmessage</i>, which must now be called
<i>XXmessage</i>, and for the macro <i>LL_MAXTOKNO</i>,
which is now called <i>XX_MAXTOKNO</i>. <i>LL.output</i> is
now <i>XX.output</i>, and <i>Lpars.c</i> and <i>Lpars.h</i>
are now called <i>XXpars.c</i> and <i>XXpars.h</i>.</p>

<h2>References
<a name="References"></a>
</h2>


<h2>References
<a name="References"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="5%">


<p style="margin-top: 1em">1.</p></td>
<td width="8%"></td>
<td width="87%">


<p style="margin-top: 1em">M. Griffiths, &ldquo;LL(1)
Grammars and Analysers&rdquo; in <i>Compiler Construction,
An Advanced Course,</i> ed. F. L. Bauer and J. Eickel,
Springer-Verlag, New York, N.Y. (1974).</p></td></tr>
<tr valign="top" align="left">
<td width="5%">


<p style="margin-top: 1em">2.</p></td>
<td width="8%"></td>
<td width="87%">


<p style="margin-top: 1em">B. W. Kernighan and D. M.
Ritchie, <i>The C Programming Language,</i> Prentice-Hall,
Inc., Englewood Cliffs, New Jersey (1978).</p></td></tr>
<tr valign="top" align="left">
<td width="5%">


<p style="margin-top: 1em">3.</p></td>
<td width="8%"></td>
<td width="87%">


<p style="margin-top: 1em">S. C. Johnson, &ldquo;Yacc: Yet
Another Compiler Compiler,&rdquo; Comp. Sci. Tech. Rep. No.
32, Bell Laboratories, Murray Hill, New Jersey (1975).</p></td></tr>
<tr valign="top" align="left">
<td width="5%">


<p style="margin-top: 1em">4.</p></td>
<td width="8%"></td>
<td width="87%">


<p style="margin-top: 1em">S. I. Feldman, &ldquo;Make - A
Program for Maintaining Computer Programs,&rdquo;
<i>Software - Practice and Experience</i> <b>10</b>(8),
pp.&nbsp;255-265 (August 1979).</p></td></tr>
<tr valign="top" align="left">
<td width="5%">


<p style="margin-top: 1em">5.</p></td>
<td width="8%"></td>
<td width="87%">


<p style="margin-top: 1em">J. Rohrich, &ldquo;Methods for
the Automatic Construction of Error Correcting
Parsers,&rdquo; <i>Acta Informatica</i> <b>13</b>,
pp.&nbsp;115-139 (1980).</p></td></tr>
<tr valign="top" align="left">
<td width="5%">


<p style="margin-top: 1em">6.</p></td>
<td width="8%"></td>
<td width="87%">


<p style="margin-top: 1em">D. R. Milton, L. W. Kirchhoff,
and B. R. Rowland, &ldquo;An ALL(1) Compiler
Generator,&rdquo; <i>SIGPLAN Notices</i> <b>14</b>(8),
pp.&nbsp;152-157 (August 1979).</p></td></tr>
<tr valign="top" align="left">
<td width="5%">


<p style="margin-top: 1em">7.</p></td>
<td width="8%"></td>
<td width="87%">


<p style="margin-top: 1em">M. E. Lesk, &ldquo;Lex - A
Lexical Analyser Generator,&rdquo; Comp. Sci. Tech. Rep. No.
39, Bell Laboratories, Murray Hill, New Jersey (October
1975).</p> </td></tr>
</table>

<h2>Appendix A : LLgen Input Syntax
<a name="Appendix A : LLgen Input Syntax"></a>
</h2>


<p style="margin-top: 1em">This appendix has a description
of the <i>LLgen</i> input syntax, as a <i>LLgen</i>
specification. As a matter of fact, the current version of
<i>LLgen</i> is written with <i>LLgen</i>.</p>

<p style="margin-top: 1em">/* <br>
* First the declarations of the terminals <br>
* The order is not important <br>
*/</p>

<p style="margin-top: 1em">%token IDENTIFIER; /* terminal
or nonterminal name */ <br>
%token NUMBER; <br>
%token LITERAL;</p>

<p style="margin-top: 1em">/* <br>
* Reserved words <br>
*/</p>

<p style="margin-top: 1em">%token TOKEN; /* %token */ <br>
%token START; /* %start */ <br>
%token PERSISTENT; /* %persistent */ <br>
%token IF; /* %if */ <br>
%token WHILE; /* %while */ <br>
%token AVOID; /* %avoid */ <br>
%token PREFER; /* %prefer */ <br>
%token DEFAULT; /* %default */ <br>
%token LEXICAL; /* %lexical */ <br>
%token PREFIX; /* %prefix */ <br>
%token ONERROR; /* %onerror */ <br>
%token FIRST; /* %first */</p>

<p style="margin-top: 1em">/* <br>
* Declare LLparse to be a C-routine that recognizes
&quot;specification&quot; <br>
*/</p>

<p style="margin-top: 1em">%start LLparse,
specification;</p>

<p style="margin-top: 1em">specification <br>
: declaration* <br>
;</p>

<p style="margin-top: 1em">declaration <br>
: START <br>
IDENTIFIER &rsquo;,&rsquo; IDENTIFIER <br>
&rsquo;;&rsquo; <br>
| &rsquo;{&rsquo; <br>
/* Read C-declaration here */ <br>
&rsquo;}&rsquo; <br>
| TOKEN <br>
IDENTIFIER <br>
[ &rsquo;,&rsquo; IDENTIFIER ]* <br>
&rsquo;;&rsquo; <br>
| FIRST <br>
IDENTIFIER &rsquo;,&rsquo; IDENTIFIER <br>
&rsquo;;&rsquo; <br>
| LEXICAL <br>
IDENTIFIER <br>
&rsquo;;&rsquo; <br>
| PREFIX <br>
IDENTIFIER <br>
&rsquo;;&rsquo; <br>
| ONERROR <br>
IDENTIFIER</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p>&rsquo;;&rsquo;</p></td></tr>
</table>

<p>| rule <br>
;</p>

<p style="margin-top: 1em">rule : IDENTIFIER parameters?
ldecl? <br>
&rsquo;:&rsquo; productions <br>
&rsquo;;&rsquo; <br>
;</p>

<p style="margin-top: 1em">ldecl : &rsquo;{&rsquo; <br>
/* Read C-declaration here */ <br>
&rsquo;}&rsquo; <br>
;</p>

<p style="margin-top: 1em">productions <br>
: simpleproduction <br>
[ &rsquo;|&rsquo; simpleproduction ]* <br>
;</p>

<p style="margin-top: 1em">simpleproduction <br>
: DEFAULT?</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p>[ IF &rsquo;(&rsquo; /* Read C-expression here */
&rsquo;)&rsquo;</p> </td></tr>
</table>

<p>| PREFER <br>
| AVOID <br>
]? <br>
[ element repeats ]* <br>
;</p>

<p style="margin-top: 1em">element : &rsquo;{&rsquo; <br>
/* Read action here */ <br>
&rsquo;}&rsquo; <br>
| &rsquo;[&rsquo; [ WHILE &rsquo;(&rsquo; /* Read
C-expression here */ &rsquo;)&rsquo; ]? <br>
PERSISTENT? <br>
productions <br>
&rsquo;]&rsquo; <br>
| LITERAL <br>
| IDENTIFIER parameters? <br>
;</p>

<p style="margin-top: 1em">parameters <br>
: &rsquo;(&rsquo; /* Read C-parameters here */
&rsquo;)&rsquo; <br>
;</p>

<p style="margin-top: 1em">repeats : /* empty */ <br>
| [ &rsquo;*&rsquo; | &rsquo;+&rsquo; ] NUMBER? <br>
| NUMBER <br>
| &rsquo;?&rsquo; <br>
;</p>

<h2>Appendix B : An example
<a name="Appendix B : An example"></a>
</h2>


<p style="margin-top: 1em">This example gives the complete
<i>LLgen</i> specification of a simple desk calculator. It
has 26 registers, labeled &quot;a&quot; through
&quot;z&quot;, and accepts arithmetic expressions made up of
the C operators +, -, *, /, %, &amp;, and |, with their
usual priorities. The value of the expression is printed. As
in C, an integer that begins with 0 is assumed to be octal;
otherwise it is assumed to be decimal.</p>

<p style="margin-top: 1em">Although the example is short
and not very complicated, it demonstrates the use of if and
while conditions. In the example they are in fact used to
reduce the number of nonterminals, and to reduce the
overhead due to the recursion that would be involved in
parsing an expression with an ordinary recursive descent
parser. In an ordinary LL(1) grammar there would be one
nonterminal for each operator priority. The example shows
how we can do it all with one nonterminal, no matter how
many priority levels there are.</p>

<p style="margin-top: 1em">{ <br>
#include &lt;stdio.h&gt; <br>
#include &lt;ctype.h&gt; <br>
#define MAXPRIO 5 <br>
#define prio(op) (ptab[op])</p>

<p style="margin-top: 1em">struct token { <br>
int t_tokno; /* token number */ <br>
int t_tval; /* Its attribute */ <br>
} stok = { 0,0 }, tok;</p>

<p style="margin-top: 1em">int nerrors = 0; <br>
int regs[26]; /* Space for the registers */ <br>
int ptab[128]; /* Attribute table */</p>

<p style="margin-top: 1em">struct token <br>
nexttok() { /* Read next token and return it */ <br>
register c; <br>
struct token new;</p>

<p style="margin-top: 1em">while ((c = getchar()) ==
&rsquo; &rsquo; || c == &rsquo;\t&rsquo;) { /* nothing */ }
<br>
if (isdigit(c)) new.t_tokno = DIGIT; <br>
else if (islower(c)) new.t_tokno = IDENT; <br>
else new.t_tokno = c; <br>
if (c &gt;= 0) new.t_tval = ptab[c]; <br>
return new; <br>
} }</p>

<p style="margin-top: 1em">%token DIGIT, IDENT; <br>
%start parse, list;</p>

<p style="margin-top: 1em">list : stat* ;</p>

<p style="margin-top: 1em">stat { int ident, val; } : <br>
%if (stok = nexttok(), <br>
stok.t_tokno == &rsquo;=&rsquo;) <br>
/* The conflict is resolved by looking one further <br>
* token ahead. The grammar is LL(2) <br>
*/ <br>
IDENT <br>
{ ident = tok.t_tval; } <br>
&rsquo;=&rsquo; expr(1,&amp;val) &rsquo;\n&rsquo; <br>
{ if (!nerrors) regs[ident] = val; } <br>
| expr(1,&amp;val) &rsquo;\n&rsquo; <br>
{ if (!nerrors) printf(&quot;%d\n&quot;,val); } <br>
| &rsquo;\n&rsquo; <br>
;</p>

<p style="margin-top: 1em">expr(int level; int *val;) { int
expr; } : <br>
factor(val) <br>
[ %while (prio(tok.t_tokno) &gt;= level) <br>
/* Swallow operators as long as their priority is <br>
* larger than or equal to the level of this invocation <br>
*/ <br>
&rsquo;+&rsquo; expr(prio(&rsquo;+&rsquo;)+1,&amp;expr) <br>
{ *val += expr; } <br>
/* This states that &rsquo;+&rsquo; groups left to right. If
it <br>
* should group right to left, the rule should read: <br>
* &rsquo;+&rsquo; expr(prio(&rsquo;+&rsquo;),&amp;expr) <br>
*/ <br>
| &rsquo;-&rsquo; expr(prio(&rsquo;-&rsquo;)+1,&amp;expr)
<br>
{ *val -= expr; } <br>
| &rsquo;*&rsquo; expr(prio(&rsquo;*&rsquo;)+1,&amp;expr)
<br>
{ *val *= expr; } <br>
| &rsquo;/&rsquo; expr(prio(&rsquo;/&rsquo;)+1,&amp;expr)
<br>
{ *val /= expr; } <br>
| &rsquo;%&rsquo; expr(prio(&rsquo;%&rsquo;)+1,&amp;expr)
<br>
{ *val %= expr; } <br>
| &rsquo;&amp;&rsquo;
expr(prio(&rsquo;&amp;&rsquo;)+1,&amp;expr) <br>
{ *val &amp;= expr; } <br>
| &rsquo;|&rsquo; expr(prio(&rsquo;|&rsquo;)+1,&amp;expr)
<br>
{ *val |= expr; } <br>
]* <br>
/* Notice the &quot;*&quot; here. It is important. <br>
*/</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p>;</p></td></tr>
</table>

<p style="margin-top: 1em">factor(int *val;): <br>
&rsquo;(&rsquo; expr(1,val) &rsquo;)&rsquo; <br>
| &rsquo;-&rsquo; expr(MAXPRIO+1,val) <br>
{ *val = -*val; } <br>
| number(val) <br>
| IDENT <br>
{ *val = regs[tok.t_tval]; } <br>
;</p>

<p style="margin-top: 1em">number(int *val;) { int base; }
<br>
: DIGIT <br>
{ base = (*val=tok.t_tval)==0?8:10; } <br>
[ DIGIT <br>
{ *val = base * *val + tok.t_tval; } <br>
]* ;</p>

<p style="margin-top: 1em">%lexical scanner ; <br>
{ <br>
scanner() { <br>
if (stok.t_tokno) { /* a token has been inserted or read
ahead */ <br>
tok = stok; <br>
stok.t_tokno = 0; <br>
return tok.t_tokno; <br>
} <br>
if (nerrors &amp;&amp; tok.t_tokno == &rsquo;\n&rsquo;) {
<br>
printf(&quot;ERROR\n&quot;); <br>
nerrors = 0; <br>
} <br>
tok = nexttok(); <br>
return tok.t_tokno; <br>
}</p>

<p style="margin-top: 1em">LLmessage(insertedtok) { <br>
nerrors++; <br>
if (insertedtok) { /* token inserted, save old token */ <br>
stok = tok; <br>
tok.t_tval = 0; <br>
if (insertedtok &lt; 128) tok.t_tval = ptab[insertedtok];
<br>
} <br>
}</p>

<p style="margin-top: 1em">main() { <br>
register *p;</p>

<p style="margin-top: 1em">for (p = ptab; p &lt;
&amp;ptab[128]; p++) *p = 0; <br>
/* for letters, their attribute is their index in the regs
array */ <br>
for (p = &amp;ptab[&rsquo;a&rsquo;]; p &lt;=
&amp;ptab[&rsquo;z&rsquo;]; p++) *p = p -
&amp;ptab[&rsquo;a&rsquo;]; <br>
/* for digits, their attribute is their value */ <br>
for (p = &amp;ptab[&rsquo;0&rsquo;]; p &lt;=
&amp;ptab[&rsquo;9&rsquo;]; p++) *p = p -
&amp;ptab[&rsquo;0&rsquo;]; <br>
/* for operators, their attribute is their priority */ <br>
ptab[&rsquo;*&rsquo;] = 4; <br>
ptab[&rsquo;/&rsquo;] = 4; <br>
ptab[&rsquo;%&rsquo;] = 4; <br>
ptab[&rsquo;+&rsquo;] = 3; <br>
ptab[&rsquo;-&rsquo;] = 3; <br>
ptab[&rsquo;&amp;&rsquo;] = 2; <br>
ptab[&rsquo;|&rsquo;] = 1; <br>
parse();</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p>exit(nerrors);</p></td></tr>
</table>

<p>} }</p>

<h2>Appendix C. How to use LLgen.
<a name="Appendix C. How to use LLgen."></a>
</h2>


<p style="margin-top: 1em">This appendix demonstrates how
<i>LLgen</i> can be used in combination with the <i>make</i>
program, to make effective use of the <i>LLgen</i>-feature
that it only changes output files when neccessary.
<i>Make</i> uses a &quot;makefile&quot;, which is a file
containing dependencies and associated commands. A
dependency usually indicates that some files depend on other
files. When a file depends on another file and is older than
that other file, the commands associated with the dependency
are executed.</p>

<p style="margin-top: 1em">So, <i>make</i> seems just the
program that we always wanted. However, it is not very good
in handling programs that generate more than one file. As
usual, there is a way around this problem. A sample makefile
follows:</p>

<p style="margin-top: 1em"># The grammar exists of the
files decl.g, stat.g and expr.g. <br>
# The &quot;.o&quot;-files are the result of a
C-compilation.</p>

<p style="margin-top: 1em">GFILES = decl.g stat.g expr.g
<br>
OFILES = decl.o stat.o expr.o Lpars.o <br>
LLOPT =</p>

<p style="margin-top: 1em"># As make does&rsquo;nt handle
programs that generate more than one <br>
# file well, we just don&rsquo;t tell make about it. <br>
# We just create a dummy file, and touch it whenever LLgen
is <br>
# executed. This way, the dummy in fact depends on the
grammar <br>
# files. <br>
# Then, we execute make again, to do the C-compilations and
<br>
# such.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="100%">


<p>all:</p></td></tr>
<tr valign="top" align="left">
<td width="100%">


<p>dummy</p></td></tr>
</table>

<p>make parser</p>

<p style="margin-top: 1em">dummy: $(GFILES) <br>
LLgen $(LLOPT) $(GFILES) <br>
touch dummy</p>

<p style="margin-top: 1em">parser: $(OFILES) <br>
$(CC) -o parser $(LDFLAGS) $(OFILES)</p>

<p style="margin-top: 1em"># Some dependencies without
actions : <br>
# make already knows what to do about them</p>

<p style="margin-top: 1em">Lpars.o: Lpars.h <br>
stat.o: Lpars.h <br>
decl.o: Lpars.h <br>
expr.o: Lpars.h</p>
<hr>
</body>
</html>

<!-- Creator     : groff version 1.18.1 -->
<!-- CreationDate: Fri Feb 11 22:17:05 2005 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title></title>
</head>
<body>

<hr>

<p align=center>DESCRIPTION OF A MACHINE<br>
ARCHITECTURE FOR USE WITH<br>
BLOCK STRUCTURED LANGUAGES</p>

<p align=center>Andrew S. Tanenbaum<br>
Hans van Staveren<br>
Ed G. Keizer<br>
Johan W. Stevenson*</p>

<p align=center>August 1983</p>

<p align=center>Informatica Rapport IR-81</p>

<p align=center>Abstract</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>EM is a family of intermediate languages designed for
producing portable compilers. A program called <b>front
end</b> translates source programs to EM. Another program,
<b>back end</b>, translates EM to the assembly language of
the target machine. Alternatively, the EM program can be
assembled to a highly efficient binary format for
interpretation. This document describes the EM languages in
detail.</p>
<!-- INDENTATION -->
<p>* Present affiliation: NV Philips, Eindhoven</p></td>
</table>

<p>1</p>

<p><b>1. INTRODUCTION</b></p>

<p>EM is a family of intermediate languages designed for
producing portable compilers. The general strategy is for a
program called <b>front end</b> to translate the source
program to EM. Another program, <b>back end</b>, translates
EM to target assembly language. Alternatively, the EM code
can be assembled to a binary form and interpreted. These
considerations led to the following goals:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">

<p>1</p>
</td>
<td width="8%"></td>
<td width="28%">

<p>The design should allow translation to, or
interpretation on, a wide range of existing machines. Design
decisions should be delayed as far as possible and the
implications of these decisions should be localized as much
as possible.</p>
</td>
<td width="61%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>The current microcomputer technology offers 8, 16 and 32
bit machines with various sizes of address space. EM should
be flexible enough to be useful on most of these machines.
The differences between the members of the EM family should
only concern the wordsize and address space size.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">

<p>2</p>
</td>
<td width="8%"></td>
<td width="30%">

<p>The architecture should ease the task of code generation
for high level languages such as Pascal, C, Ada, Algol 68,
BCPL.</p>
</td>
<td width="59%">
</td>
<tr valign="top" align="left">
<td width="2%">

<p>3</p>
</td>
<td width="8%"></td>
<td width="30%">

<p>The instruction set used by the interpreter should be
compact, to reduce the amount of memory needed for program
storage, and to reduce the time needed to transmit programs
over communication lines.</p>
</td>
<td width="59%">
</td>
<tr valign="top" align="left">
<td width="2%">

<p>3</p>
</td>
<td width="8%"></td>
<td width="30%">

<p>It should be designed with microprogrammed
implementations in mind; in particular, the use of many
short fields within instruction opcodes should be avoided,
because their extraction by the microprogram or conversion
to other instruction formats is inefficient.</p>
</td>
<td width="59%">
</td>
</table>

<p>The basic architecture is based on the concept of a
stack. The stack is used for procedure return addresses,
actual parameters, local variables, and arithmetic
operations. There are several built-in object types, for
example, signed and unsigned integers, floating point
numbers, pointers and sets of bits. There are instructions
to push and pop objects to and from the stack. The push and
pop instructions are not typed. They only care about the
size of the objects. For each built-in type there are
reverse Polish type instructions that pop one or more
objects from the top of the stack, perform an operation, and
push the result back onto the stack. For all types except
pointers, these instructions have the object size as
argument.</p>

<p>There are no visible general registers used for
arithmetic operands etc. This is in contrast to most third
generation computers, which usually have 8 or 16 general
registers. The decision not to have a group of general
registers was fully intentional, and follows W.L. Van der
Poel&rsquo;s dictum that a machine should have 0, 1, or an
infinite number of any feature. General registers have two
primary uses: to hold intermediate results of complicated
expressions, e.g.</p>
<pre>     ((a*b + c*d)/e + f*g/h) * i
</pre>

<p>and to hold local variables.</p>

<p>Various studies have shown that the average expression
has fewer than two operands, making the former use of
registers of doubtful value. The present trend toward
structured programs consisting of many small procedures
greatly reduces the value of registers to hold local
variables because the large number of procedure calls
implies a large overhead in saving and restoring the
registers at every call.</p>

<p>Although there are no general purpose registers, there
are a few internal registers with specific functions as
follows:</p>

<p align=center><img src="grohtml-97441.png"></p>

<p>Furthermore, reverse Polish code is much easier to
generate than multi-register machine code, especially if
highly efficient code is desired. When translating to
assembly language the back end can make good use of the
target machine&rsquo;s registers. An EM machine can achieve
high performance by keeping part of the stack in high speed
storage (a cache or microprogram scratchpad memory) rather
than in primary memory.</p>

<p>Again according to van der Poel&rsquo;s dictum, all EM
instructions have zero or one argument. We believe that
instructions needing two arguments can be split into two
simpler ones. The simpler ones can probably be used in other
circumstances as well. Moreover, these two instructions
together often have a shorter encoding than the single
instruction before.</p>

<p>This document describes EM at three different levels:
the abstract level, the assembly language level and the
machine language level.<br>
The most important level is that of the abstract EM
architecture. This level deals with the basic design issues.
Only the functional capabilities of instructions are
relevant, not their format or encoding. Most chapters of
this document refer to the abstract level and it is
explicitly stated whenever another level is described.<br>
The assembly language is intended for the compiler writer.
It presents a more or less orthogonal instruction set and
provides symbolic names for data. Moreover, it facilitates
the linking of separately compiled &rsquo;modules&rsquo;
into a single program by providing several
pseudoinstructions.<br>
The machine language is designed for interpretation with a
compact program text and easy decoding. The binary
representation of the machine language instruction set is
far from orthogonal. Frequent instructions have a short
opcode. The encoding is fully byte oriented. These bytes do
not contain small bit fields, because bit fields would slow
down decoding considerably.</p>

<p>A common use for EM is for producing portable (cross)
compilers. When used this way, the compilers produce EM
assembly language as their output. To run the compiled
program on the target machine, the back end, translates the
EM assembly language to the target machine&rsquo;s assembly
language. When this approach is used, the format of the EM
machine language instructions is irrelevant. On the other
hand, when writing an interpreter for EM machine language
programs, the interpreter must deal with the machine
language and not with the symbolic assembly language.</p>

<p>As mentioned above, the current microcomputer technology
offers 8, 16 and 32 bit machines with address spaces ranging
from 2 <small>16</small> to 2 <small>32</small> bytes.
Having one size of pointers and integers restricts the
usefulness of the language. We decided to have a different
language for each combination of word and pointer size. All
languages offer the same instruction set and differ only in
memory alignment restrictions and the implicit size assumed
in several instructions. The languages differ slightly for
the different size combinations. For example: the size of
any object on the stack and alignment restrictions. The
wordsize is restricted to powers of 2 and the pointer size
must be a multiple of the wordsize. Almost all programs
handling EM will be parametrized with word and pointer
size.</p>

<p>2</p>

<p><b>2. MEMORY</b></p>

<p>The EM machine has two distinct address spaces, one for
instructions and one for data. The data space is divided up
into 8-bit bytes. The smallest addressable unit is a byte.
Bytes are numbered consecutively from 0 to some maximum. All
sizes in EM are expressed in bytes.</p>

<p>Some EM instructions can transfer objects containing
several bytes to and/or from memory. The size of all objects
larger than a word must be a multiple of the wordsize. The
size of all objects smaller than a word must be a divisor of
the wordsize. For example: if the wordsize is 2 bytes,
objects of the sizes 1, 2, 4, 6,... are allowed. The address
of such an object is the lowest address of all bytes it
contains. For objects smaller than the wordsize, the address
must be a multiple of the object size. For all other objects
the address must be a multiple of the wordsize. For example,
if an instruction transfers a 4-byte object to memory at
location <i>m</i> and the wordsize is 2, <i>m</i> must be a
multiple of 2 and the bytes at locations <i>m</i>,
<i>m</i>+1,<i>m</i>+2 and <i>m</i>+3 are overwritten.</p>

<p>The size of almost all objects in EM is an integral
number of words. Only two operations are allowed on objects
whose size is a divisor of the wordsize: push it onto the
stack and pop it from the stack. The addressing of these
objects in memory is always indirect. If such a small object
is pushed onto the stack it is assumed to be a small integer
and stored in the least significant part of a word. The rest
of the word is cleared to zero, although EM provides a way
to sign-extend a small integer. Popping a small object from
the stack removes a word from the stack, stores the least
significant byte(s) of this word in memory and discards the
rest of the word.</p>

<p>The format of pointers into both address spaces is
explicitly undefined. The size of a pointer, however, is
fixed for a member of EM, so that the compiler writer knows
how much storage to allocate for a pointer.</p>

<p>A minor problem is raised by the undefined pointer
format. Some languages, notably Pascal, require a special,
otherwise illegal, pointer value to represent the nil
pointer. The current Pascal-VU compiler uses the integer
value 0 as nil pointer. This value is also used by many C
programs as a normally impossible address. A better solution
would be to have a special instruction loading an illegal
pointer value, but it is hard to imagine an implementation
for which the current solution is inadequate, especially
because the first word in the EM data space is special and
probably not the target of any pointer.</p>

<p>The next two chapters describe the EM memory in more
detail. One describes the instruction address space, the
other the data address space.</p>

<p>A design goal of EM has been to allow its implementation
on a wide range of existing machines, as well as allowing a
new one to be built in hardware. To this extent we have
tried to minimize the demands of EM on the memory structure
of the target machine. Therefore, apart from the logical
partitioning, EM memory is divided into
&rsquo;fragments&rsquo;. A fragment consists of consecutive
machine words and has a base address and a size. Pointer
arithmetic is only defined within a fragment. The only
exception to this rule is comparison with the null pointer.
All fragments must be word aligned.</p>

<p>3</p>

<p><b>3. INSTRUCTION ADDRESS SPACE</b></p>

<p>The instruction space of the EM machine contains the
code for procedures. Tables necessary for the execution of
this code, for example, procedure descriptor tables, may
also be present. The instruction space does not change
during the execution of a program, so that it may be
protected. No further restrictions to the instruction
address space are necessary for the abstract and assembly
language level.</p>

<p>Each procedure has a single entry point: the first
instruction. A special type of pointer identifies a
procedure. Pointers into the instruction address space have
the same size as pointers into data space and can, for
example, contain the address of the first instruction or an
index in a procedure descriptor table.</p>

<p>There is a single EM program counter, PC, pointing to
the next instruction to be executed. The procedure pointed
to by PC is called the &rsquo;current&rsquo; procedure. A
procedure may call another procedure using the CAL or CAI
instruction. The calling procedure remains
&rsquo;active&rsquo; and is resumed whenever the called
procedure returns. Note that a procedure has several
&rsquo;active&rsquo; invocations when called
recursively.</p>

<p>Each procedure must return properly. It is not allowed
to fall through to the code of the next procedure. There are
several ways to exit from a procedure:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">

<p>-</p>
</td>
<td width="8%"></td>
<td width="24%">

<p>the RET instruction, which returns to the calling
procedure.</p>
</td>
<td width="65%">
</td>
<tr valign="top" align="left">
<td width="2%">

<p>-</p>
</td>
<td width="8%"></td>
<td width="24%">

<p>the RTT instruction, which exits a trap handling routine
and resumes the trapping instruction (see next chapter).</p>
</td>
<td width="65%">
</td>
<tr valign="top" align="left">
<td width="2%">

<p>-</p>
</td>
<td width="8%"></td>
<td width="24%">

<p>the GTO instruction, which is used for non-local
goto&rsquo;s. It can remove several frames from the stack
and transfer control to an active procedure. (see also MES
11 in paragraph 11.1.4.4)</p>
</td>
<td width="65%">
</td>
</table>

<p>All branch instructions can transfer control to any
label within the same procedure. Branch instructions can
never jump out of a procedure.</p>

<p>Several language implementations use a so called
procedure instance identifier, a combination of a procedure
identifier and the LB of a stack frame, also called static
link.</p>

<p>The program text for each procedure, as well as any
tables, are fragments and can be allocated anywhere in the
instruction address space.</p>

<p>4</p>

<p><b>4. DATA ADDRESS SPACE</b></p>

<p>The data address space is divided into three parts,
called &rsquo;areas&rsquo;, each with its own addressing
method: global data area, local data area (including the
stack), and heap data area. These data areas must be part of
the same address space because all data is accessed by the
same type of pointers.</p>

<p>Space for global data is reserved using several
pseudoinstructions in the assembly language, as described in
the next paragraph and chapter 11. The size of the global
data area is fixed per program.</p>

<p>Global data is addressed absolutely in the machine
language. Many instructions are available to address global
data. They all have an absolute address as argument.
Examples are LOE, LAE and STE.</p>

<p>Part of the global data area is initialized by the
compiler, the rest is not initialized at all or is
initialized with a value, typically &minus;32768 or 0. Part
of the initialized global data may be made read-only if the
implementation supports protection.</p>

<p>The local data area is used as a stack, which grows from
high to low addresses and contains some data for each active
procedure invocation, called a &rsquo;frame&rsquo;. The size
of the local data area varies dynamically during execution.
Below the current procedure frame resides the operand stack.
The stack pointer SP always points to the bottom of the
local data area. Local data is addressed by offsetting from
the local base pointer LB. LB always points to the frame of
the current procedure. Only the words of the current frame
and the parameters can be addressed directly. Variables in
other active procedures are addressed by following the chain
of statically enclosing procedures using the LXL or LXA
instruction. The variables in dynamically enclosing
procedures can be addressed with the use of the DCH
instruction.</p>

<p>Many instructions have offsets to LB as argument, for
instance LOL, LAL and STL. The arguments of these
instructions range from &minus;1 to some (negative) minimum
for the access of local storage and from 0 to some
(positive) maximum for parameter access.</p>

<p>The procedure call instructions CAL and CAI each create
a new frame on the stack. Each procedure has an
assembly-time parameter specifying the number of bytes
needed for local storage. This storage is allocated each
time the procedure is called and must be a multiple of the
wordsize. Each procedure, therefore, starts with a stack
with the local variables already allocated. The return
instructions RET and RTT remove a frame. The actual
parameters must be removed by the calling procedure.</p>

<p>RET may copy some words from the stack of the returning
procedure to an unnamed &rsquo;function return area&rsquo;.
This area is available for &rsquo;READ-ONCE&rsquo; access
using the LFR instruction. The result of a LFR is only
defined if the size used to fetch is identical to the size
used in the last return. The instruction ASP, used to remove
the parameters from the stack, the branch instruction BRA
and the non-local goto instruction GTO are the only ones
that leave the contents of the &rsquo;function return
area&rsquo; intact. All other instructions are allowed to
destroy the function return area. Thus parameters can be
popped before fetching the function result. The maximum size
of all function return areas is implementation dependent,
but should allow procedure instance identifiers and all
implemented objects of type integer, unsigned, float and
pointer to be returned. In most implementations the maximum
size of the function return area is twice the pointer size,
because we want to be able to handle &rsquo;procedure
instance identifiers&rsquo; which consist of a procedure
identifier and the LB of a frame belonging to that
procedure.</p>

<p>The heap data area grows upwards, to higher numbered
addresses. It is initially empty. The initial value of the
heap pointer HP marks the low end. The heap pointer may be
manipulated by the LOR and STR instructions. The heap can
only be addressed indirectly, by pointers derived from
previous values of HP.</p>

<p><b>4.1 Global data area</b></p>

<p>The initial size of the global data area is determined
at assembly time. Global data is allocated by several
pseudoinstructions in the EM assembly language. Each
pseudoinstruction allocates one or more bytes. The bytes
allocated for a single pseudo form a &rsquo;block&rsquo;. A
block differs from a fragment, because, under certain
conditions, several blocks are allocated in a single
fragment. This guarantees that the bytes of these blocks are
consecutive.</p>

<p>Global data is addressed absolutely in binary machine
language. Most compilers, however, cannot assign absolute
addresses to their global variables, especially not if the
language allows programs to be composed of several
separately compiled modules. The assembly language therefore
allows the compiler to name the first address of a global
data block with an alphanumeric label. Moreover, the only
way to address such a named global data block in the
assembly language is by using its name. It is the task of
the assembler/loader to translate these labels into absolute
addresses. These labels may also be used in CON and ROM
pseudoinstructions to initialize pointers.</p>

<p>The pseudoinstruction CON allocates initialized data.
ROM acts like CON but indicates that the initialized data
will not change during execution of the program. The
pseudoinstruction BSS allocates a block of uninitialized or
identically initialized data. The pseudoinstruction HOL is
similar to BSS, but it alters the meaning of subsequent
absolute addressing in the assembly language.</p>

<p>Another type of global data is a small block, called the
ABS block, with an implementation defined size. Storage in
this type of block can only be addressed absolutely in
assembly language. The first word has address 0 and is used
to maintain the source line number. Special instructions LIN
and LNI are provided to update this counter. A pointer at
location 4 points to a string containing the current source
file name. The instruction FIL can be used to update the
pointer.</p>

<p>All numeric arguments of the instructions that address
the global data area refer to locations in the ABS block
unless they are preceded by at least one HOL pseudo in the
same module, in which case they refer to the storage area
allocated by the last HOL pseudoinstruction. Thus LOE 0
loads the zeroth word of the most recent HOL, unless no HOL
has appeared in the current file so far, in which case it
loads the zeroth word of the ABS fragment.</p>

<p>The global data area is highly fragmented. The ABS block
and each HOL and BSS block are separate fragments. The way
fragments are formed from CON and ROM blocks is more
complex. The assemblers group several blocks into a single
fragment. A fragment only contains blocks of the same type:
CON or ROM. It is guaranteed that the bytes allocated for
two consecutive CON pseudos are allocated consecutively in a
single fragment, unless these CON pseudos are separated in
the assembly language program by a data label definition or
one or more of the following pseudos:</p>
<pre>     ROM, BSS, HOL and END
</pre>

<p>An analogous rule holds for ROM pseudos.</p>

<p><b>4.2 Local data area</b></p>

<p>The local data area consists of a sequence of frames,
one for each active procedure. Below the frame of the
current procedure resides the expression stack. Frames are
generated by procedure calls and are removed by procedure
returns. A procedure frame consists of six
&rsquo;zones&rsquo;:</p>
<pre>     1.  The return status block
     2.  The local variables and compiler temporaries
     3.  The register save block
     4.  The dynamic local generators
     5.  The operand stack.
     6.  The parameters of a procedure one level deeper
</pre>

<p>A sample frame is shown in Figure 1.</p>

<p>Before a procedure call is performed the actual
parameters are pushed onto the stack of the calling
procedure. The exact details are compiler dependent. EM
allows procedures to be called with a variable number of
parameters. The implementation of the C-language almost
forces its runtime system to push the parameters in reverse
order, that is, the first positional parameter last. Most
compilers use the C calling convention to be compatible. The
parameters of a procedure belong to the frame of the calling
procedure. Note that the evaluation of the actual parameters
may imply the calling of procedures. The parameters can be
accessed with certain instructions using offsets of 0 and
greater. The first byte of the last parameter pushed has
offset 0. Note that the parameter at offset 0 has a special
use in the instructions following the static chain (LXL and
LXA). These instructions assume that this parameter contains
the LB of the statically enclosing procedure. Procedures
that do not have a dynamically enclosing procedure do not
need a static link at offset 0.</p>

<p>Two instructions are available to perform procedure
calls, CAL and CAI. Several tasks are performed by these
call instructions.</p>

<p>First, a part of the status of the calling procedure is
saved on the stack in the return status block. This block
should contain the return address of the calling procedure,
its LB and other implementation dependent data. The size of
this block is fixed for any given implementation because the
lexical instructions LPB, LXL and LXA must be able to obtain
the base addresses of the procedure parameters <b>and</b>
local variables. An alternative solution can be used on
machines with a highly segmented address space. The stack
frames need not be contiguous then and the first status save
area can contain the parameter base AB, which has the value
of SP just after the last parameter has been pushed.</p>

<p>Second, the LB is changed to point to the first word
above the local variables. The new LB is a copy of the SP
after the return status block has been pushed.</p>

<p>Third, the amount of local storage needed by the
procedure is reserved. The parameters and local storage are
accessed by the same instructions. Negative offsets are used
for access to local variables. The highest byte, that is the
byte nearest to LB, has to be accessed with offset &minus;1.
The pseudoinstruction specifying the entry point of a
procedure, has an argument that specifies the amount of
local storage needed. The local variables allocated by the
CAI or CAL instructions are the only ones that can be
accessed with a fixed negative offset. The initial value of
the allocated words is not defined, but implementations that
check for undefined values will probably initialize them
with a special &rsquo;undefined&rsquo; pattern, typically
&minus;32768.</p>

<p>Fourth, any EM implementation is allowed to reserve a
variable size block beneath the local variables. This block
could, for example, be used to save a variable number of
registers.</p>

<p>Finally, the address of the entry point of the called
procedure is loaded into the Program Counter.</p>

<p>The ASP instruction can be used to allocate further
(dynamic) local storage. The base address of such storage
must be obtained with a LOR SP instruction. This same
instruction ASP may also be used to remove some words from
the stack.</p>

<p>There is a version of ASP, called ASS, which fetches the
number of bytes to allocate from the stack. It can be used
to allocate space for local objects whose size is unknown at
compile time, so called &rsquo;dynamic local
generators&rsquo;.</p>

<p>Control is returned to the calling procedure with a RET
instruction. Any return value is then copied to the
&rsquo;function return area&rsquo;. The frame created by the
call is deallocated and the status of the calling procedure
is restored. The value of SP just after the return value has
been popped must be the same as the value of SP just before
executing the first instruction of this invocation. This
means that when a RET is executed the operand stack can only
contain the return value and all dynamically generated
locals must be deallocated. Violating this restriction might
result in hard to detect errors. The calling procedure has
to remove the parameters from the stack. This can be done
with the aforementioned ASP instruction.</p>

<p>Each procedure frame is a separate fragment. Because any
fragment may be placed anywhere in memory, procedure frames
need not be contiguous.</p>

<p><tt>|===============================| | actual parameter
n-1 | |-------------------------------| | . | | . | | . |
|-------------------------------| | actual parameter 0 | (
&lt;&minus; AB ) |===============================|</tt></p>

<p><tt>|===============================|
|///////////////////////////////| |///// return status block
/////| |///////////////////////////////| &lt;&minus; LB
|===============================| | | | local variables | |
| |-------------------------------| | | | compiler
temporaries | | | |===============================|
|///////////////////////////////| |///// register save block
/////| |///////////////////////////////|
|===============================| | | | dynamic local
generators | | | |===============================| | operand
| |-------------------------------| | operand |
|===============================| | parameter m-1 |
|-------------------------------| | . | | . | | . |
|-------------------------------| | parameter 0 |
&lt;&minus; SP |===============================|</tt></p>

<p align=center>Figure 1. A sample procedure frame and
parameters.</p>

<p><b>4.3 Heap data area</b></p>

<p>The heap area starts empty, with HP pointing to the low
end of it. HP always contains a word address. A copy of HP
can always be obtained with the LOR instruction. A new value
may be stored in the heap pointer using the STR instruction.
If the new value is greater than the old one, then the heap
grows. If it is smaller, then the heap shrinks. HP may never
point below its original value. All words between the
current HP and the original HP are allocated to the heap.
The heap may not grow into a part of memory that is already
allocated. When this is attempted, the STR instruction will
cause a trap to occur. In this case, HP retains its old
value.</p>

<p>The only way to address the heap is indirectly. Whenever
an object is allocated by increasing HP, then the old HP
value must be saved and can be used later to address the
allocated object. If, in the meantime, HP is decreased so
that the object is no longer part of the heap, then an
attempt to access the object is not allowed. Furthermore, if
the heap pointer is increased again to above the object
address, then access to the old object gives undefined
results.</p>

<p>The heap is a single fragment. All bytes have
consecutive addresses. No limits are imposed on the size of
the heap as long as it fits in the available data address
space.</p>

<p>5</p>

<p><b>5. MAPPING OF EM DATA MEMORY ONTO TARGET MACHINE
MEMORY</b></p>

<p>The EM architecture is designed to be implemented on
many existing and future machines. EM memory is highly
fragmented to make adaptation to various memory
architectures possible. Format and encoding of pointers is
explicitly undefined.</p>

<p>This chapter gives solutions to some of the anticipated
problems. First, we describe a possible memory layout for
machines with 64K bytes of address space. Here we use a
member of the EM family with 2-byte word and pointer size.
The most straightforward layout is shown in figure 2.</p>

<p><tt>65534 &minus;&gt; |-------------------------------|
|///////////////////////////////| |//// unimplemented memory
/////| |///////////////////////////////| ML &minus;&gt;
|-------------------------------| | | | | &lt;&minus; LB |
stack and local area | | | |-------------------------------|
&lt;&minus; SP |///////////////////////////////| |////////
inaccessible /////////| |///////////////////////////////|
|-------------------------------| &lt;&minus; HP | | | heap
area | | | | | HB &minus;&gt;
|-------------------------------| | | | global data area | |
| EB &minus;&gt; |-------------------------------| | | |
program text | &lt;&minus; PC | | | ( and tables ) | | | | |
PB &minus;&gt; |-------------------------------|
|///////////////////////////////| |////////// undefined
//////////| |///////////////////////////////| 0 &minus;&gt;
|-------------------------------|</tt></p>

<p align=center>Figure 2. Memory layout showing typical
register<br>
positions during execution of an EM program.</p>

<p>The base registers for the various memory pieces can be
stored in target machine registers or memory.</p>

<p align=center><img src="grohtml-97442.png"></p>

<p>The stack grows from high EM addresses to low EM
addresses, and the heap the other way. The memory between SP
and HP is not accessible, but may be allocated later to the
stack or the heap if needed. The local data area is
allocated starting at the high end of memory.</p>

<p>Because EM address 0 is not mapped onto target address
0, a problem arises when pointers are used. If a program
pushed a constant, say 6, onto the stack, and then tried to
indirect through it, the wrong word would be fetched,
because EM address 6 is mapped onto target address EB+6 and
not target address 6 itself. This particular problem is
solved by explicitly declaring the format of a pointer to be
undefined, so that using a constant as a pointer is
completely illegal. However, the general problem of mapping
pointers still exists.</p>

<p>There are two possible solutions. In the first solution,
EM pointers are represented in the target machine as true EM
addresses, for example, a pointer to EM address 6 really is
stored as a 6 in the target machine. This solution implies
that every time a pointer is fetched EB must be added before
referencing the target machine&rsquo;s memory. If the target
machine has powerful indexing facilities, EB can be kept in
a target machine register, and the relocation can indeed be
done on every reference to the data address space at a
modest cost in speed.</p>

<p>The other solution consists of having EM pointers refer
to the true target machine address. Thus the instruction LAE
6 (Load Address of External 6) would push the value of EB+6
onto the stack. When this approach is chosen, back ends must
know how to offset from EB, to translate all instructions
that manipulate EM addresses. However, the problem is not
completely solved, because a front end may have to
initialize a pointer in CON or ROM data to point to a global
address. This pointer must also be relocated by the back end
or the interpreter.</p>

<p>Although the EM stack grows from high to low EM
addresses, some machines have hardware PUSH and POP
instructions that require the stack to grow upwards. If
reasons of efficiency demand the use of these instructions,
then EM can be implemented with the memory layout upside
down, as shown in figure 3. This is possible because the
pointer format is explicitly undefined. The first element of
a word array will have a lower physical address than the
second element.</p>

<p><tt>| | | | | EB=60 | | ^ | | | | | |
|-----------------| |-----------------| 105 | 45 | 44 | 104
214 | 41 | 40 | 215 |-----------------| |-----------------|
103 | 43 | 42 | 102 212 | 43 | 42 | 213 |-----------------|
|-----------------| 101 | 41 | 40 | 100 210 | 45 | 44 | 211
|-----------------| |-----------------| | | | | | | v | |
EB=255 | | | | |</tt></p>

<p><tt>Type A Type B</tt></p>

<p align=center>Figure 3. Two possible memory
implementations.<br>
Numbers within the boxes are EM addresses.<br>
The other numbers are physical addresses.</p>

<p>So, we have two different EM memory implementations:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p>A &minus;</p>
</td>
<td width="4%"></td>
<td width="18%">

<p>stack downwards</p>
</td>
<td width="71%">
</td>
<tr valign="top" align="left">
<td width="6%">

<p>B &minus;</p>
</td>
<td width="4%"></td>
<td width="18%">

<p>stack upwards</p>
</td>
<td width="71%">
</td>
</table>

<p>For each of these two possibilities we give the
translation of the EM instructions to push the third byte of
a global data block starting at EM address 40 onto the stack
and to load the word at address 40. All translations assume
a word and pointer size of two bytes. The target machine
used is a PDP-11 augmented with push and pop instructions.
Registers &rsquo;r0&rsquo; and &rsquo;r1&rsquo; are used and
suffer from sign extension for byte transfers. Push $40
means push the constant 40, not word 40.</p>

<p>The translation of the EM instructions depends on the
pointer representation used. For each of the two solutions
explained above the translation is given.</p>

<p>First, the translation for the two implementations using
EM addresses as pointer representation:</p>

<p align=center><img src="grohtml-97443.png"></p>

<p>The translation for the two implementations, if the
target machine address is used as pointer representation,
is:</p>

<p align=center><img src="grohtml-97444.png"></p>

<p>The translation presented above is not intended to be
optimal. Most machines can handle these simple cases in one
or two instructions. It demonstrates, however, the
flexibility of the EM design.</p>

<p>There are several possibilities to implement EM on
machines with address spaces larger than 64k bytes. For EM
with two byte pointers one could allocate instruction and
data space each in a separate 64k piece of memory. EM
pointers still have to fit in two bytes, but the base
registers PB and EB may be loaded in hardware registers
wider than 16 bits, if available. EM implementations can
also make efficient use of a machine with separate
instruction and data space.</p>

<p>EM with 32 bit pointers allows one to make use of
machines with large address spaces. In a virtual, segmented
memory system one could use a separate segment for each
fragment.</p>

<p>6</p>

<p><b>6. TYPE REPRESENTATIONS</b></p>

<p>The representations used for typed objects are not
precisely specified by EM. Sometimes we only specify that a
typed object occupies a certain amount of space and state no
further restrictions. If one wants to have a different
representation of the value of an object on the stack one
has to use a convert instruction in most cases. We do
specify some relations between the representations of types.
This allows some intermixed use of operators for different
types on the same object(s). For example, the instruction
ZER pushes signed and unsigned integers with the value zero
and empty sets. ZER has as only argument the size of the
object.</p>

<p>The representation of floating point numbers is a good
example, it allows widely varying implementations. The only
ways to create floating point numbers are via initialization
and via conversions from integer numbers. Only by using
conversions to integers and comparing two floating point
numbers with each other, can these numbers be converted to
human readable output. Implementations may use base 10, base
2 or any other base for exponents, and have freedom in
choosing the range of exponent and mantissa.</p>

<p>Other types are more precisely described. In the
following paragraphs a description will be given of the
restrictions imposed on the representation of the types
used. A number <b>n</b> used in these paragraphs indicates
the size of the object in <i>bits</i>.</p>

<p><b>6.1 Unsigned integers</b></p>

<p>The range of unsigned integers is 0.. 2
<b><small>n</small></b> -1. A binary representation is
assumed. The order of the bits within an object is knowingly
left unspecified. Discussing bit order within each 8-bit
byte is academic, so the only real freedom of this
specification lies in the byte order. We really do not care
whether an implementation of a 4-byte integer has its bytes
in a particular order of significance. This of course means
that some sequences of instructions have unpredictable
effects. For example:</p>
<pre>     LOC 258 ; STL 0 ; LAL 0 ; LOI 1      ( wordsize &gt;=2 )
</pre>

<p>The value on the stack after executing this sequence can
be anything, but will most likely be 1 or 2.</p>

<p>Conversion between unsigned integers of different sizes
have to be done with explicit convert instructions. One
cannot simply pad an unsigned integer with zero&rsquo;s at
either end and expect a correct result.</p>

<p>We assume existence of at least single word unsigned
arithmetic in any implementation.</p>

<p><b>6.2 Signed Integers</b></p>

<p>The range of signed integers is &minus;2
<b><small>n</small></b><small>&minus;1</small> .. 2
<b><small>n</small></b><small>&minus;1</small> &minus;1, in
other words the range of signed integers of <b>n</b> bits
using two&rsquo;s complement arithmetic. The representation
is the same as for unsigned integers except the range 2
<b><small>n</small></b><small>&minus;1</small> .. 2
<b><small>n</small></b> &minus;1 is mapped on the range
&minus;2 <b><small>n</small></b><small>&minus;1</small> ..
&minus;1. In other words, the most significant bit is used
as sign bit. The convert instructions between signed and
unsigned integers of the same size can be used to catch
errors.</p>

<p>The value &minus;2
<b><small>n</small></b><small>&minus;1</small> is used for
undefined signed integers. EM implementations should trap
when this value is used in an operation on signed integers.
The instruction mask, accessed with SIM and LIM &minus; see
chapter 9 &minus;, can be used to disable such traps.</p>

<p>We assume existence of at least single word signed
arithmetic in any implementation.</p>

<p><b>6.3 Floating point values</b></p>

<p>Floating point values must have a signed mantissa and a
signed exponent. Although no base is specified, base 2 is
the normal choice, because the FEF instruction pushes the
exponent in base 2.</p>

<p>The implementation of floating point arithmetic is
optional. The compilers currently in use have runtime
parameters for the size of the floating point values they
should use. Common choices are 4 and/or 8 bytes.</p>

<p><b>6.4 Pointers</b></p>

<p>EM has two kinds of pointers: for instruction and for
data space. Each kind can only be used for its own space,
conversion between these two subtypes is impossible. We
assume that pointers have a range from 0 upwards. Any
implementation may have holes in the pointer range between
fragments. One can of course not expect to be able to
address two megabyte of memory using a 2-byte pointer.
Normally, a 2-byte pointer allows up to 65536 bytes of
addressable memory.</p>

<p>Pointer representation has one restriction. The pointer
with the same representation as the integer zero of the same
size should be invalid. Some languages and/or runtime
systems represent the nil pointer as zero.</p>

<p><b>6.5 Bit sets</b></p>

<p>All bit sets of size <b>n</b> are subsets of the set { i
| i&gt;=0, i&lt;<b>n</b> }. A bit set contains a bit for
each element showing its presence or absence. Bit sets are
subdivided into words. The word with the lowest EM address
governs the subset { i | i&gt;=0, i&lt;<b>m</b> }, where
<b>m</b> is the number of bits in a word. The next higher
words each govern the next higher <b>m</b> set elements. The
relation between a set with size of a word and an unsigned
integer word is that the value of the unsigned integer is
the summation of the 2i where i is in the set.</p>

<p>Example: a 2-word bit set (wordsize 2) containing the
elements 1, 6, 8, 15, 18, 21, 27 and 28 is composed of two
integers, e.g. at addresses 40 and 42. The word at 40
contains the value 33090 (or &minus;32446), the word at 42
contains the value 6180.</p>

<p>7</p>

<p><b>7. DESCRIPTORS</b></p>

<p>Several instructions use descriptors, notably the range
check instruction, the array instructions, the goto
instruction and the case jump instructions. Descriptors
reside in data space. They may be constructed at run time,
but more often they are fixed and allocated in ROM data.</p>

<p>All instructions using descriptors, except GTO, have as
argument the size of the integers in the descriptor. All
implementations have to allow integers of the size of a word
in descriptors. All integers popped from the stack and used
for indexing or comparing must have the same size as the
integers in the descriptor.</p>

<p><b>7.1 Range check descriptors</b></p>

<p>Range check descriptors consist of two integers:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p>1.</p>
</td>
<td width="10%">

<p>lower bound</p>
</td>
<td width="79%">

<p>signed</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p>2.</p>
</td>
<td width="10%">

<p>upper bound</p>
</td>
<td width="79%">

<p>signed</p>
</td>
</table>

<p>The range check instruction checks an integer on the
stack against these bounds and causes a trap if the value is
outside the interval. The value itself is neither changed
nor removed from the stack.</p>

<p><b>7.2 Array descriptors</b></p>

<p>Each array descriptor describes a single dimension. For
multi-dimensional arrays, several array instructions are
needed to access a single element. Array descriptors contain
the following three integers:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p>1.</p>
</td>
<td width="10%">

<p>lower bound</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="10%"></td>
<td width="79%">

<p>signed</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p>2.</p>
</td>
<td width="10%">

<p>upper bound &minus; lower bound</p>
</td>
<td width="79%">

<p>unsigned</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p>3.</p>
</td>
<td width="14%">

<p>number of bytes per element</p>
</td>
<td width="75%">

<p>unsigned</p>
</td>
</table>

<p>The array instructions LAR, SAR and AAR have the pointer
to the start of the descriptor as operand on the stack.</p>

<p>The element A[I] is fetched as follows:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>1.</p>
</td>
<td width="6%"></td>
<td width="20%">

<p>Stack the address of A (e.g., using LAE or LAL)</p>
</td>
<td width="69%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>2.</p>
</td>
<td width="6%"></td>
<td width="20%">

<p>Stack the value of I (n-byte integer)</p>
</td>
<td width="69%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>3.</p>
</td>
<td width="6%"></td>
<td width="20%">

<p>Stack the pointer to the descriptor (e.g., using
LAE)</p>
</td>
<td width="69%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>4.</p>
</td>
<td width="6%"></td>
<td width="20%">

<p>LAR n (n is the size of the integers in the descriptor
and I)</p>
</td>
<td width="69%">
</td>
</table>

<p>All array instructions first pop the address of the
descriptor and the index. If the index is not within the
bounds specified, a trap occurs. If ok, (I &minus; lower
bound) is multiplied by the number of bytes per element (the
third word). The result is added to the address of A and
replaces A on the stack.</p>

<p>At this point LAR, SAR and AAR diverge. AAR is finished.
LAR pops the address and fetches the data item, the size
being specified by the descriptor. The usual restrictions
for memory access must be obeyed. SAR pops the address and
stores the data item now exposed.</p>

<p><b>7.3 Non-local goto descriptors</b></p>

<p>The GTO instruction provides a way of returning directly
to any active procedure invocation. The argument of the
instruction is the address of a descriptor containing three
pointers:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>1.</p>
</td>
<td width="6%"></td>
<td width="10%">

<p>value of PC after the jump</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>2.</p>
</td>
<td width="6%"></td>
<td width="10%">

<p>value of SP after the jump</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>3.</p>
</td>
<td width="6%"></td>
<td width="10%">

<p>value of LB after the jump</p>
</td>
<td width="79%">
</td>
</table>

<p>GTO replaces the loads PC, SP and LB from the
descriptor, thereby jumping to a procedure and removing zero
or more frames from the stack. The LB, SP and PC in the
descriptor must belong to a dynamically enclosing procedure,
because some EM implementations will need to backtrack
through the dynamic chain and use the implementation
dependent data in frames to restore registers etc.</p>

<p><b>7.4 Case descriptors</b></p>

<p>The case jump instructions CSA and CSB both provide
multiway branches selected by a case index. Both fetch two
operands from the stack: first a pointer to the low address
of the case descriptor and then the case index. CSA uses the
case index as index in the descriptor table, but CSB
searches the table for an occurrence of the case index.
Therefore, the descriptors for CSA and CSB, as shown in
figure 4, are different. All pointers in the table must be
addresses of instructions in the procedure executing the
case instruction.</p>

<p>CSA selects the new PC by indexing. If the index, a
signed integer, is greater than or equal to the lower bound
and less than or equal to the upper bound, then fetch the
new PC from the list of instruction pointers by indexing
with index-lower. The table does not contain the value of
the upper bound, but the value of upper-lower as an unsigned
integer. The default instruction pointer is used when the
index is out of bounds. If the resulting PC is 0, then
trap.</p>

<p>CSB selects the new PC by searching. The table is
searched for an entry with index value equal to the case
index. That entry or, if none is found, the default entry
contains the new PC. When the resulting PC is 0, a trap is
performed.</p>

<p>The choice of which case instruction to use for each
source language case statement is up to the front end. If
the range of the index value is dense, i.e</p>
<pre>     (highest value &minus; lowest value) / number of cases
</pre>

<p>is less than some threshold, then CSA is the obvious
choice. If the range is sparse, CSB is better.</p>

<p><tt>|--------------------| |--------------------| high
address | pointer for upb | | pointer n-1 |
|--------------------| |- - - - - - - | | . | | index n-1 |
| . | |--------------------| | . | | . | | . | | . | | . | |
. | | . | |--------------------| | . | | pointer 1 |
|--------------------| |- - - - - - - | | pointer for lwb+1
| | index 1 | |--------------------| |--------------------|
| pointer for lwb | | pointer 0 | |--------------------| |-
- - - - - - | | upper - lower | | index 0 |
|--------------------| |--------------------| | lower bound
| | number of entries | |--------------------|
|--------------------| | default pointer | | default pointer
| low address |--------------------|
|--------------------|</tt></p>

<p><tt>CSA descriptor CSB descriptor</tt></p>

<p align=center>Figure 4. Descriptor layout for CSA and
CSB</p>

<p>8</p>

<p><b>8. ENVIRONMENT INTERACTIONS</b></p>

<p>EM programs can interact with their environment in three
ways. Two, starting/stopping and monitor calls, are dealt
with in this chapter. The remaining way to interact,
interrupts, will be treated together with traps in chapter
9.</p>

<p><b>8.1 Program starting and stopping</b></p>

<p>EM user programs start with a call to a procedure called
_m_a_i_n. The assembler and backends look for the definition
of a procedure with this name in their input. The call
passes three parameters to the procedure. The parameters are
similar to the parameters supplied by the
<small>UNIX</small> &reg; operating system to C programs.
These parameters are often called <b>argc</b>, <b>argv</b>
and <b>envp</b>. Argc is the parameter nearest to LB and is
a wordsized integer. The other two are pointers to the first
element of an array of string pointers. The <b>argv</b>
array contains <b>argc</b> strings, the first of which
contains the program call name. The other strings in the
<b>argv</b> array are the program parameters.</p>

<p>The <b>envp</b> array contains strings in the form
&quot;name=string&quot;, where &rsquo;name&rsquo; is the
name of an environment variable and string its value. The
<b>envp</b> is terminated by a zero pointer.</p>

<p>An EM user program stops if the program returns from the
first invocation of _m_a_i_n. The contents of the function
return area are used to procure a wordsized program return
code. EM programs also stop when traps and interrupts occur
that are not caught and when the exit monitor call is
executed.</p>

<p><b>8.2 Input/Output and other monitor calls</b></p>

<p>EM differs from most conventional machines in that it
has high level i/o instructions. Typical instructions are
OPEN FILE and READ FROM FILE instead of low level
instructions such as setting and clearing bits in device
registers. By providing such high level i/o primitives, the
task of implementing EM on various non EM machines is made
considerably easier.</p>

<p>I/O is initiated by the MON instruction, which expects
an iocode on top of the stack. Often there are also
parameters which are pushed on the stack in reverse order,
that is: last parameter first. Some i/o functions also
provide results, which are returned on the stack. In the
list of monitor calls we use several types of parameters and
results, these types consist of integers and unsigneds of
varying sizes, but never smaller than the wordsize, and the
two pointer types.</p>

<p>The names of the types used are:</p>

<p align=center><img src="grohtml-97445.png"></p>

<p>The table below lists the i/o codes with their results
and parameters. This list is similar to the system calls of
the UNIX Version 7 operating system.</p>

<p>To execute a monitor call, proceed as follows:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>a)</p>
</td>
<td width="6%"></td>
<td width="24%">

<p>Stack the parameters, in reverse order, last parameter
first.</p>
</td>
<td width="65%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>b)</p>
</td>
<td width="6%"></td>
<td width="24%">

<p>Push the monitor call number (iocode) onto the
stack.</p>
</td>
<td width="65%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>c)</p>
</td>
<td width="6%"></td>
<td width="24%">

<p>Execute the MON instruction.</p>
</td>
<td width="65%">
</td>
</table>

<p>An error code is present on the top of the stack after
execution of most monitor calls. If this error code is zero,
the call performed the action requested and the results are
available on top of the stack. Non-zero error codes indicate
a failure, in this case no results are available and the
error code has been pushed twice. This construction enables
programs to test for failure with a single instruction ( TEQ
or TNE ) and still find out the cause of the failure. The
result name &rsquo;e&rsquo; is reserved for the error
code.</p>

<p>List of monitor calls.</p>
<pre>nr  name     parameters      results                function

</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>1</p>
</td>
<td width="92%">

<p>Exit</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>status:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Terminate this process</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>2</p>
</td>
<td width="92%">

<p>Fork</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e,flag,pid:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Spawn new process</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>3</p>
</td>
<td width="92%">

<p>Read</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>fildes:int;buf:ptr;nbytes:unsp</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int;rbytes:unsp</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Read from file</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>4</p>
</td>
<td width="92%">

<p>Write</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>fildes:int;buf:ptr;nbytes:unsp</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int;wbytes:unsp</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Write on a file</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>5</p>
</td>
<td width="92%">

<p>Open</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string:ptr;flag:int</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e,fildes:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Open file for read and/or write</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>6</p>
</td>
<td width="92%">

<p>Close</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>fildes:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Close a file</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>7</p>
</td>
<td width="92%">

<p>Wait</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int;status,pid:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Wait for child</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>8</p>
</td>
<td width="92%">

<p>Creat</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string:ptr;mode:int</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e,fildes:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Create a new file</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>9</p>
</td>
<td width="92%">

<p>Link</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string1,string2:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Link to a file</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>10</p>
</td>
<td width="92%">

<p>Unlink</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Remove directory entry</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>12</p>
</td>
<td width="92%">

<p>Chdir</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Change default directory</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>14</p>
</td>
<td width="92%">

<p>Mknod</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string:ptr;mode,addr:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Make a special file</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>15</p>
</td>
<td width="92%">

<p>Chmod</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string:ptr;mode:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Change mode of file</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>16</p>
</td>
<td width="92%">

<p>Chown</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string:ptr;owner,group:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Change owner/group of a file</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>18</p>
</td>
<td width="92%">

<p>Stat</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string,statbuf:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Get file status</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>19</p>
</td>
<td width="92%">

<p>Lseek</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>fildes:int;off:int4;whence:int</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int;oldoff:int4</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Move read/write pointer</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>20</p>
</td>
<td width="92%">

<p>Getpid</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>pid:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Get process identification</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>21</p>
</td>
<td width="92%">

<p>Mount</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>special,string:ptr;rwflag:int</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Mount file system</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>22</p>
</td>
<td width="92%">

<p>Umount</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>special:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Unmount file system</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>23</p>
</td>
<td width="92%">

<p>Setuid</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>userid:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Set user ID</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>24</p>
</td>
<td width="92%">

<p>Getuid</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e_uid,r_uid:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Get user ID</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>25</p>
</td>
<td width="92%">

<p>Stime</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>time:int4</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Set time and date</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>26</p>
</td>
<td width="92%">

<p>Ptrace</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>request:int;pid:int2;addr:ptr;data:int</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e,value:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Process trace</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>27</p>
</td>
<td width="92%">

<p>Alarm</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>seconds:uns2</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>previous:uns2</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Schedule signal</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>28</p>
</td>
<td width="92%">

<p>Fstat</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>fildes:int;statbuf:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Get file status</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>29</p>
</td>
<td width="92%">

<p>Pause</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Stop until signal</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>30</p>
</td>
<td width="92%">

<p>Utime</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string,timep:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Set file times</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>33</p>
</td>
<td width="92%">

<p>Access</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string:ptr;mode:int</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Determine file accessibility</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>34</p>
</td>
<td width="92%">

<p>Nice</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>incr:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Set program priority</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>35</p>
</td>
<td width="92%">

<p>Ftime</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>bufp:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Get date and time</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>36</p>
</td>
<td width="92%">

<p>Sync</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Update filesystem</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>37</p>
</td>
<td width="92%">

<p>Kill</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>pid:int2;sig:int</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Send signal to a process</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>41</p>
</td>
<td width="92%">

<p>Dup</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>fildes,newfildes:int</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e,fildes:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Duplicate a file descriptor</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>42</p>
</td>
<td width="92%">

<p>Pipe</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e,w_des,r_des:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Create a pipe</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>43</p>
</td>
<td width="92%">

<p>Times</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>buffer:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Get process times</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>44</p>
</td>
<td width="92%">

<p>Profil</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>buff:ptr;bufsiz,offset,scale:intp</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Execution time profile</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>46</p>
</td>
<td width="92%">

<p>Setgid</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>gid:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Set group ID</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>47</p>
</td>
<td width="92%">

<p>Getgid</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e_gid,r_gid:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Get group ID</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>48</p>
</td>
<td width="92%">

<p>Sigtrp</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>trapno,signo:int</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e,prevtrap:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>See below</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>51</p>
</td>
<td width="92%">

<p>Acct</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>file:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Turn accounting on or off</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>53</p>
</td>
<td width="92%">

<p>Lock</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>flag:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Lock a process</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>54</p>
</td>
<td width="92%">

<p>Ioctl</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>fildes,request:int;argp:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Control device</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>56</p>
</td>
<td width="92%">

<p>Mpxcall</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>cmd:int;vec:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Multiplexed file handling</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>59</p>
</td>
<td width="92%">

<p>Exece</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>name,argv,envp:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%">
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Execute a file</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>60</p>
</td>
<td width="92%">

<p>Umask</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>mask:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>oldmask:int2</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Set file creation mode mask</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>61</p>
</td>
<td width="92%">

<p>Chroot</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>string:ptr</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>e:int</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>Change root directory</p>
</td>
</table>

<p>Codes 0, 11, 13, 17, 31, 32, 38, 39, 40, 45, 49, 50, 52,
55, 57, 58, 62, and 63 are not used.</p>

<p>All monitor calls, except fork and sigtrp are the same
as the UNIX version 7 system calls.</p>

<p>The sigtrp entry maps UNIX signals onto EM interrupts.
Normally, trapno is in the range 0 to 252. In that case it
requests that signal signo will cause trap trapno to occur.
When given trap number &minus;2, default signal handling is
reset, and when given trap number &minus;3, the signal is
ignored.</p>

<p>The flag returned by fork is 1 in the child process and
0 in the parent. The pid returned is the process-id of the
other process.</p>

<p>9</p>

<p><b>9. TRAPS AND INTERRUPTS</b></p>

<p>EM provides a means for the user program to catch all
traps generated by the program itself, the hardware, or
external conditions. This mechanism uses five instructions:
LIM, SIM, SIG, TRP and RTT. This section of the manual may
be omitted on the first reading since it presupposes
knowledge of the EM instruction set.</p>

<p>The action taken when a trap occurs is determined by the
value of an internal EM trap register. This register
contains a pointer to a procedure. Initially the pointer
used is zero and all traps halt the program with, hopefully,
a useful message to the outside world. The SIG instruction
can be used to alter the trap register, it pops a procedure
pointer from the stack into the trap register. When a trap
occurs after storing a nonzero value in the trap register,
the procedure pointed to by the trap register is called with
the trap number as the only parameter (see below). SIG
returns the previous value of the trap register on the
stack. Two consecutive SIGs are a no-op. When a trap occurs,
the trap register is reset to its initial condition, to
prevent recursive traps from hanging the machine up, e.g.
stack overflow in the stack overflow handling procedure.</p>

<p>The runtime systems for some languages need to ignore
some EM traps. EM offers a feature called the ignore mask.
It contains one bit for each of the lowest 16 trap numbers.
The bits are numbered 0 to 15, with the least significant
bit having number 0. If a certain bit is 1 the corresponding
trap never occurs and processing simply continues. The
actions performed by the offending instruction are described
by the Pascal program in appendix A.<br>
If the bit is 0, traps are not ignored. The instructions LIM
and SIM allow copying and replacement of the ignore
mask.</p>

<p>The TRP instruction generates a trap, the trap number
being found on the stack. This is, among other things,
useful for library procedures and runtime systems. It can
also be used by a low level trap procedure to pass the trap
to a higher level one (see example below).</p>

<p>The RTT instruction returns from the trap procedure and
continues after the trap. In the list below all traps marked
with an asterisk (&rsquo;*&rsquo;) are considered to be
fatal and it is explicitly undefined what happens when
restarting after the trap.</p>

<p>The way a trap procedure is called is completely
compatible with normal calling conventions. The only way a
trap procedure differs from normal procedures is the return.
It has to use RTT instead of RET. This is necessary because
the complete runtime status is saved on the stack before
calling the procedure and all this status has to be
reloaded. Error numbers are in the range 0 to 252. The trap
numbers are divided into three categories:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="10%">

<p>0&minus; 63</p>
</td>
<td width="10%"></td>
<td width="24%">

<p>EM machine errors, e.g. illegal instruction.</p>
</td>
<td width="51%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>0&minus;15</p>
<td width="39%"></td>
<td width="16%">

<p>maskable</p>
</td>
<td width="43%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="32%">

<p>16&minus;63</p>
</td>
<td width="6%"></td>
<td width="16%">

<p>not maskable</p>
</td>
<td width="43%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="32%">

<p>64&minus;127</p>
</td>
<td width="6%"></td>
<td width="16%"></td>
<td width="43%">
</td>
</table>

<p>Reserved for use by compilers, run time systems,
etc.</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">

<p>128&minus;252</p>
</td>
<td width="10%"></td>
<td width="18%">

<p>Available for user programs.</p>
</td>
<td width="57%">
</td>
</table>

<p>EM machine errors are numbered as follows:</p>

<p align=center><img src="grohtml-97446.png"></p>

<p>As an example, suppose a subprocedure has to be written
to do a numeric calculation. When an overflow occurs the
computation has to be stopped and the higher level procedure
must be resumed. This can be programmed as follows using the
mechanism described above:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>mes 2,2,2</p>
</td>
<td width="52%">

<p>; set sizes</p>
</td>
</table>

<p>ersave</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>bss 2,0,0</p>
</td>
<td width="52%">

<p>; Room to save previous value of trap procedure</p>
</td>
</table>

<p>msave</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>bss 2,0,0</p>
</td>
<td width="52%">

<p>; Room to save previous value of trap mask</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>pro $calcule,0</p>
</td>
<td width="52%">

<p>; entry point</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lxl 0</p>
</td>
<td width="52%">

<p>; fill in non-local goto descriptor with LB</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>ste jmpbuf+4</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lor 1</p>
</td>
<td width="52%">

<p>; and SP</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>ste jmpbuf+2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lim</p>
</td>
<td width="52%">

<p>; get current ignore mask</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>ste msave</p>
</td>
<td width="52%">

<p>; save it</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>lim</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>loc 16</p>
</td>
<td width="52%">

<p>; bit for EFOVFL</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>ior 2</p>
</td>
<td width="52%">

<p>; set in mask</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>sim</p>
</td>
<td width="52%">

<p>; ignore EFOVFL from now on</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lpi $catch</p>
</td>
<td width="52%">

<p>; load procedure identifier</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>sig</p>
</td>
<td width="52%">

<p>; catch wil get all traps now</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>ste ersave</p>
</td>
<td width="52%">

<p>; save previous trap procedure identifier</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">
</td>
<td width="52%">

<p>; perform calculation now, possibly generating
overflow</p>
</td>
<tr valign="top" align="left">
<td width="2%">

<p>1</p>
</td>
<td width="46%"></td>
<td width="52%">

<p>; label jumped to by catch procedure</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>loe ersave</p>
</td>
<td width="52%">

<p>; get old trap procedure</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>sig</p>
</td>
<td width="52%">

<p>; refer all following trap to old procedure</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>asp 2</p>
</td>
<td width="52%">

<p>; remove result of sig</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>loe msave</p>
</td>
<td width="52%">

<p>; restore previous mask</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>sim</p>
</td>
<td width="52%">

<p>; done now</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">
</td>
<td width="52%">

<p>; load result of calculation</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>ret 2</p>
</td>
<td width="52%">

<p>; return result</p>
</td>
</table>

<p>jmpbuf</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="98%">

<p>con *1,0,0</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="98%">

<p>end</p>
</td>
</table>

<p>Example of catch procedure</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>pro $catch,0</p>
</td>
<td width="52%">

<p>; Local procedure that must catch the overflow trap</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lol 2</p>
</td>
<td width="52%">

<p>; Load trap number</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>loc 4</p>
</td>
<td width="52%">

<p>; check for overflow</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>bne *1</p>
</td>
<td width="52%">

<p>; if other trap, call higher trap procedure</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>gto jmpbuf</p>
</td>
<td width="52%">

<p>; return to procedure calcule</p>
</td>
<tr valign="top" align="left">
<td width="2%">

<p>1</p>
</td>
<td width="46%"></td>
<td width="52%">

<p>; other trap has occurred</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>loe ersave</p>
</td>
<td width="52%">

<p>; previous trap procedure</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>sig</p>
</td>
<td width="52%">

<p>; other procedure will get the traps now</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>asp 2</p>
</td>
<td width="52%">

<p>; remove the result of sig</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lol 2</p>
</td>
<td width="52%">

<p>; stack trap number</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>trp</p>
</td>
<td width="52%">

<p>; call other trap procedure</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>rtt</p>
</td>
<td width="52%">

<p>; if other procedure returns, do the same</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>end</p>
</td>
<td width="52%">
</td>
</table>

<p>10</p>

<p><b>10. EM MACHINE LANGUAGE</b></p>

<p>The EM machine language is designed to make program text
compact and to make decoding easy. Compact program text has
many advantages: programs execute faster, programs occupy
less primary and secondary storage and loading programs into
satellite processors is faster. The decoding of EM machine
language is so simple, that it is feasible to use
interpreters as long as EM hardware machines are not
available. This chapter is irrelevant when back ends are
used to produce executable target machine code.</p>

<p><b>10.1 Instruction encoding</b></p>

<p>A design goal of EM is to make the program text as
compact as possible. Decoding must be easy, however. The
encoding is fully byte oriented, without any small bit
fields. There are 256 primary opcodes, two of which are an
escape to two groups of 256 secondary opcodes each.</p>

<p>EM instructions without arguments have a single opcode
assigned, possibly escaped:</p>

<p><tt>|--------------| | opcode |
|--------------|</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="47%"></td>
<td width="-24%"></td>
<td width="76%">

<p>or</p>
</td>
</table>

<p><tt>|--------------|--------------| | escape | opcode |
|--------------|--------------|</tt></p>

<p>The encoding for instructions with an argument is more
complex. Several instructions have an address from the
global data area as argument. Other instructions have
different opcodes for positive and negative arguments.</p>

<p>There is always an opcode that takes the next two bytes
as argument, high byte first:</p>

<p><tt>|--------------|--------------|--------------| |
opcode | hibyte | lobyte |
|--------------|--------------|--------------|</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="-10%"></td>
<td width="90%">

<p>or</p>
</td>
</table>


<p><tt>|--------------|--------------|--------------|--------------|
| escape | opcode | hibyte | lobyte |
|--------------|--------------|--------------|--------------|</tt></p>

<p>An extra escape is provided for instructions with four
or eight byte arguments.</p>

<p><tt>|--------------|--------------|--------------|
|--------------| | ESCAPE | opcode | hibyte |...| lobyte |
|--------------|--------------|--------------|
|--------------|</tt></p>

<p>For most instructions some argument values predominate.
The most frequent combinations of instruction and argument
will be encoded in a single byte, called a mini:</p>

<p><tt>|---------------| |opcode+argument| (mini)
|---------------|</tt></p>

<p>The number of minis is restricted, because only 254
primary opcodes are available. Many instructions have the
bulk of their arguments fall in the range 0 to 255.
Instructions that address global data have their arguments
distributed over a wider range, but small values of the high
byte are common. For all these cases there is another
encoding that combines the instruction and the high byte of
the argument into a single opcode. These opcodes are called
shorties. Shorties may be escaped.</p>

<p><tt>|--------------|--------------| | opcode+high |
lobyte | (shortie) |--------------|--------------|</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="-10%"></td>
<td width="90%">

<p>or</p>
</td>
</table>

<p><tt>|--------------|--------------|--------------| |
escape | opcode+high | lobyte |
|--------------|--------------|--------------|</tt></p>

<p>Escaped shorties are useless if the normal encoding has
a primary opcode. Note that for some instruction-argument
combinations several different encodings are available. It
is the task of the assembler to select the shortest of
these. The savings by these mini and shortie opcodes are
considerable, about 55%.</p>

<p>Further improvements are possible: the arguments of many
instructions are a multiple of the wordsize. Some do also
not allow zero as an argument. If these arguments are
divided by the wordsize and, when zero is not allowed, then
decremented by 1, more of them can be encoded as shortie or
mini. The arguments of some other instructions rarely or
never assume the value 0, but start at 1. The value 1 is
then encoded as 0, 2 as 1 and so on.</p>

<p>Assigning opcodes to instructions by the assembler is
completely table driven. For details see appendix B.</p>

<p><b>10.2 Procedure descriptors</b></p>

<p>The procedure identifiers used in the interpreter are
indices into a table of procedure descriptors. Each
descriptor contains:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>1.</p>
</td>
<td width="6%"></td>
<td width="22%">

<p>the number of bytes to be reserved for locals at each
invocation.</p>
</td>
<td width="67%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>This is a pointer-sized integer.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>2.</p>
</td>
<td width="6%"></td>
<td width="18%">

<p>the start address of the procedure</p>
</td>
<td width="71%">
</td>
</table>

<p><b>10.3 Load format</b></p>

<p>The EM machine language load format defines the
interface between the EM assembler/loader and the EM machine
itself. A load file consists of a header, the program text
to be executed, a description of the global data area and
the procedure descriptor table, in this order. All integers
in the load file are presented with the least significant
byte first.</p>

<p>The header has two parts: the first half (eight 16-bit
integers) aids in selecting the correct EM machine or
interpreter. Some EM machines, for instance, may have
hardware floating point instructions. The header entries are
as follows (bit 0 is rightmost):</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>1:</p>
</td>
<td width="6%"></td>
<td width="18%">

<p>magic number (07255)</p>
</td>
<td width="71%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>2:</p>
</td>
<td width="6%"></td>
<td width="18%">

<p>flag bits with the following meaning:</p>
</td>
<td width="71%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>bit 0</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>TEST; test for integer overflow etc.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>bit 1</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>PROFILE; for each source line: count the number of memory
cycles executed.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>bit 2</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>FLOW; for each source line: set a bit in a bit map table
if instructions on that line are executed.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>bit 3</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>COUNT; for each source line: increment a counter if that
line is entered.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>bit 4</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>REALS; set if a program uses floating point
instructions.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>bit 5</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>EXTRA; more tests during compiler debugging.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>3:</p>
</td>
<td width="6%"></td>
<td width="22%">

<p>number of unresolved references.</p>
</td>
<td width="67%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>4:</p>
</td>
<td width="6%"></td>
<td width="22%">

<p>version number; used to detect obsolete EM load
files.</p>
</td>
<td width="67%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>5:</p>
</td>
<td width="6%"></td>
<td width="22%">

<p>wordsize ; the number of bytes in each machine word.</p>
</td>
<td width="67%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>6:</p>
</td>
<td width="6%"></td>
<td width="22%">

<p>pointer size ; the number of bytes available for
addressing.</p>
</td>
<td width="67%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>7:</p>
</td>
<td width="6%"></td>
<td width="22%">

<p>unused</p>
</td>
<td width="67%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>8:</p>
</td>
<td width="6%"></td>
<td width="22%">

<p>unused</p>
</td>
<td width="67%">
</td>
</table>

<p>The second part of the header (eight entries, of pointer
size bytes each) describes the load file itself:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>1:</p>
</td>
<td width="6%"></td>
<td width="26%">

<p>NTEXT; the program text size in bytes.</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>2:</p>
</td>
<td width="6%"></td>
<td width="26%">

<p>NDATA; the number of load-file descriptors (see
below).</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>3:</p>
</td>
<td width="6%"></td>
<td width="26%">

<p>NPROC; the number of entries in the procedure descriptor
table.</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>4:</p>
</td>
<td width="6%"></td>
<td width="26%">

<p>ENTRY; procedure number of the procedure to start
with.</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>5:</p>
</td>
<td width="6%"></td>
<td width="26%">

<p>NLINE; the maximum source line number.</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>6:</p>
</td>
<td width="6%"></td>
<td width="26%">

<p>SZDATA; the address of the lowest uninitialized data
byte.</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>7:</p>
</td>
<td width="6%"></td>
<td width="26%">

<p>unused</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="4%">

<p>8:</p>
</td>
<td width="6%"></td>
<td width="26%">

<p>unused</p>
</td>
<td width="63%">
</td>
</table>

<p>The program text consists of NTEXT bytes. NTEXT is
always a multiple of the wordsize. The first byte of the
program text is the first byte of the instruction address
space, i.e. it has address 0. Pointers into the program text
are found in the procedure descriptor table where relocation
is simple and in the global data area. The initialization of
the global data area allows easy relocation of pointers into
both address spaces.</p>

<p>The global data area is described by the NDATA
descriptors. Each descriptor describes a number of
consecutive words (of wordsize) and consists of a sequence
of bytes. While reading the descriptors from the load file,
one can initialize the global data area from low to high
addresses. The size of the initialized data area is given by
SZDATA, this number can be used to check the
initialization.<br>
The header of each descriptor consists of a byte, describing
the type, and a count. The number of bytes used for this
(unsigned) count depends on the type of the descriptor and
is either a pointer-sized integer or one byte. The meaning
of the count depends on the descriptor type. At load time an
interpreter can perform any conversion deemed necessary,
such as reordering bytes in integers and pointers and adding
base addresses to pointers.</p>

<p>In the following pictures we show a graphical notation
of the initializers. The leftmost rectangle represents the
leading byte.</p>

<p>Fields marked with</p>

<p align=center><img src="grohtml-97447.png"></p>

<p><tt>------------------- | 0 | n | repeat last
initialization n times -------------------</tt></p>

<p><tt>--------- | 1 | m | m uninitialized words
---------</tt></p>

<p><tt>____________ / bytes \ ----------------- ----- | 2 |
m | b | b |...| b | m initialized bytes -----------------
-----</tt></p>

<p><tt>_________ / word \ ----------------------- | 3 | m |
w |... m initialized wordsized integers
-----------------------</tt></p>

<p><tt>_________ / pointer \ ----------------------- | 4 |
m | p |... m initialized data pointers
-----------------------</tt></p>

<p><tt>_________ / pointer \ ----------------------- | 5 |
m | p |... m initialized instruction pointers
-----------------------</tt></p>

<p><tt>____________ / bytes \ ------------------------- | 6
| m | b | b |...| b | initialized integer of size m
-------------------------</tt></p>

<p><tt>____________ / bytes \ ------------------------- | 7
| m | b | b |...| b | initialized unsigned of size m
-------------------------</tt></p>

<p><tt>____________ / string \ ------------------------- |
8 | m | s | initialized float of size m
-------------------------</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">

<p>type 0:</p>
</td>
<td width="6%"></td>
<td width="28%">

<p>If the last initialization initialized k bytes starting
at address <i>a</i>, do the same initialization again n
times, starting at <i>a</i>+k, <i>a</i>+2*k, ....
<i>a</i>+n*k. This is the only descriptor whose starting
byte is followed by an integer with the size of a pointer,
in all other descriptors the first byte is followed by a
one-byte count. This descriptor must be preceded by a
descriptor of another type.</p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="14%">

<p>type 1:</p>
</td>
<td width="6%"></td>
<td width="28%">

<p>Reserve m words, not explicitly initialized (BSS and
HOL).</p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="14%">

<p>type 2:</p>
</td>
<td width="6%"></td>
<td width="28%">

<p>The m bytes following the descriptor header are
initializers for the next m bytes of the global data area. m
is divisible by the wordsize.</p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="14%">

<p>type 3:</p>
</td>
<td width="6%"></td>
<td width="28%">

<p>The m words following the header are initializers for
the next m words of the global data area.</p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="14%">

<p>type 4:</p>
</td>
<td width="6%"></td>
<td width="28%">

<p>The m data address space pointers following the header
are initializers for the next m data pointers in the global
data area. Interpreters that represent EM pointers by target
machine addresses must relocate all data pointers.</p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="14%">

<p>type 5:</p>
</td>
<td width="6%"></td>
<td width="28%">

<p>The m instruction address space pointers following the
header are initializers for the next m instruction pointers
in the global data area. Interpreters that represent EM
instruction pointers by target machine addresses must
relocate these pointers.</p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="14%">

<p>type 6:</p>
</td>
<td width="6%"></td>
<td width="28%">

<p>The m bytes following the header form a signed integer
number with a size of m bytes, which is an initializer for
the next m bytes of the global data area. m is governed by
the same restrictions as for transfer of objects to/from
memory.</p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="14%">

<p>type 7:</p>
</td>
<td width="6%"></td>
<td width="28%">

<p>The m bytes following the header form an unsigned
integer number with a size of m bytes, which is an
initializer for the next m bytes of the global data area. m
is governed by the same restrictions as for transfer of
objects to/from memory.</p>
</td>
<td width="51%">
</td>
<tr valign="top" align="left">
<td width="14%">

<p>type 8:</p>
</td>
<td width="6%"></td>
<td width="28%">

<p>The header is followed by an ASCII string, null
terminated, to initialize, in global data, a floating point
number with a size of m bytes. m is governed by the same
restrictions as for transfer of objects to/from memory. The
ASCII string contains the notation of a real as used in the
Pascal language.</p>
</td>
<td width="51%">
</td>
</table>

<p>The NPROC procedure descriptors on the load file consist
of an instruction space address (of pointer size) and an
integer (of pointer size) specifying the number of bytes for
locals.</p>

<p>11</p>

<p><b>11. EM ASSEMBLY LANGUAGE</b></p>

<p>We use two representations for assembly language
programs, one is in ASCII and the other is the compact
assembly language. The latter needs less space than the
first for the same program and therefore allows faster
processing. Our only program accepting ASCII assembly
language converts it to the compact form. All other programs
expect compact assembly input. The first part of the chapter
describes the ASCII assembly language and its semantics. The
second part describes the syntax of the compact assembly
language. The last part lists the EM instructions with the
type of arguments allowed and an indication of the function.
Appendix A gives a detailed description of the effect of all
instructions in the form of a Pascal program.</p>

<p><b>11.1 ASCII assembly language</b></p>

<p>An assembly language program consists of a series of
lines, each line may be blank, contain one
(pseudo)instruction or contain one label. Input to the
assembler is in lower case. Upper case is used in this
document merely to distinguish keywords from the surrounding
prose. Comment is allowed at the end of each line and starts
with a semicolon &quot;;&quot;. This kind of comment does
not exist in the compact form.</p>

<p>Labels must be placed all by themselves on a line and
start in column 1. There are two kinds of labels,
instruction and data labels. Instruction labels are unsigned
positive integers. The scope of an instruction label is its
procedure.</p>

<p>The pseudoinstructions CON, ROM and BSS may be preceded
by a line containing a 1&minus;8 character data label, the
first character of which is a letter, period or underscore.
The period may only be followed by digits, the others may be
followed by letters, digits and underscores. The use of the
character &quot;.&quot; followed by a constant, which must
be in the range 1 to 32767 (e.g. &quot;.40&quot;) is
recommended for compiler generated programs. These labels
are considered as a special case and handled more
efficiently in compact assembly language (see below). Note
that a data label on its own or two consecutive labels are
not allowed.</p>

<p>Each statement may contain an instruction mnemonic or
pseudoinstruction. These must begin in column 2 or later
(not column 1) and must be followed by a space, tab,
semicolon or LF. Everything on the line following a
semicolon is taken as a comment.</p>

<p>Each input file contains one module. A module may
contain many procedures, which may be nested. A procedure
consists of a PRO statement, a (possibly empty) collection
of instructions and pseudoinstructions and finally an END
statement. Pseudoinstructions are also allowed between
procedures. They do not belong to a specific procedure.</p>

<p>All constants in EM are interpreted in the decimal base.
The ASCII assembly language accepts constant expressions
wherever constants are allowed. The operators recognized
are: +, &minus;, *, % and / with the usual precedence order.
Use of the parentheses ( and ) to alter the precedence order
is allowed.</p>

<p><i>11.1.1 Instruction arguments</i></p>

<p>Unlike many other assembly languages, the EM assembly
language requires all arguments of normal and
pseudoinstructions to be either a constant or an identifier,
but not a combination of these two. There is one exception
to this rule: when a data label is used for initialization
or as an instruction argument, expressions of the form
&rsquo;label+constant&rsquo; and
&rsquo;label-constant&rsquo; are allowed. This makes it
possible to address, for example, the third word of a ten
word BSS block directly. Thus LOE LABEL+4 is permitted and
so is CON LABEL+3. The resulting address is must be in the
same fragment as the label. It is not allowed to add or
subtract from instruction labels or procedure identifiers,
which certainly is not a severe restriction and greatly aids
optimization.</p>

<p>Instruction arguments can be constants, data labels,
data labels offsetted by a constant, instruction labels and
procedure identifiers. The range of integers allowed depends
on the instruction. Most instructions allow only integers
(signed or unsigned) that fit in a word. Arguments used as
offsets to pointers should fit in a pointer-sized integer.
Finally, arguments to LDC should fit in a double-word
integer.</p>

<p>Several instructions have two possible forms: with an
explicit argument and with an implicit argument on top of
the stack. The size of the implicit argument is the
wordsize. The implicit argument is always popped before all
other operands. For example: &rsquo;CMI 4&rsquo; specifies
that two four-byte signed integers on top of the stack are
to be compared. &rsquo;CMI&rsquo; without an argument
expects a wordsized integer on top of the stack that
specifies the size of the integers to be compared. Thus the
following two sequences are equivalent:</p>

<p align=center><img src="grohtml-97448.png"></p>

<p>Section 11.1.6 shows the arguments allowed for each
instruction.</p>

<p><i>11.1.2 Pseudoinstruction arguments</i></p>

<p>Pseudoinstruction arguments can be divided in two
classes: Initializers and others. The following initializers
are allowed: signed integer constants, unsigned integer
constants, floating-point constants, strings, data labels,
data labels offsetted by a constant, instruction labels and
procedure identifiers.</p>

<p>Constant initializers in BSS, HOL, CON and ROM
pseudoinstructions can be followed by a letter I, U or F.
This indicator specifies the type of the initializer:
Integer, Unsigned or Float. If no indicator is present I is
assumed. The size of the initializer is the wordsize unless
the indicator is followed by an integer specifying the
initializer&rsquo;s size. This integer is governed by the
same restrictions as for transfer of objects to/from memory.
As in instruction arguments, initializers include
expressions of the form: &quot;LABEL+offset&quot; and
&quot;LABEL&minus;offset&quot;. The offset must be an
unsigned decimal constant. The &rsquo;IUF&rsquo; indicators
cannot be used in the offsets.</p>

<p>Data labels are referred to by their name.</p>

<p>Strings are surrounded by double quotes (&quot;).
Semicolon&rsquo;s in string do not indicate the start of
comment. In the ASCII representation the escape character \
(backslash) alters the meaning of subsequent character(s).
This feature allows inclusion of zeroes, graphic characters
and the double quote in the string. The following escape
sequences exist:</p>

<p align=center><img src="grohtml-97449.png"></p>

<p>The escape <b>\ddd</b> consists of the backslash
followed by 1, 2, or 3 octal digits specifying the value of
the desired character. If the character following a
backslash is not one of those specified, the backslash is
ignored. Example: CON &quot;hello\012\0&quot;. Each string
element initializes a single byte. The ASCII character set
is used to map characters onto values.</p>

<p>Instruction labels are referred to as *1, *2, etc. in
both branch instructions and as initializers.</p>

<p>The notation $procname means the identifier for the
procedure with the specified name. This identifier has the
size of a pointer.</p>

<p><i>11.1.3 Notation</i></p>

<p>First, the notation used for the arguments, classes of
instructions and pseudoinstructions.</p>

<p align=center><img src="grohtml-974410.png"></p>

<p><i>11.1.4 Pseudoinstructions</i></p>

<p><i>11.1.4.1 Storage declaration</i></p>

<p>Initialized global data is allocated by the
pseudoinstruction CON, which needs at least one argument.
Each argument is used to allocate and initialize a number of
consecutive bytes in data memory. The number of bytes to be
allocated and the alignment depend on the type of the
argument. For each argument, an integral number of words,
determined by the argument type, is allocated and
initialized.</p>

<p>The pseudoinstruction ROM is the same as CON, except
that it guarantees that the initialized words will not
change during the execution of the program. This information
allows optimizers to do certain calculations such as array
indexing and subrange checking at compile time instead of at
run time.</p>

<p>The pseudoinstruction BSS allocates uninitialized global
data or large blocks of data initialized by the same value.
The first argument to this pseudo is the number of bytes
required, which must be a multiple of the wordsize. The
other arguments specify the value used for initialization
and whether the initialization is only for convenience or a
strict necessity. The pseudoinstruction HOL is similar to
BSS in that it requests an (un)initialized global data
block. Addressing of a HOL block, however, is quasi
absolute. The first byte is addressed by 0, the second byte
by 1 etc. in assembly language. The assembler/loader adds
the base address of the HOL block to these numbers to obtain
the absolute address in the machine language.</p>

<p>The scope of a HOL block starts at the HOL pseudo and
ends at the next HOL pseudo or at the end of a module
whatever comes first. Each instruction falls in the scope of
at most one HOL block, the current HOL block. It is not
allowed to have more than one HOL block per procedure.</p>

<p>The alignment restrictions are enforced by the
pseudoinstructions. All initializers are aligned on a
multiple of their size or the wordsize whichever is smaller.
Strings form an exception, they are to be seen as a sequence
of initializers each for one byte, i.e. strings are not
padded with zero bytes. Switching to another type of
fragment or placing a label forces word-alignment. There are
three types of fragments in global data space: CON, ROM and
BSS/HOL.</p>

<p>BSS &lt;cst1&gt;,&lt;val&gt;,&lt;cst2&gt;</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Reserve &lt;cst1&gt; bytes. &lt;val&gt; is the value used
to initialize the area. &lt;cst1&gt; must be a multiple of
the size of &lt;val&gt;. &lt;cst2&gt; is 0 if the
initialization is not strictly necessary, 1 if it is.</p>
</td>
</table>

<p>HOL &lt;cst1&gt;,&lt;val&gt;,&lt;cst2&gt;</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Idem, but all following absolute global data references
will refer to this block. Only one HOL is allowed per
procedure, it has to be placed before the first
instruction.</p>
</td>
</table>

<p>CON &lt;val&gt;+</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Assemble global data words initialized with the
&lt;val&gt; constants.</p>
</td>
</table>

<p>ROM &lt;val&gt;+</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Idem, but the initialized data will never be changed by
the program.</p>
</td>
</table>

<p><i>11.1.4.2 Partitioning</i></p>

<p>Two pseudoinstructions partition the input into
procedures:</p>

<p>PRO &lt;pro&gt;[,&lt;cst&gt;]</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Start of procedure. &lt;pro&gt; is the procedure name.
&lt;cst&gt; is the number of bytes for locals. The number of
bytes for locals must be specified in the PRO or END
pseudoinstruction. When specified in both, they must be
identical.</p>
</td>
</table>

<p>END [&lt;cst&gt;]</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>End of Procedure. &lt;cst&gt; is the number of bytes for
locals. The number of bytes for locals must be specified in
either the PRO or END pseudoinstruction or both.</p>
</td>
</table>

<p><i>11.1.4.3 Visibility</i></p>

<p>Names of data and procedures in an EM module can either
be internal or external. External names are known outside
the module and are used to link several pieces of a program.
Internal names are not known outside the modules they are
used in. Other modules will not &rsquo;see&rsquo; an
internal name.</p>

<p>To reduce the number of passes needed, it must be known
at the first occurrence whether a name is internal or
external. If the first occurrence of a name is in a
definition, the name is considered to be internal. If the
first occurrence of a name is a reference, the name is
considered to be external. If the first occurrence is in one
of the following pseudoinstructions, the effect of the
pseudo has precedence.</p>

<p>EXA &lt;dlb&gt;</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>External name. &lt;dlb&gt; is known, possibly defined,
outside this module. Note that &lt;dlb&gt; may be defined in
the same module.</p>
</td>
</table>

<p>EXP &lt;pro&gt;</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>External procedure identifier. Note that &lt;pro&gt; may
be defined in the same module.</p>
</td>
</table>

<p>INA &lt;dlb&gt;</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Internal name. &lt;dlb&gt; is internal to this module and
must be defined in this module.</p>
</td>
</table>

<p>INP &lt;pro&gt;</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Internal procedure. &lt;pro&gt; is internal to this
module and must be defined in this module.</p>
</td>
</table>

<p><i>11.1.4.4 Miscellaneous</i></p>

<p>Two other pseudoinstructions provide miscellaneous
features:</p>

<p>EXC &lt;cst1&gt;,&lt;cst2&gt;</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Two blocks of instructions preceding this one are
interchanged before being processed. &lt;cst1&gt; gives the
number of lines of the first block. &lt;cst2&gt; gives the
number of lines of the second one. Blank and pure comment
lines do not count. This instruction is obsolete. Its use is
strongly discouraged.</p>
</td>
</table>

<p>MES &lt;cst&gt;[,&lt;par&gt;]*</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>A special type of comment. Used by compilers to
communicate with the optimizer, assembler, etc. as
follows:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 0</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>An error has occurred, stop further processing.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 1</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Suppress optimization.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 2,&lt;cst1&gt;,&lt;cst2&gt;</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Use wordsize &lt;cst1&gt; and pointer size
&lt;cst2&gt;.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES
3,&lt;cst1&gt;,&lt;cst2&gt;,&lt;cst3&gt;,&lt;cst4&gt;</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Indicates that a local variable is never referenced
indirectly. Used to indicate that a register may be used for
a specific variable. &lt;cst1&gt; is offset in bytes from AB
if positive and offset from LB if negative. &lt;cst2&gt;
gives the size of the variable. &lt;cst3&gt; indicates the
class of the variable. The following values are currently
recognized:<br>
0 The variable can be used for anything.<br>
1 The variable is used as a loopindex.<br>
2 The variable is used as a pointer.<br>
3 The variable is used as a floating point number.<br>
&lt;cst4&gt; gives the priority of the variable, higher
numbers indicate better candidates.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 4,&lt;cst&gt;,&lt;str&gt;</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Number of source lines in file &lt;str&gt; (for
profiler).</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 5</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Floating point used.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 6,&lt;val&gt;*</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Comment. Used to provide comments in compact assembly
language.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 7,.....</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Reserved.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 8,&lt;pro&gt;[,&lt;dlb&gt;]...</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Library module. Indicates that the module may only be
loaded if it is useful, that is, if it can satisfy any
unresolved references during the loading process. May not be
preceded by any other pseudo, except MES&rsquo;s.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 9,&lt;cst&gt;</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Guarantees that no more than &lt;cst&gt; bytes of
parameters are accessed, either directly or indirectly.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 10,&lt;cst&gt;[,&lt;par&gt;]*</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>This message number is reserved for the global optimizer.
It inserts these messages in its output as hints to
backends. &lt;cst&gt; indicates the type of hint.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>MES 11</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="19%"></td>
<td width="80%">
<p>Procedures containing this message are possible
destinations of non-local goto&rsquo;s with the GTO
instruction. Some backends keep locals in registers, the
locals in this procedure should not be kept in registers and
all registers containing locals of other procedures should
be saved upon entry to this procedure.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Each backend is free to skip irrelevant MES pseudos.</p>
</td>
</table>

<p><b>11.2 The Compact Assembly Language</b></p>

<p>The assembler accepts input in a highly encoded form.
This form is intended to reduce the amount of file transport
between the front ends, optimizers and back ends, and also
reduces the amount of storage required for storing
libraries. Libraries are stored as archived compact assembly
language, not machine language.</p>

<p>When beginning to read the input, the assembler is in
neutral state, and expects either a label or an instruction
(including the pseudoinstructions). The meaning of the next
byte(s) when in neutral state is as follows, where b1, b2
etc. represent the succeeding bytes.</p>

<p align=center><img src="grohtml-974411.png"></p>

<p>After a label, the assembler is back in neutral state;
it can immediately accept another label or an instruction in
the next byte. No linefeeds are used to separate lines.</p>

<p>If an opcode expects no arguments, the assembler is back
in neutral state after reading the one byte containing the
instruction number. If it has one or more arguments (only
pseudos have more than 1), the arguments follow directly,
encoded as follows:</p>

<p align=center><img src="grohtml-974412.png"></p>

<p>Absence of an optional argument is indicated by a
special byte.</p>

<p align=center><img src="grohtml-974413.png"></p>

<p>The bytes specifying the value of a 16, 32 or 64 bit
constant are presented in two&rsquo;s complement notation,
with the least significant byte first. For example: the
value of a 32 bit constant is ((s4*256+b3)*256+b2)*256+b1,
where s4 is b4&minus;256 if b4 is greater than 128 else s4
takes the value of b4. A &lt;string&gt; consists of a
&lt;cst&gt; immediately followed by a sequence of bytes with
length &lt;cst&gt;.</p>

<p>The pseudoinstructions fall into several categories,
depending on their arguments:</p>
<pre>     Group 1 &minus; EXC, BSS, HOL have a known number of arguments
     Group 2 &minus; EXA, EXP, INA, INP have a string as argument
     Group 3 &minus; CON, MES, ROM have a variable number of various things
     Group 4 &minus; END, PRO have a trailing optional argument.
</pre>

<p>Groups 1 and 2 use the encoding described above. Group 3
also uses the encoding listed above, with an &lt;end&gt;
byte after the last argument to indicate the end of the
list. Group 4 uses an &lt;end&gt; byte if the trailing
argument is not present.</p>

<p align=center><img src="grohtml-974414.png"></p>

<p><b>11.3 Assembly language instruction list</b></p>

<p>For each instruction in the list the range of argument
values in the assembly language is given. The column headed
<i>assem</i> contains the mnemonics defined in 11.1.3. The
following column specifies restrictions of the argument
value. Addresses have to obey the restrictions mentioned in
chapter 2. The classes of arguments are indicated by
letters:</p>

<p align=center><img src="grohtml-974415.png"></p>

<p>The * at the rationale for <b>w</b> indicates that the
argument can either be given as argument or on top of the
stack. If the argument is omitted, the argument is fetched
from the stack; it is assumed to be a wordsized unsigned
integer. Instructions that check for undefined integer or
floating-point values and underflow or overflow are
indicated below by (*).</p>
<pre>     GROUP 1 &minus; LOAD


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>LOC <b>c</b> :</p>
<td width="13%"></td>
<td width="20%">

<p>Load constant (i.e. push one word onto the stack)<br>
LDC <b>d</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load double constant ( push two words )<br>
LOL <b>l</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load word at <b>l</b>-th local (<b>l</b>&lt;0) or
parameter (<b>l</b>&gt;=0)<br>
LOE <b>g</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load external word <b>g</b><br>
LIL <b>l</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load word pointed to by <b>l</b>-th local or
parameter<br>
LOF <b>f</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load offsetted (top of stack + <b>f</b> yield
address)<br>
LAL <b>l</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load address of local or parameter<br>
LAE <b>g</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load address of external<br>
LXL <b>n</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load lexical (address of LB <b>n</b> static levels
back)<br>
LXA <b>n</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load lexical (address of AB <b>n</b> static levels
back)<br>
LOI <b>o</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load indirect <b>o</b> bytes (address is popped from the
stack)<br>
LOS <b>w</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load indirect, <b>w</b>-byte integer on top of stack
gives object size<br>
LDL <b>l</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load double local or parameter (two consecutive words
are stacked)<br>
LDE <b>g</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load double external (two consecutive externals are
stacked)<br>
LDF <b>f</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load double offsetted (top of stack + <b>f</b> yield
address)<br>
LPI <b>p</b> :</p>
</td>
<td width="66%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="20%">

<p>Load procedure identifier</p>
</td>
<td width="66%">
</td>
</table>
<pre>     GROUP 2 &minus; STORE


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>STL <b>l</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Store local or parameter<br>
STE <b>g</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store external<br>
SIL <b>l</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store into word pointed to by <b>l</b>-th local or
parameter<br>
STF <b>f</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store offsetted<br>
STI <b>o</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store indirect <b>o</b> bytes (pop address, then
data)<br>
STS <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store indirect, <b>w</b>-byte integer on top of stack
gives object size<br>
SDL <b>l</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store double local or parameter<br>
SDE <b>g</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store double external<br>
SDF <b>f</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store double offsetted</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 3 &minus; INTEGER ARITHMETIC


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>ADI <b>w</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Addition (*)<br>
SBI <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Subtraction (*)<br>
MLI <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Multiplication (*)<br>
DVI <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Division (*)<br>
RMI <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Remainder (*)<br>
NGI <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Negate (two&rsquo;s complement) (*)<br>
SLI <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Shift left (*)<br>
SRI <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Shift right (*)</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 4 &minus; UNSIGNED ARITHMETIC


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>ADU <b>w</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Addition<br>
SBU <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Subtraction<br>
MLU <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Multiplication<br>
DVU <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Division<br>
RMU <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Remainder<br>
SLU <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Shift left<br>
SRU <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Shift right</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 5 &minus; FLOATING POINT ARITHMETIC


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>ADF <b>w</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Floating add (*)<br>
SBF <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Floating subtract (*)<br>
MLF <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Floating multiply (*)<br>
DVF <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Floating divide (*)<br>
NGF <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Floating negate (*)<br>
FIF <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Floating multiply and split integer and fraction part
(*)<br>
FEF <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Split floating number in exponent and fraction part
(*)</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 6 &minus; POINTER ARITHMETIC


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>ADP <b>f</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Add <b>f</b> to pointer on top of stack<br>
ADS <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Add <b>w</b>-byte value and pointer<br>
SBS <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Subtract pointers in same fragment and push diff as size
<b>w</b> integer</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 7 &minus; INCREMENT/DECREMENT/ZERO


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>INC <b>&minus;</b> :</p>
<td width="9%"></td>
<td width="10%">

<p>Increment word on top of stack by 1 (*)<br>
INL <b>l</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p>Increment local or parameter (*)<br>
INE <b>g</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p>Increment external (*)<br>
DEC <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p>Decrement word on top of stack by 1 (*)<br>
DEL <b>l</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p>Decrement local or parameter (*)<br>
DEE <b>g</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p>Decrement external (*)<br>
ZRL <b>l</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p>Zero local or parameter<br>
ZRE <b>g</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p>Zero external<br>
ZRF <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p>Load a floating zero of size <b>w</b><br>
ZER <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">

<p>Load <b>w</b> zero bytes</p>
<pre>     GROUP 8 &minus; CONVERT    (stack:</td>
<td width="79%">
  source, source size, dest. size (top))


       CII <b>&minus;</b> :</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">
 Convert integer to integer (*)
       CUI <b>&minus;</b> :</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">
 Convert unsigned to integer (*)
       CFI <b>&minus;</b> :</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">
 Convert floating to integer (*)
       CIF <b>&minus;</b> :</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">
 Convert integer to floating (*)
       CUF <b>&minus;</b> :</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">
 Convert unsigned to floating (*)
       CFF <b>&minus;</b> :</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">
 Convert floating to floating (*)
       CIU <b>&minus;</b> :</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">
 Convert integer to unsigned
       CUU <b>&minus;</b> :</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">
 Convert unsigned to unsigned
       CFU <b>&minus;</b> :</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="10%">
 Convert floating to unsigned</td>
<td width="79%">
</td>
</table>

</pre>
<pre>     GROUP 9 &minus; LOGICAL


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>AND <b>w</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Boolean and on two groups of <b>w</b> bytes<br>
IOR <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Boolean inclusive or on two groups of <b>w</b> bytes<br>
XOR <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Boolean exclusive or on two groups of <b>w</b> bytes<br>
COM <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Complement (one&rsquo;s complement of top <b>w</b>
bytes)<br>
ROL <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Rotate left a group of <b>w</b> bytes<br>
ROR <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Rotate right a group of <b>w</b> bytes</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 10 &minus; SETS


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>INN <b>w</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Bit test on <b>w</b> byte set (bit number on top of
stack)<br>
SET <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Create singleton <b>w</b> byte set with bit n on (n is
top of stack)</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 11 &minus; ARRAY


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>LAR <b>w</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Load array element, descriptor contains integers of size
<b>w</b><br>
SAR <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store array element<br>
AAR <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Load address of array element</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 12 &minus; COMPARE


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>CMI <b>w</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Compare <b>w</b> byte integers, Push negative, zero,
positive for &lt;, = or &gt;<br>
CMF <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Compare <b>w</b> byte reals<br>
CMU <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Compare <b>w</b> byte unsigneds<br>
CMS <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Compare <b>w</b> byte values, can only be used for bit
for bit equality test<br>
CMP <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Compare pointers</p>

<p>TLT <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>True if less, i.e. iff top of stack &lt; 0<br>
TLE <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>True if less or equal, i.e. iff top of stack &lt;= 0<br>
TEQ <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>True if equal, i.e. iff top of stack = 0<br>
TNE <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>True if not equal, i.e. iff top of stack non zero<br>
TGE <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>True if greater or equal, i.e. iff top of stack &gt;=
0<br>
TGT <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>True if greater, i.e. iff top of stack &gt; 0</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 13 &minus; BRANCH


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>BRA <b>b</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Branch unconditionally to label <b>b</b></p>

<p>BLT <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch less (pop 2 words, branch if top &gt; second)<br>
BLE <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch less or equal<br>
BEQ <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch equal<br>
BNE <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch not equal<br>
BGE <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch greater or equal<br>
BGT <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch greater</p>

<p>ZLT <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch less than zero (pop 1 word, branch negative)<br>
ZLE <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch less or equal to zero<br>
ZEQ <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch equal zero<br>
ZNE <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch not zero<br>
ZGE <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch greater or equal zero<br>
ZGT <b>b</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Branch greater than zero</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 14 &minus; PROCEDURE CALL


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>CAI <b>&minus;</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Call procedure (procedure identifier on stack)<br>
CAL <b>p</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Call procedure (with identifier <b>p</b>)<br>
LFR <b>s</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Load function result<br>
RET <b>z</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Return (function result consists of top <b>z</b>
bytes)</p>
</td>
<td width="79%">
</td>
</table>
<pre>     GROUP 15 &minus; MISCELLANEOUS


</pre>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>ASP <b>f</b> :</p>
<td width="13%"></td>
<td width="6%">

<p>Adjust the stack pointer by <b>f</b><br>
ASS <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Adjust the stack pointer by <b>w</b>-byte integer<br>
BLM <b>z</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Block move <b>z</b> bytes; first pop destination addr,
then source addr<br>
BLS <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Block move, size is in <b>w</b>-byte integer on top of
stack<br>
CSA <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Case jump; address of jump table at top of stack<br>
CSB <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Table lookup jump; address of jump table at top of
stack<br>
DCH <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Follow dynamic chain, convert LB to LB of caller<br>
DUP <b>s</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Duplicate top <b>s</b> bytes<br>
DUS <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Duplicate top <b>w</b> bytes<br>
EXG <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Exchange top <b>w</b> bytes<br>
FIL <b>g</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>File name (external 4 := <b>g</b>)<br>
GTO <b>g</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Non-local goto, descriptor at <b>g</b><br>
LIM <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Load 16 bit ignore mask<br>
LIN <b>n</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Line number (external 0 := <b>n</b>)<br>
LNI <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Line number increment<br>
LOR <b>r</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Load register (0=LB, 1=SP, 2=HP)<br>
LPB <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Convert local base to argument base<br>
MON <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Monitor call<br>
NOP <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>No operation<br>
RCK <b>w</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Range check; trap on error<br>
RTT <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Return from trap<br>
SIG <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Trap errors to proc identifier on top of stack, &minus;2
resets default<br>
SIM <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store 16 bit ignore mask<br>
STR <b>r</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Store register (0=LB, 1=SP, 2=HP)<br>
TRP <b>&minus;</b> :</p>
</td>
<td width="79%">
</td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="6%">

<p>Cause trap to occur (Error number on stack)</p>
</td>
<td width="79%">
</td>
</table>

<p>12</p>

<p><b>A. EM INTERPRETER</b></p>
<pre>{ This  is an interpreter for EM.  It serves as  the official machine
  definition.  This interpreter must run on a machine which supports
  arithmetic with words and memory offsets.

 Certain aspects of the definition are over specified.  In particular:

   1. The representation of  an  address on the stack  need not be the
       numerical value of the memory location.

   2. The state of  the stack is not defined  after a trap has aborted
       an instruction in the middle.  For example, it is officially un-
       defined  whether the second  operand of an  ADD  instruction has
       been popped  or  not  if the  first one is undefined ( -32768 or
       unsigned 32768).

   3. The memory layout is implementation dependent. Only the most
       basic checks are performed whenever memory is accessed.

   4. The representation of an integer or set on the stack is not fixed
       in bit order.

   5. The format and existence of the procedure descriptors depends on
       the implementation.

   6. The result of the compare operators  CMI etc.  are -1, 0  and  1
       here, but other negative  and  positive values will do  and they
       need not be the same each time.

   7. The shift count for SHL, SHR, ROL and ROR must be in the range 0
       to object size in bits - 1.  The effect of a  count  not in this
       range is undefined.
}
</pre>

<p>13</p>

<p><tt>{$i256} {$d+} program
em(tables,prog,input,output);</tt></p>

<p><tt>label 8888,9999;</tt></p>

<p><tt>const t15 = 32768; { 2**15 } t15m1 = 32767; { 2**15
-1 } t16 = 65536; { 2**16 } t16m1 = 65535; { 2**16 -1 }
t31m1 = 2147483647; { 2**31 -1 }</tt></p>

<p><tt>wsize = 2; { number of bytes in a word } asize = 2;
{ number of bytes in an address } fsize = 4; { number of
bytes in a floating point number } maxret =4; { number of
words in the return value area }</tt></p>

<p><tt>signbit = t15; { the power of two indicating the
sign bit } negoff = t16; { the next power of two } maxsint =
t15m1; { the maximum signed integer } maxuint = t16m1; { the
maximum unsigned integer } maxdbl = t31m1; { the maximum
double signed integer } maxadr = t16m1; { the maximum
address } maxoffs = t15m1; { the maximum offset from an
address } maxbitnr= 15; { the number of the highest bit
}</tt></p>

<p><tt>lineadr = 0; { address of the line number } fileadr
= 4; { address of the file name } maxcode = 8191; { highest
byte in code address space } maxdata = 8191; { highest byte
in data address space }</tt></p>

<p><tt>{ format of status save area } statd = 4; { how far
is static link from lb } dynd = 2; { how far is dynamic link
from lb } reta = 0; { how far is the return address from lb
} savsize = 4; { size of save area in bytes }</tt></p>

<p><tt>{ procedure descriptor format } pdlocs = 0; { offset
for size of local variables in bytes } pdbase = asize; {
offset for the procedure base } pdsize = 4; { size of
procedure descriptor in bytes = 2*asize }</tt></p>

<p><tt>{ header words } NTEXT = 1; NDATA = 2; NPROC = 3;
ENTRY = 4; NLINE = 5; SZDATA = 6;</tt></p>

<p><tt>escape1 = 254; { escape to secondary opcodes }
escape2 = 255; { escape to tertiary opcodes } undef =
signbit; { the range of integers is -32767 to +32767
}</tt></p>

<p><tt>{ error codes } EARRAY = 0; ERANGE = 1; ESET = 2;
EIOVFL = 3; EFOVFL = 4; EFUNFL = 5; EIDIVZ = 6; EFDIVZ = 7;
EIUND = 8; EFUND = 9; ECONV = 10; ESTACK = 16; EHEAP = 17;
EILLINS = 18; EODDZ = 19; ECASE = 20; EMEMFLT = 21; EBADPTR
= 22; EBADPC = 23; EBADLAE = 24; EBADMON = 25; EBADLIN = 26;
EBADGTO = 27;</tt></p>

<p>14</p>


<p><tt>{---------------------------------------------------------------------------}
{ Declarations }
{---------------------------------------------------------------------------}</tt></p>

<p><tt>type bitval= 0..1; { one bit } bitnr= 0..maxbitnr; {
bits in machine words are numbered 0 to 15 } byte= 0..255; {
memory is an array of bytes } adr= {0..maxadr} long; { the
range of addresses } word= {0..maxuint} long;{ the range of
unsigned integers } offs= -maxoffs..maxoffs; { the range of
signed offsets from addresses } size= 0..maxoffs; { the
range of sizes is the positive offsets } sword=
{-signbit..maxsint} long; { the range of signed integers }
full= {-maxuint..maxuint} long; { intermediate results need
this range } double={-maxdbl..maxdbl} long; { double
precision range } bftype= (andf,iorf,xorf); { tells which
boolean operator needed } insclass=(prim,second,tert); {
tells which opcode table is in use }
instype=(implic,explic); { does opcode have implicit or
explicit operand } iflags= (mini,short,sbit,wbit,zbit,ibit);
ifset= set of iflags;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><tt>mnem = ( NON,</tt></p>
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>AAR, ADF, ADI, ADP, ADS, ADU,XAND, ASP, ASS,
BEQ,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>BGE, BGT, BLE, BLM, BLS, BLT, BNE, BRA, CAI,
CAL,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>CFF, CFI, CFU, CIF, CII, CIU, CMF, CMI, CMP,
CMS,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>CMU, COM, CSA, CSB, CUF, CUI, CUU, DCH, DEC,
DEE,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>DEL, DUP, DUS, DVF, DVI, DVU, EXG, FEF, FIF,
FIL,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>GTO, INC, INE, INL, INN, IOR, LAE, LAL, LAR,
LDC,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>LDE, LDF, LDL, LFR, LIL, LIM, LIN, LNI, LOC,
LOE,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>LOF, LOI, LOL, LOR, LOS, LPB, LPI, LXA, LXL,
MLF,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>MLI, MLU, MON, NGF, NGI, NOP, RCK, RET, RMI,
RMU,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>ROL, ROR, RTT, SAR, SBF, SBI, SBS, SBU, SDE,
SDF,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>SDL,XSET, SIG, SIL, SIM, SLI, SLU, SRI, SRU,
STE,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>STF, STI, STL, STR, STS, TEQ, TGE, TGT, TLE,
TLT,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>TNE, TRP, XOR, ZEQ, ZER, ZGE, ZGT, ZLE, ZLT,
ZNE,</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>ZRE, ZRF, ZRL);</tt></p>

<p><tt>dispatch = record</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>iflag: ifset;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>instr: mnem;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>case instype of</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>implic: (implicit:sword);</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>explic: (ilength:byte);</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
</table>

<p><tt>var code: packed array[0..maxcode] of byte; { code
space } data: packed array[0..maxdata] of byte; { data space
} retarea: array[1..maxret ] of word; { return area }
pc,lb,sp,hp,pd: adr; { internal machine registers } i:
integer; { integer scratch variable } s,t :word; { scratch
variables } sz:size; { scratch variables } ss,st: sword; {
scratch variables } k :double; { scratch variables } j:size;
{ scratch variable used as index } a,b:adr; { scratch
variable used for addresses } dt,ds:double; { scratch
variables for double precision } rt,rs,x,y:real; { scratch
variables for real } found:boolean; { scratch } opcode:
byte; { holds the opcode during execution } iclass:
insclass; { true for escaped opcodes } dispat:
array[insclass,byte] of dispatch; retsize:size; { holds size
of last LFR } insr: mnem; { holds the instruction number }
halted: boolean; { normally false } exitstatus:word; {
parameter of MON 1 } ignmask:word; { ignore mask for traps }
uerrorproc:adr; { number of user defined error procedure }
intrap:boolean; { Set when executing trap(), to catch
recursive calls} trapval:byte; { Set to number of last trap
} header: array[1..8] of adr;</tt></p>

<p><tt>tables: text; { description of EM instructions }
prog: file of byte; { program and initialized data
}</tt></p>


<p><tt>{---------------------------------------------------------------------------}
{ Various check routines }
{---------------------------------------------------------------------------}</tt></p>

<p><tt>{ Only the most basic checks are performed. These
routines are inherently implementation dependent. }</tt></p>

<p><tt>procedure trap(n:byte); forward;</tt></p>

<p><tt>procedure memadr(a:adr); begin if (a&gt;maxdata) or
((a&lt;sp) and (a&gt;=hp)) then trap(EMEMFLT) end;</tt></p>

<p><tt>procedure wordadr(a:adr); begin memadr(a); if (a mod
wsize&lt;&gt;0) then trap(EBADPTR) end;</tt></p>

<p><tt>procedure chkadr(a:adr; s:size); begin memadr(a);
memadr(a+s-1); { assumption: size is ok } if s&lt;wsize then
begin if a mod s&lt;&gt;0 then trap(EBADPTR) end else if a
mod wsize&lt;&gt;0 then trap(EBADPTR) end;</tt></p>

<p><tt>procedure newpc(a:double); begin if (a&lt;0) or
(a&gt;maxcode) then trap(EBADPC); pc:=a end;</tt></p>

<p><tt>procedure newsp(a:adr); begin if (a&gt;lb) or
(a&lt;hp) or (a mod wsize&lt;&gt;0) then trap(ESTACK); sp:=a
end;</tt></p>

<p><tt>procedure newlb(a:adr); begin if (a&lt;sp) or (a mod
wsize&lt;&gt;0) then trap(ESTACK); lb:=a end;</tt></p>

<p><tt>procedure newhp(a:adr); begin if (a&gt;sp) or
(a&gt;maxdata+1) or (a mod wsize&lt;&gt;0) then trap(EHEAP)
else hp:=a end;</tt></p>

<p><tt>function argc(a:double):sword; begin if
(a&lt;-signbit) or (a&gt;maxsint) then trap(EILLINS);
argc:=a end;</tt></p>

<p><tt>function argd(a:double):double; begin if
(a&lt;-maxdbl) or (a&gt;maxdbl) then trap(EILLINS); argd:=a
end;</tt></p>

<p><tt>function argl(a:double):offs; begin if
(a&lt;-maxoffs) or (a&gt;maxoffs) then trap(EILLINS);
argl:=a end;</tt></p>

<p><tt>function argg(k:double):adr; begin if (k&lt;0) or
(k&gt;maxadr) then trap(EILLINS); argg:=k end;</tt></p>

<p><tt>function argf(a:double):offs; begin if
(a&lt;-maxoffs) or (a&gt;maxoffs) then trap(EILLINS);
argf:=a end;</tt></p>

<p><tt>function argn(a:double):word; begin if (a&lt;0) or
(a&gt;maxuint) then trap(EILLINS); argn:=a end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>function args(a:double):size; begin if (a&lt;=0) or
(a&gt;maxoffs)</tt></p>
</td>
<td width="89%">

<p><tt>then trap(EODDZ)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else if (a mod wsize)&lt;&gt;0 then trap(EODDZ);
args:=a ; end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>function argz(a:double):size; begin if (a&lt;0) or
(a&gt;maxoffs)</tt></p>
</td>
<td width="89%">

<p><tt>then trap(EODDZ)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else if (a mod wsize)&lt;&gt;0 then trap(EODDZ);
argz:=a ; end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>function argo(a:double):size; begin if (a&lt;=0) or
(a&gt;maxoffs)</tt></p>
</td>
<td width="89%">

<p><tt>then trap(EODDZ)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else if (a mod wsize&lt;&gt;0) and (wsize mod
a&lt;&gt;0) then trap(EODDZ); argo:=a ; end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>function argw(a:double):size; begin if (a&lt;=0) or
(a&gt;maxoffs) or (a&gt;maxuint)</tt></p>
</td>
<td width="89%">

<p><tt>then trap(EODDZ)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else if (a mod wsize)&lt;&gt;0 then trap(EODDZ);
argw:=a ; end;</tt></p>
</td>
</table>

<p><tt>function argp(a:double):size; begin if (a&lt;0) or
(a&gt;=header[NPROC]) then trap(EILLINS); argp:=a
end;</tt></p>

<p><tt>function argr(a:double):word; begin if (a&lt;0) or
(a&gt;2) then trap(EILLINS); argr:=a end;</tt></p>

<p><tt>procedure argwf(s:double); begin if
argw(s)&lt;&gt;fsize then trap(EILLINS) end;</tt></p>

<p><tt>function szindex(s:double):integer; begin
s:=argw(s); if (s mod wsize &lt;&gt; 0) or (s&gt;2*wsize)
then trap(EILLINS); szindex:=s div wsize end;</tt></p>

<p><tt>function locadr(l:double):adr; begin l:=argl(l); if
l&lt;0 then locadr:=lb+l else locadr:=lb+l+savsize
end;</tt></p>

<p><tt>function signwd(w:word):sword; begin if w = undef
then trap(EIUND); if w &gt;= signbit then signwd:=w-negoff
else signwd:=w end;</tt></p>

<p><tt>function dosign(w:word):sword; begin if w &gt;=
signbit then dosign:=w-negoff else dosign:=w end;</tt></p>

<p><tt>function unsign(w:sword):word; begin if w&lt;0 then
unsign:=w+negoff else unsign:=w end;</tt></p>

<p><tt>function chopw(dw:double):word; begin chopw:=dw mod
negoff end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>function fitsw(w:full;trapno:byte):word; { checks
whether value fits in signed word, returns unsigned
representation} begin if (w&gt;maxsint) or (w&lt;-signbit)
then begin trap(trapno); if w&lt;0 then fitsw:=negoff-
(-w)mod negoff</tt></p>
</td>
<td width="89%">

<p><tt>else fitsw:=w mod negoff; end else fitsw:=unsign(w)
end;</tt></p>
</td>
</table>

<p><tt>function fitd(w:full):double; begin if abs(w) &gt;
maxdbl then trap(ECONV); fitd:=w end;</tt></p>


<p><tt>{---------------------------------------------------------------------------}
{ Memory access routines }
{---------------------------------------------------------------------------}</tt></p>

<p><tt>{ memw returns a machine word as an unsigned integer
memb returns a single byte as a positive integer: 0 &lt;=
memb &lt;= 255 mems(a,s) fetches an object smaller than a
word and returns a word store(a,v) stores the word v at
machine address a storea(a,v) stores the address v at
machine address a storeb(a,b) stores the byte b at machine
address a stores(a,s,v) stores the s least significant bytes
of a word at address a memi returns an offset from the
instruction space Note that the procedure descriptors are
part of instruction space. nextpc returns the next byte
addressed by pc, incrementing pc</tt></p>

<p><tt>lino changes the line number word. filna changes the
pointer to the file name.</tt></p>

<p><tt>All routines check to make sure the address is
within range and valid for the size of the object. If an
addressing error is found, a trap occurs. }</tt></p>

<p><tt>function memw(a:adr):word; var b:word; i:integer;
begin wordadr(a); b:=0; for i:=wsize-1 downto 0 do b:=256*b
+ data[a+i] ; memw:=b end;</tt></p>

<p><tt>function memd(a:adr):double; { Always signed } var
b:double; i:integer; begin wordadr(a); b:=data[a+2*wsize-1];
if b&gt;=128 then b:=b-256; for i:=2*wsize-2 downto 0 do
b:=256*b + data[a+i] ; memd:=b end;</tt></p>

<p><tt>function mema(a:adr):adr; var b:adr; i:integer;
begin wordadr(a); b:=0; for i:=asize-1 downto 0 do b:=256*b
+ data[a+i] ; mema:=b end;</tt></p>

<p><tt>function mems(a:adr;s:size):word; var i:integer;
b:word; begin chkadr(a,s); b:=0; for i:=1 to s do
b:=b*256+data[a+s-i]; mems:=b end;</tt></p>

<p><tt>function memb(a:adr):byte; begin memadr(a);
memb:=data[a] end;</tt></p>

<p><tt>procedure store(a:adr; x:word); var i:integer; begin
wordadr(a); for i:=0 to wsize-1 do begin data[a+i]:=x mod
256; x:=x div 256 end end;</tt></p>

<p><tt>procedure storea(a:adr; x:adr); var i:integer; begin
wordadr(a); for i:=0 to asize-1 do begin data[a+i]:=x mod
256; x:=x div 256 end end;</tt></p>

<p><tt>procedure stores(a:adr;s:size;v:word); var
i:integer; begin chkadr(a,s); for i:=0 to s-1 do begin
data[a+i]:=v mod 256; v:=v div 256 end; end;</tt></p>

<p><tt>procedure storeb(a:adr; b:byte); begin memadr(a);
data[a]:=b end;</tt></p>

<p><tt>function memi(a:adr):adr; var b:adr; i:integer;
begin if (a mod wsize&lt;&gt;0) or (a+asize-1&gt;maxcode)
then trap(EBADPTR); b:=0; for i:=asize-1 downto 0 do
b:=256*b + code[a+i] ; memi:=b end;</tt></p>

<p><tt>function nextpc:byte; begin if pc&gt;=pd then
trap(EBADPC); nextpc:=code[pc]; newpc(pc+1) end;</tt></p>

<p><tt>procedure lino(w:word); begin store(lineadr,w)
end;</tt></p>

<p><tt>procedure filna(a:adr); begin storea(fileadr,a)
end;</tt></p>


<p><tt>{---------------------------------------------------------------------------}
{ Stack Manipulation Routines }
{---------------------------------------------------------------------------}</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>{ push puts a word on the stack pushsw takes a
signed one word integer and pushes it on the stack pop
removes a machine word from the stack and delivers it as a
word popsw removes a machine word from the stack and
delivers a signed integer pusha pushes an address on the
stack popa removes a machine word from the stack and
delivers it as an address pushd pushes a double precision
number on the stack popd removes two machine words and
returns a double precision integer pushr pushes a float
(floating point) number on the stack popr removes several
machine words and returns a float number pushx puts an
object of arbitrary size on the stack popx removes an object
of arbitrary size</tt></p>
</td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>}</tt></p>
</td>
</table>

<p><tt>procedure push(x:word); begin newsp(sp-wsize);
store(sp,x) end;</tt></p>

<p><tt>procedure pushsw(x:sword); begin newsp(sp-wsize);
store(sp,unsign(x)) end;</tt></p>

<p><tt>function pop:word; begin pop:=memw(sp);
newsp(sp+wsize) end;</tt></p>

<p><tt>function popsw:sword; begin popsw:=signwd(pop)
end;</tt></p>

<p><tt>procedure pusha(x:adr); begin newsp(sp-asize);
storea(sp,x) end;</tt></p>

<p><tt>function popa:adr; begin popa:=mema(sp);
newsp(sp+asize) end;</tt></p>

<p><tt>procedure pushd(y:double); begin { push double
integer onto the stack } newsp(sp-2*wsize) end;</tt></p>

<p><tt>function popd:double; begin { pop double integer
from the stack } newsp(sp+2*wsize); popd:=0 end;</tt></p>

<p><tt>procedure pushr(z:real); begin { Push a float onto
the stack } newsp(sp-fsize) end;</tt></p>

<p><tt>function popr:real; begin { pop float from the stack
} newsp(sp+fsize); popr:=0.0 end;</tt></p>

<p><tt>procedure pushx(objsize:size; a:adr); var i:integer;
begin if objsize&lt;wsize then push(mems(a,objsize)) else
for i:=1 to objsize div wsize do
push(memw(a+objsize-wsize*i)) end;</tt></p>

<p><tt>procedure popx(objsize:size; a:adr); var i:integer;
begin if objsize&lt;wsize then stores(a,objsize,pop) else
for i:=1 to objsize div wsize do store(a-wsize+wsize*i,pop)
end;</tt></p>


<p><tt>{---------------------------------------------------------------------------}
{ Bit manipulation routines (extract, shift, rotate) }
{---------------------------------------------------------------------------}</tt></p>

<p><tt>procedure sleft(var w:sword); { 1 bit left shift }
begin w:= dosign(fitsw(2*w,EIOVFL)) end;</tt></p>

<p><tt>procedure suleft(var w:word); { 1 bit left shift }
begin w := chopw(2*w) end;</tt></p>

<p><tt>procedure sdleft(var d:double); { 1 bit left shift }
begin { shift two word signed integer } end;</tt></p>

<p><tt>procedure sright(var w:sword); { 1 bit right shift
with sign extension } begin if w &gt;= 0 then w := w div 2
else w := (w-1) div 2 end;</tt></p>

<p><tt>procedure suright(var w:word); { 1 bit right shift
without sign extension } begin w := w div 2 end;</tt></p>

<p><tt>procedure sdright(var d:double); { 1 bit right shift
} begin { shift two word signed integer } end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure rleft(var w:word); { 1 bit left rotate }
begin if w &gt;= t15</tt></p>
</td>
<td width="89%">

<p><tt>then w:=(w-t15)*2 + 1</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else w:=w*2 end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure rright(var w:word); { 1 bit right rotate }
begin if w mod 2 = 1</tt></p>
</td>
<td width="89%">

<p><tt>then w:=w div 2 + t15</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else w:=w div 2 end;</tt></p>
</td>
</table>

<p><tt>function sextend(w:word;s:size):word; var i:size;
begin for i:=1 to (wsize-s)*8 do rleft(w); for i:=1 to
(wsize-s)*8 do sright(w); sextend:=w; end;</tt></p>

<p><tt>function bit(b:bitnr; w:word):bitval; { return bit b
of the word w } var i:bitnr; begin for i:= 1 to b do
rright(w); bit:= w mod 2 end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>function bf(ty:bftype; w1,w2:word):word; { return
boolean fcn of 2 words } var i:bitnr; j:word; begin j:=0;
for i:= maxbitnr downto 0 do</tt></p>
</td>
<td width="89%">

<p><tt>begin j := 2*j;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case ty of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>andf: if bit(i,w1)+bit(i,w2) = 2 then
j:=j+1;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>iorf: if bit(i,w1)+bit(i,w2) &gt; 0 then
j:=j+1;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>xorf: if bit(i,w1)+bit(i,w2) = 1 then
j:=j+1</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; bf:=j end;</tt></p>
</td>
</table>


<p><tt>{---------------------------------------------------------------------------}
{ Array indexing }
{---------------------------------------------------------------------------}</tt></p>

<p><tt>function arraycalc(c:adr):adr; { subscript
calculation } var j:full; objsize:size; a:adr; begin j:=
popsw - signwd(memw(c)); if (j&lt;0) or (j&gt;memw(c+wsize))
then trap(EARRAY); objsize := argo(memw(c+wsize+wsize)); a
:= j*objsize+popa; chkadr(a,objsize); arraycalc:=a
end;</tt></p>


<p><tt>{---------------------------------------------------------------------------}
{ Double and Real Arithmetic }
{---------------------------------------------------------------------------}</tt></p>

<p><tt>{ All routines for doubles and floats are dummy
routines, since the format of doubles and floats is not
defined in EM. }</tt></p>

<p><tt>function doadi(ds,dt:double):double; begin { add two
doubles } doadi:=0 end;</tt></p>

<p><tt>function dosbi(ds,dt:double):double; begin {
subtract two doubles } dosbi:=0 end;</tt></p>

<p><tt>function domli(ds,dt:double):double; begin {
multiply two doubles } domli:=0 end;</tt></p>

<p><tt>function dodvi(ds,dt:double):double; begin { divide
two doubles } dodvi:=0 end;</tt></p>

<p><tt>function dormi(ds,dt:double):double; begin { modulo
of two doubles } dormi:=0 end;</tt></p>

<p><tt>function dongi(ds:double):double; begin { negative
of a double } dongi:=0 end;</tt></p>

<p><tt>function doadf(x,y:real):real; begin { add two
floats } doadf:=0.0 end;</tt></p>

<p><tt>function dosbf(x,y:real):real; begin { subtract two
floats } dosbf:=0.0 end;</tt></p>

<p><tt>function domlf(x,y:real):real; begin { multiply two
floats } domlf:=0.0 end;</tt></p>

<p><tt>function dodvf(x,y:real):real; begin { divide two
floats } dodvf:=0.0 end;</tt></p>

<p><tt>function dongf(x:real):real; begin { negate a float
} dongf:=0.0 end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure dofif(x,y:real;var intpart,fraction:real);
begin { dismember x*y into integer and fractional parts }
intpart:=0.0; { integer part of x*y, same sign as x*y }
fraction:=0.0;</tt></p>
</td>
<td width="89%">

<p><tt>{ fractional part of x*y, 0&lt;=abs(fraction)&lt;1
and same sign as x*y } end;</tt></p>
</td>
</table>

<p><tt>procedure dofef(x:real;var mantissa:real;var
exponent:sword); begin { dismember x into mantissa and
exponent parts } mantissa:=0.0; { mantissa of x , &gt;= 1/2
and &lt;1 } exponent:=0; { base 2 exponent of x }
end;</tt></p>

<p>15</p>


<p><tt>{---------------------------------------------------------------------------}
{ Trap and Call }
{---------------------------------------------------------------------------}</tt></p>

<p><tt>procedure call(p:adr); { Perform the call } begin
pusha(lb);pusha(pc); newlb(sp);newsp(sp - memi(pd + pdsize*p
+ pdlocs)); newpc(memi(pd + pdsize*p+ pdbase)) end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure dotrap(n:byte); var i:size; begin if
(uerrorproc=0) or intrap then begin if intrap then</tt></p>
</td>
<td width="89%">

<p><tt>writeln(&rsquo;Recursive trap, first trap number was
&rsquo;, trapval:1); writeln(&rsquo;Error &rsquo;, n:1);
writeln(&rsquo;With&rsquo;,ord(insr):4,&rsquo; arg
&rsquo;,k:1); goto 9999 end; { Deposit all interpreter
variables that need to be saved on the stack. This includes
all scratch variables that can be in use at the moment and (
not possible in this interpreter ) the internal address of
the interpreter where the error occurred. This would make it
possible to execute an RTT instruction totally transparent
to the user program. It can, for example, occur within an
ADD instruction that both operands are undefined and that
the result overflows. Although this will generate 3 error
traps it must be possible to ignore them all. }
intrap:=true; trapval:=n; for i:=retsize div wsize downto 1
do push(retarea[i]); push(retsize); { saved return area }
pusha(mema(fileadr)); { saved current file name pointer }
push(memw(lineadr)); { saved line number } push(n); { push
error number } a:=argp(uerrorproc); uerrorproc:=0; { reset
signal } call(a); { call the routine } intrap:=false; {
Don&rsquo;t catch recursive traps anymore } goto 8888; {
reenter main loop } end;</tt></p>
</td>
</table>

<p><tt>procedure trap; { This routine is invoked for
overflow, and other run time errors. For non-fatal errors,
trap returns to the calling routine } begin if n&gt;=16 then
dotrap(n) else if bit(n,ignmask)=0 then dotrap(n);
end;</tt></p>

<p><tt>procedure dortt; { The restoration of file address
and line number is not essential. The restoration of the
return save area is. } var i:size; n:word; begin newsp(lb);
lb:=maxdata+1 ; { to circumvent ESTACK for the popa + pop }
newpc(popa); newlb(popa); { So far a plain RET 0 } n:=pop;
if (n&gt;=16) and (n&lt;64) then goto 9999 ; lino(pop);
filna(popa); retsize:=pop; for i:=1 to retsize div wsize do
retarea[i]:=pop ; end;</tt></p>


<p><tt>{---------------------------------------------------------------------------}
{ monitor calls }
{---------------------------------------------------------------------------}</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure domon(entry:word); var index:
1..63;</tt></p>
</td>
<td width="89%">

<p><tt>dummy: double;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>count,rwptr: adr;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>token: byte;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>i: integer; begin if (entry&lt;=0) or (entry&gt;63)
then entry:=63 ; index:=entry; case index of 1: begin { exit
} exitstatus:=pop; halted:=true end; 3: begin { read }
dummy:=pop; { All input is from stdin }</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>rwptr:=popa; count:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>i:=0 ;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>while (not eof(input)) and (i&lt;count) do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if eoln(input) then begin storeb(rwptr,10) ;
count:=i end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else storeb(rwptr,ord(input^)) ;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>get(input); rwptr:=rwptr+1 ; i:=i+1 ;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>pusha(i); push(0) end; 4: begin { write }
dummy:=pop; { All output is to stdout }</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>rwptr:=popa; count:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:=1 to count do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin token:=memb(rwptr); rwptr:=rwptr+1 ;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if token=10 then writeln else
write(chr(token))</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end ;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>pusha(count);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>push(0) end; 54: begin { ioctl, faked }
dummy:=popa;dummy:=popa;dummy:=pop;push(0) end ; 2, 5, 6, 7,
8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
53, 55, 56, 57, 58, 59, 60, 61, 62: begin push(22); push(22)
end; 63: { exists only for the trap } trap(EBADMON) end
end;</tt></p>
</td>
</table>

<p>16</p>


<p><tt>{---------------------------------------------------------------------------}
{ Initialization and debugging }
{---------------------------------------------------------------------------}</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure doident; { print line number and file name
} var a:adr; i,c:integer; found:boolean; begin
write(&rsquo;at line &rsquo;,memw(lineadr):1,&rsquo;
&rsquo;); a:=mema(fileadr); if a&lt;&gt;0 then begin i:=20;
found:=false; while (i&lt;&gt;0) and not found do begin
c:=memb(a); a:=a+1; found:=true; i:=i-1; if (c&gt;=48) and
(c&lt;=57) then</tt></p>
</td>
<td width="89%">

<p><tt>begin found:=false;
write(chr(ord(&rsquo;0&rsquo;)+c-48)) end; if (c&gt;=65) and
(c&lt;=90) then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin found:=false;
write(chr(ord(&rsquo;A&rsquo;)+c-65)) end; if (c&gt;=97) and
(c&lt;=122) then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin found:=false;
write(chr(ord(&rsquo;a&rsquo;)+c-97)) end; end; end;
writeln; end;</tt></p>
</td>
</table>

<p><tt>procedure initialize; { start the ball rolling } {
This is not part of the machine definition } var cset:set of
char; f:ifset; iclass:insclass; insno:byte; nops:integer;
opcode:byte; i,j,n:integer; wtemp:sword; count:integer;
repc:adr; nexta,firsta:adr; elem:byte; amount,ofst:size;
c:char;</tt></p>

<p><tt>function readb(n:integer):double; var b:byte; begin
read(prog,b); if n&gt;1 then readb:=readb(n-1)*256+b else
readb:=b end;</tt></p>

<p><tt>function readbyte:byte; begin readbyte:=readb(1)
end;</tt></p>

<p><tt>function readword:word; begin readword:=readb(wsize)
end;</tt></p>

<p><tt>function readadr:adr; begin readadr:=readb(asize)
end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><tt>function ifind(ordinal:byte):mnem; var
loopvar:mnem;</tt></p>
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>found:boolean; begin ifind:=NON; loopvar:=insr;
found:=false; repeat</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>if ordinal=ord(loopvar) then</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>begin found:=true; ifind:=loopvar end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>if loopvar&lt;&gt;ZRL then loopvar:=succ(loopvar)
else loopvar:=NON; until found or (loopvar=insr) ;
end;</tt></p>

<p><tt>procedure readhdr; type hdrw=0..32767 ; { 16 bit
header words } var hdr: hdrw;</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>i: integer; begin for i:=0 to 7 do begin
hdr:=readb(2);</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>case i of</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>0: if hdr&lt;&gt;3757 then { 07255 }</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>begin writeln(&rsquo;Not an em load file&rsquo;);
halt end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>2: if hdr&lt;&gt;0 then</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>begin writeln(&rsquo;Unsolved references&rsquo;);
halt end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>3: if hdr&lt;&gt;3 then</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>begin writeln(&rsquo;Incorrect load file
version&rsquo;); halt end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>4: if hdr&lt;&gt;wsize then</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>begin writeln(&rsquo;Incorrect word size&rsquo;);
halt end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>5: if hdr&lt;&gt;asize then</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>begin writeln(&rsquo;Incorrect pointer size&rsquo;);
halt end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>1,6,7:;</tt></p>
</td>
<tr valign="top" align="left">
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>end end end;</tt></p>
</td>
</table>

<p><tt>procedure noinit; begin writeln(&rsquo;Illegal
initialization&rsquo;); halt end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><tt>procedure readint(a:adr;s:size); var i:size; begin {
construct integer out of byte sequence } for i:=1 to s do {
construct the value and initialize at a }</tt></p>
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>begin storeb(a,readbyte); a:=a+1 end end;</tt></p>
</td>
</table>

<p><tt>procedure readuns(a:adr;s:size); begin { construct
unsigned out of byte sequence } readint(a,s) { identical to
readint } end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><tt>procedure readfloat(a:adr;s:size); var i:size;
b:byte; begin { construct float out of string} if
(s&lt;&gt;4) and (s&lt;&gt;8) then noinit; i:=0; repeat {
eat the bytes, construct the value and intialize at a
}</tt></p>
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>b:=readbyte; i:=i+1; until b=0 ; end;</tt></p>
</td>
</table>

<p><tt>begin halted:=false; exitstatus:=undef;
uerrorproc:=0; intrap:=false;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><tt>{ initialize tables } for i:=0 to maxcode do
code[i]:=0; for i:=0 to maxdata do data[i]:=0; for
iclass:=prim to tert do for i:=0 to 255 do with
dispat[iclass][i] do</tt></p>
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin instr:=NON; iflag:=[zbit] end;</tt></p>

<p><tt>{ read instruction table file. see appendix B } {
The table read here is a simple transformation of the table
on page xx } { - instruction names were transformed to
numbers } { - the &rsquo;-&rsquo; flag was transformed to an
&rsquo;i&rsquo; flag for &rsquo;w&rsquo; type instructions }
{ - the &rsquo;S&rsquo; flag was added for instructions
having signed operands } reset(tables); insr:=NON; repeat
read(tables,insno) ; cset:=[]; f:=[]; insr:=ifind(insno); if
insr=NON then begin writeln(&rsquo;Incorrect table&rsquo;);
halt end; repeat read(tables,c) until c&lt;&gt;&rsquo;
&rsquo; ; repeat cset:=cset+[c]; read(tables,c) until
c=&rsquo; &rsquo; ; if &rsquo;m&rsquo; in cset then
f:=f+[mini]; if &rsquo;s&rsquo; in cset then f:=f+[short];
if &rsquo;-&rsquo; in cset then f:=f+[zbit]; if
&rsquo;i&rsquo; in cset then f:=f+[ibit]; if &rsquo;S&rsquo;
in cset then f:=f+[sbit]; if &rsquo;w&rsquo; in cset then
f:=f+[wbit]; if (mini in f) or (short in f) then
read(tables,nops) else nops:=1 ; readln(tables,opcode); if
(&rsquo;4&rsquo; in cset) or (&rsquo;8&rsquo; in cset) then
begin iclass:=tert end else if &rsquo;e&rsquo; in cset then
begin iclass:=second end else iclass:=prim; for i:=0 to
nops-1 do begin with dispat[iclass,opcode+i] do
begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>iflag:=f; instr:=insr;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>if &rsquo;2&rsquo; in cset then ilength:=2</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>else if &rsquo;u&rsquo; in cset then
ilength:=2</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>else if &rsquo;4&rsquo; in cset then
ilength:=4</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>else if &rsquo;8&rsquo; in cset then
ilength:=8</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>else if (mini in f) or (short in f) then</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>if &rsquo;N&rsquo; in cset then wtemp:=-1-i else
wtemp:=i ;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>if &rsquo;o&rsquo; in cset then wtemp:=wtemp+1
;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>if short in f then wtemp:=wtemp*256 ;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>implicit:=wtemp</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>end end end until eof(tables);</tt></p>

<p><tt>{ read in program text, data and procedure
descriptors } reset(prog); readhdr; { verify first header }
for i:=1 to 8 do header[i]:=readadr; { read second header }
hp:=maxdata+1; sp:=maxdata+1; lino(0); { read program text }
if header[NTEXT]+header[NPROC]*pdsize&gt;maxcode then begin
writeln(&rsquo;Text size too large&rsquo;); halt end; if
header[SZDATA]&gt;maxdata then begin writeln(&rsquo;Data
size too large&rsquo;); halt end; for i:=0 to
header[NTEXT]-1 do code[i]:=readbyte; { read data blocks }
nexta:=0; for i:=1 to header[NDATA] do begin n:=readbyte; if
n&lt;&gt;0 then</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>elem:=readbyte; firsta:=nexta;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>case n of</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>1: { uninitialized words }</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>for j:=1 to elem do</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin store(nexta,undef); nexta:=nexta+wsize
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>2: { initialized bytes }</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>for j:=1 to elem do</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin storeb(nexta,readbyte); nexta:=nexta+1
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>3: { initialized words }</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>for j:=1 to elem do</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin store(nexta,readword); nexta:=nexta+wsize
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>4,5: { instruction and data pointers }</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>for j:=1 to elem do</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin storea(nexta,readadr); nexta:=nexta+asize
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>6: { signed integers }</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin readint(nexta,elem); nexta:=nexta+elem
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>7: { unsigned integers }</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin readuns(nexta,elem); nexta:=nexta+elem
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>8: { floating point numbers }</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin readfloat(nexta,elem); nexta:=nexta+elem
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>end else</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>repc:=readadr; amount:=nexta-firsta;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>for count:=1 to repc do</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>for ofst:=0 to amount-1 do
data[nexta+ofst]:=data[firsta+ofst];</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>nexta:=nexta+amount;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>end end; if header[SZDATA]&lt;&gt;nexta then
writeln(&rsquo;Data initialization error&rsquo;); hp:=nexta;
{ read descriptor table } pd:=header[NTEXT]; for i:=1 to
header[NPROC]*pdsize do code[pd+i-1]:=readbyte; { call the
entry point routine } ignmask:=0;</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>{ catch all traps, higher numbered traps cannot be
ignored} retsize:=0; lb:=maxdata; { illegal dynamic link }
pc:=maxcode; { illegal return address } push(0); a:=sp; { No
environment } push(0); b:=sp; { No args } pusha(a); { envp }
pusha(b); { argv } push(0); { argc }
call(argp(header[ENTRY])); end;</tt></p>
</td>
</table>

<p>17</p>


<p><tt>{---------------------------------------------------------------------------}
{ MAIN LOOP OF THE INTERPRETER }
{---------------------------------------------------------------------------}
{ It should be noted that the interpreter (microprogram) for
an EM machine can be written in two fundamentally different
ways: (1) the instruction operands are fetched in the main
loop, or (2) the in- struction operands are fetched after
the 256 way branch, by the exe- cution routines themselves.
In this interpreter, method (1) is used to simplify the
description of execution routines. The dispatch table dispat
is used to determine how the operand is encoded. There are 4
possibilities:</tt></p>

<p><tt>0. There is no operand 1. The operand and
instruction are together in 1 byte (mini) 2. The operand is
one byte long and follows the opcode byte(s) 3. The operand
is two bytes long and follows the opcode byte(s) 4. The
operand is four bytes long and follows the opcode
byte(s)</tt></p>

<p><tt>In this interpreter, the main loop determines the
operand type, fetches it, and leaves it in the global
variable k for the execution routines to use. Consequently,
instructions such as LOL, which use three different formats,
need only be described once in the body of the interpreter.
However, for a production interpreter, or a hardware EM
machine, it is probably better to use method (2), i.e. to
let the execution routines themselves fetch their own
operands. The reason for this is that each opcode uniquely
determines the operand format, so no table lookup in the
dispatch table is needed. The whole table is not needed.
Method (2) therefore executes much faster. However, separate
execution routines will be needed for LOL with a one byte
offset, and LOL with a two byte offset. It is to avoid this
additional clutter that method (1) is used here. In a
produc- tion interpreter, it is envisioned that the main
loop will fetch the next instruction byte, and use it as an
index into a 256 word table to find the address of the
interpreter routine to jump to. The routine jumped to will
begin by fetching its operand, if any, without any table
lookup, since it knows which format to expect. After doing
the work, it returns to the main loop by jumping in-
directly to a register that contains the address of the main
loop. A slight variation on this idea is to have the
register contain the address of the branch table, rather
than the address of the main loop. Another issue is whether
the execution routines for LOL 0, LOL 2, LOL 4, etc. should
all be have distinct execution routines. Doing so provides
for the maximum speed, since the operand is implicit in the
routine itself. The disadvantage is that many nearly
identical execution routines will then be needed. Another
way of doing it is to keep the instruction byte fetched from
memory (LOL 0, LOL 2, LOL 4, etc.) in some register, and
have all the LOL mini format instruc- tions branch to a
common routine. This routine can then determine the operand
by subtracting the code for LOL 0 from the register, leaving
the true operand in the register (as a word quantity of
course). This method makes the interpreter smaller, but is a
bit slower.</tt></p>

<p>18</p>

<p><tt>To make this important point a little clearer,
consider how a production interpreter for the PDP-11 might
appear. Let us assume the following opcodes have been
assigned:</tt></p>

<p><tt>31: LOL -2 (2 bytes, i.e. next word) 32: LOL -4 33:
LOL -6 34: LOL b (format with a one byte offset) 35: LOL w
(format with a one word, i.e. two byte offset)</tt></p>

<p><tt>Further assume that each of the 5 opcodes will have
its own execution routine, i.e. we are making a tradeoff in
favor of fast execution and a slightly larger interpreter.
Register r5 is the em program counter. Register r4 is the em
LB register Register r3 is the em SP register (the stack
grows toward low core) Register r2 contains the interpreter
address of the main loop</tt></p>

<p><tt>The main loop looks like this:</tt></p>

<p><tt>movb (r5)+,r0 /fetch the opcode into r0 and
increment r5 asl r0 /shift r0 left 1 bit. Now:
-256&lt;=r0&lt;=+254 jmp *table(r0) /jump to execution
routine</tt></p>

<p><tt>Notice that no operand fetching has been done. The
execution routines for the 5 sample instructions given above
might be as follows:</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><tt>lol2: mov -2(r4),-(sp) /push local -2 onto
stack</tt></p>
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>jmp (r2) /go back to main loop lol4: mov
-4(r4),-(sp) /push local -4 onto stack</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>jmp (r2) /go back to main loop lol6: mov
-6(r4),-(sp) /push local -6 onto stack</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>jmp (r2) /go back to main loop lolb: mov $177400,r0
/prepare to fetch the 1 byte operand</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>bisb (r5)+,r0 /operand is now in r0</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>asl r0 /r0 is now offset from LB in bytes, not
words</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>add r4,r0 /r0 is now address of the needed
local</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>mov (r0),-(sp) /push the local onto the
stack</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>jmp (r2) lolw: clr r0 /prepare to fetch the 2 byte
operand</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>bisb (r5)+,r0 /fetch high order byte first
!!!</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>swab r0 /insert high order byte in place</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>bisb (r5)+,r0 /insert low order byte in
place</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>asl r0 /convert offset to bytes, from words</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>add r4,r0 /r0 is now address of needed
local</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>mov (r0),-(sp) /stack the local</tt></p>
</td>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="6%"></td>
<td width="89%">

<p><tt>jmp (r2) /done</tt></p>
</td>
</table>

<p><tt>The important thing to notice is where and how the
operand fetch occurred: lol2, lol4, and lol6, (the
mini&rsquo;s) have implicit operands lolb knew it had to
fetch one byte, and did so without any table lookup lolw
knew it had to fetch a word, and did so, high order byte
first }</tt></p>

<p>19</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">


<p><tt>{---------------------------------------------------------------------------}
{ Routines for the individual instructions }
{---------------------------------------------------------------------------}
procedure loadops; var j:integer; begin case insr of { LOAD
GROUP } LDC: pushd(argd(k)); LOC: pushsw(argc(k)); LOL:
push(memw(locadr(k))); LOE: push(memw(argg(k))); LIL:
push(memw(mema(locadr(k)))); LOF: push(memw(popa+argf(k)));
LAL: pusha(locadr(k)); LAE: pusha(argg(k)); LXL: begin
a:=lb; for j:=1 to argn(k) do a:=mema(a+savsize); pusha(a)
end; LXA: begin a:=lb;</tt></p>
</td>
<td width="89%">

<p><tt>for j:=1 to argn(k) do a:= mema(a+savsize);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>pusha(a+savsize)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; LOI: pushx(argo(k),popa); LOS: begin
k:=argw(k); if k&lt;&gt;wsize then trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>k:=pop; pushx(argo(k),popa)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; LDL: begin a:=locadr(k); push(memw(a+wsize));
push(memw(a)) end; LDE: begin k:=argg(k);
push(memw(k+wsize)); push(memw(k)) end; LDF: begin
k:=argf(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>a:=popa; push(memw(a+k+wsize));
push(memw(a+k))</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; LPI: push(argp(k)) end end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure storeops; begin case insr of { STORE GROUP
} STL: store(locadr(k),pop); STE: store(argg(k),pop); SIL:
store(mema(locadr(k)),pop); STF: begin a:=popa;
store(a+argf(k),pop) end; STI: popx(argo(k),popa); STS:
begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS);</tt></p>
</td>
<td width="89%">

<p><tt>k:=popa; popx(argo(k),popa)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; SDL: begin a:=locadr(k); store(a,pop);
store(a+wsize,pop) end; SDE: begin k:=argg(k); store(k,pop);
store(k+wsize,pop) end; SDF: begin k:=argf(k); a:=popa;
store(a+k,pop); store(a+k+wsize,pop) end end end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure intarith; var i:integer; begin case insr
of { SIGNED INTEGER ARITHMETIC } ADI: case szindex(argw(k))
of</tt></p>
</td>
<td width="89%">

<p><tt>1: begin st:=popsw; ss:=popsw;
push(fitsw(ss+st,EIOVFL)) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: begin dt:=popd; ds:=popd; pushd(doadi(ds,dt))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end ; SBI: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin st:=popsw; ss:= popsw;
push(fitsw(ss-st,EIOVFL)) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: begin dt:=popd; ds:=popd; pushd(dosbi(ds,dt))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end ; MLI: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin st:=popsw; ss:= popsw;
push(fitsw(ss*st,EIOVFL)) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: begin dt:=popd; ds:=popd; pushd(domli(ds,dt))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end ; DVI: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin st:= popsw; ss:= popsw;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if st=0 then trap(EIDIVZ) else pushsw(ss div
st)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: begin dt:=popd; ds:=popd; pushd(dodvi(ds,dt))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; RMI: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin st:= popsw; ss:=popsw;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if st=0 then trap(EIDIVZ) else pushsw(ss - (ss div
st)*st)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: begin dt:=popd; ds:=popd; pushd(dormi(ds,dt))
end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; NGI: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin st:=popsw; pushsw(-st) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: begin ds:=popd; pushd(dongi(ds)) end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; SLI: begin t:=pop;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin ss:=popsw;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:= 1 to t do sleft(ss); pushsw(ss)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; SRI: begin t:=pop;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin ss:=popsw;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:= 1 to t do sright(ss); pushsw(ss)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: begin ds:=popd;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:= 1 to t do sdright(ss); pushd(ss)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end end end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure unsarith; var i:integer; begin case insr
of { UNSIGNED INTEGER ARITHMETIC } ADU: case
szindex(argw(k)) of</tt></p>
</td>
<td width="89%">

<p><tt>1: begin t:=pop; s:= pop; push(chopw(s+t))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end ; SBU: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin t:=pop; s:= pop; push(chopw(s-t))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end ; MLU: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin t:=pop; s:= pop; push(chopw(s*t))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end ; DVU: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin t:= pop; s:= pop;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if t=0 then trap(EIDIVZ) else push(s div t)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; RMU: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin t:= pop; s:=pop;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if t=0 then trap(EIDIVZ) else push(s - (s div
t)*t)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; SLU: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin t:=pop; s:=pop;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:= 1 to t do suleft(s); push(s)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; SRU: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin t:=pop; s:=pop;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:= 1 to t do suright(s); push(s)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end end end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure fltarith; begin case insr of { FLOATING
POINT ARITHMETIC } ADF: begin argwf(k); rt:=popr; rs:=popr;
pushr(doadf(rs,rt)) end; SBF: begin argwf(k); rt:=popr;
rs:=popr; pushr(dosbf(rs,rt)) end; MLF: begin argwf(k);
rt:=popr; rs:=popr; pushr(domlf(rs,rt)) end; DVF: begin
argwf(k); rt:=popr; rs:=popr; pushr(dodvf(rs,rt)) end; NGF:
begin argwf(k); rt:=popr; pushr(dongf(rt)) end; FIF: begin
argwf(k); rt:=popr; rs:=popr;</tt></p>
</td>
<td width="89%">

<p><tt>dofif(rt,rs,x,y); pushr(y); pushr(x)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; FEF: begin argwf(k); rt:=popr; dofef(rt,x,ss);
pushr(x); pushsw(ss) end end end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure ptrarith; begin case insr of { POINTER
ARITHMETIC } ADP: pusha(popa+argf(k)); ADS: case
szindex(argw(k)) of</tt></p>
</td>
<td width="89%">

<p><tt>1: begin st:=popsw; pusha(popa+st) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: begin dt:=popd; pusha(popa+dt) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; SBS: begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>a:=popa; b:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: push(fitsw(b-a,EIOVFL));</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: pushd(b-a)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end end end;</tt></p>
</td>
</table>

<p><tt>procedure incops; var j:integer; begin case insr of
{ INCREMENT/DECREMENT/ZERO } INC:
push(fitsw(popsw+1,EIOVFL)); INL: begin a:=locadr(k);
store(a,fitsw(signwd(memw(a))+1,EIOVFL)) end; INE: begin
a:=argg(k); store(a,fitsw(signwd(memw(a))+1,EIOVFL)) end;
DEC: push(fitsw(popsw-1,EIOVFL)); DEL: begin a:=locadr(k);
store(a,fitsw(signwd(memw(a))-1,EIOVFL)) end; DEE: begin
a:=argg(k); store(a,fitsw(signwd(memw(a))-1,EIOVFL)) end;
ZRL: store(locadr(k),0); ZRE: store(argg(k),0); ZER: for
j:=1 to argw(k) div wsize do push(0); ZRF: pushr(0); end
end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure convops; begin case insr of { CONVERT
GROUP } CII: begin s:=pop; t:=pop;</tt></p>
</td>
<td width="89%">

<p><tt>if t&lt;wsize then begin push(sextend(pop,t));
t:=wsize end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case szindex(argw(t)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: if szindex(argw(s))=2 then pushd(popsw);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: if szindex(argw(s))=1 then
push(fitsw(popd,ECONV))</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CIU: case szindex(argw(pop)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: if szindex(argw(pop))=2 then push(unsign(popd mod
negoff));</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CIF: begin argwf(pop);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case szindex(argw(pop)) of 1:pushr(popsw);
2:pushr(popd) end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CUI: case szindex(argw(pop)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: case szindex(argw(pop)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin s:=pop; if s&gt;maxsint then trap(ECONV);
push(s) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: case szindex(argw(pop)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: pushd(pop);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CUU: case szindex(argw(pop)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: if szindex(argw(pop))=2 then
trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CUF: begin argwf(pop);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if szindex(argw(pop))=1 then pushr(pop) else
trap(EILLINS)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CFI: begin sz:=argw(pop); argwf(pop);
rt:=popr;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case szindex(sz) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: push(fitsw(trunc(rt),ECONV));</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: pushd(fitd(trunc(rt)));</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CFU: begin sz:=argw(pop); argwf(pop);
rt:=popr;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case szindex(sz) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: push( chopw(trunc(abs(rt)-0.5)) );</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CFF: begin argwf(pop); argwf(pop) end end
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure logops; var i,j:integer; begin case insr
of { LOGICAL GROUP } XAND:</tt></p>
</td>
<td width="89%">

<p><tt>begin k:=argw(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for j:= 1 to k div wsize do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin a:=sp+k; t:=pop; store(a,bf(andf,memw(a),t))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; IOR:</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=argw(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for j:= 1 to k div wsize do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin a:=sp+k; t:=pop; store(a,bf(iorf,memw(a),t))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; XOR:</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=argw(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for j:= 1 to k div wsize do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin a:=sp+k; t:=pop; store(a,bf(xorf,memw(a),t))
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; COM:</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=argw(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for j:= 1 to k div wsize do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>store(sp+k-wsize*j, bf(xorf,memw(sp+k-wsize*j),
negoff-1))</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; ROL: begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>t:=pop; s:=pop; for i:= 1 to t do rleft(s);
push(s)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; ROR: begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>t:=pop; s:=pop; for i:= 1 to t do rright(s);
push(s)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end end end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure setops; var i,j:integer; begin case insr
of { SET GROUP } INN:</tt></p>
</td>
<td width="89%">

<p><tt>begin k:=argw(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>t:=pop;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>i:= t mod 8; t:= t div 8;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if t&gt;=k then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin trap(ESET); s:=0 end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin s:=memb(sp+t) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>newsp(sp+k); push(bit(i,s));</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; XSET:</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=argw(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>t:=pop;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>i:= t mod 8; t:= t div 8;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for j:= 1 to k div wsize do push(0);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if t&gt;=k then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>trap(ESET)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin s:=1; for j:= 1 to i do rleft(s);
storeb(sp+t,s) end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end end end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure arrops; begin case insr of { ARRAY GROUP }
LAR:</tt></p>
</td>
<td width="89%">

<p><tt>begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS); a:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>pushx(argo(memw(a+2*k)),arraycalc(a))</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; SAR:</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS); a:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>popx(argo(memw(a+2*k)),arraycalc(a))</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; AAR:</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS); a:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>push(arraycalc(a))</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end end end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure cmpops; begin case insr of { COMPARE GROUP
} CMI: case szindex(argw(k)) of</tt></p>
</td>
<td width="89%">

<p><tt>1: begin st:=popsw; ss:=popsw;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if ss&lt;st then pushsw(-1) else if ss=st then
push(0) else push(1)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: begin dt:=popd; ds:=popd;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if ds&lt;dt then pushsw(-1) else if ds=dt then
push(0) else push(1)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CMU: case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: begin t:=pop; s:=pop;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if s&lt;t then pushsw(-1) else if s=t then push(0)
else push(1)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CMP: begin a:=popa; b:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if b&lt;a then pushsw(-1) else if b=a then push(0)
else push(1)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CMF: begin argwf(k); rt:=popr;
rs:=popr;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if rs&lt;rt then pushsw(-1) else if rs=rt then
push(0) else push(1)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CMS: begin k:=argw(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>t:= 0; j:= 0;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>while (j &lt; k) and (t=0) do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin if memw(sp+j) &lt;&gt; memw(sp+k+j) then
t:=1;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>j:=j+wsize</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>newsp(sp+wsize*k); push(t);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
</table>

<p><tt>TLT: if popsw &lt; 0 then push(1) else push(0); TLE:
if popsw &lt;= 0 then push(1) else push(0); TEQ: if pop = 0
then push(1) else push(0); TNE: if pop &lt;&gt; 0 then
push(1) else push(0); TGE: if popsw &gt;= 0 then push(1)
else push(0); TGT: if popsw &gt; 0 then push(1) else
push(0); end end;</tt></p>

<p><tt>procedure branchops; begin case insr of { BRANCH
GROUP } BRA: newpc(pc+k);</tt></p>

<p><tt>BLT: begin st:=popsw; if popsw &lt; st then
newpc(pc+k) end; BLE: begin st:=popsw; if popsw &lt;= st
then newpc(pc+k) end; BEQ: begin t :=pop ; if pop = t then
newpc(pc+k) end; BNE: begin t :=pop ; if pop &lt;&gt; t then
newpc(pc+k) end; BGE: begin st:=popsw; if popsw &gt;= st
then newpc(pc+k) end; BGT: begin st:=popsw; if popsw &gt; st
then newpc(pc+k) end;</tt></p>

<p><tt>ZLT: if popsw &lt; 0 then newpc(pc+k); ZLE: if popsw
&lt;= 0 then newpc(pc+k); ZEQ: if pop = 0 then newpc(pc+k);
ZNE: if pop &lt;&gt; 0 then newpc(pc+k); ZGE: if popsw &gt;=
0 then newpc(pc+k); ZGT: if popsw &gt; 0 then newpc(pc+k)
end end;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure callops; var j:integer; begin case insr of
{ PROCEDURE CALL GROUP } CAL: call(argp(k)); CAI: begin
call(argp(popa)) end; RET: begin k:=argz(k); if k div
wsize&gt;maxret then trap(EILLINS);</tt></p>
</td>
<td width="89%">

<p><tt>for j:= 1 to k div wsize do retarea[j]:=pop;
retsize:=k;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>newsp(lb); lb:=maxdata+1; { To circumvent stack
overflow error }</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>newpc(popa);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if pc=maxcode then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>halted:=true;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if retsize=wsize then
exitstatus:=retarea[1]</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else exitstatus:=undef</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>newlb(popa);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; LFR: begin k:=args(k); if k&lt;&gt;retsize then
trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for j:=k div wsize downto 1 do
push(retarea[j]);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end end end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%">

<p><tt>procedure miscops; var i,j:integer; begin case insr
of { MISCELLANEOUS GROUP } ASP,ASS:</tt></p>
</td>
<td width="89%">

<p><tt>begin if insr=ASS then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS); k:=popsw end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>k:=argf(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if k&lt;0</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>then for j:= 1 to -k div wsize do
push(undef)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>else newsp(sp+k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; BLM,BLS:</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin if insr=BLS then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS); k:=pop end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>k:=argz(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>b:=popa; a:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for j := 1 to k div wsize do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">


<p><tt>store(b-wsize+wsize*j,memw(a-wsize+wsize*j))</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CSA: begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>a:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>st:= popsw - signwd(memw(a+asize));</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if (st&gt;=0) and (st&lt;=memw(a+wsize+asize))
then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>b:=mema(a+2*wsize+asize+asize*st) else
b:=mema(a);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if b=0 then trap(ECASE) else newpc(b)</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; CSB: begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS); a:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>t:=pop; i:=1; found:=false;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>while (i&lt;=memw(a+asize)) and not found
do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if t=memw(a+(asize+wsize)*i) then found:=true else
i:=i+1;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if found then b:=memw(a+(asize+wsize)*i+wsize) else
b:=memw(a);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if b=0 then trap(ECASE) else newpc(b);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; DCH: begin pusha(mema(popa+dynd)) end;
DUP,DUS:</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin if insr=DUS then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=argw(k); if k&lt;&gt;wsize then
trap(EILLINS); k:=pop end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>k:=args(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:=1 to k div wsize do
push(memw(sp+k-wsize));</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; EXG: begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>k:=argw(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:=1 to k div wsize do
push(memw(sp+k-wsize));</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:=0 to k div wsize - 1 do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>store(sp+k+i*wsize,memw(sp+k+k+i*wsize));</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:=1 to k div wsize do</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin t:=pop ; store(sp+k+k-wsize,t) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; FIL: filna(argg(k)); GTO: begin
k:=argg(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>newlb(mema(k+2*asize)); newsp(mema(k+asize));
newpc(mema(k))</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; LIM: push(ignmask); LIN: lino(argn(k)); LNI:
lino(memw(0)+1); LOR: begin i:=argr(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case i of 0:pusha(lb); 1:pusha(sp); 2:pusha(hp)
end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; LPB: pusha(popa+statd); MON: domon(pop); NOP:
writeln(&rsquo;NOP at line &rsquo;,memw(0):5) ; RCK: begin
a:=popa;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case szindex(argw(k)) of</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>1: if (signwd(memw(sp))&lt;signwd(memw(a)))
or</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>(signwd(memw(sp))&gt;signwd(memw(a+wsize))) then
trap(ERANGE);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>2: if (memd(sp)&lt;memd(a)) or</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>(memd(sp)&gt;memd(a+2*wsize)) then
trap(ERANGE);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; RTT: dortt; SIG: begin a:=popa;
pusha(uerrorproc); uerrorproc:=a end; SIM: ignmask:=pop;
STR: begin i:=argr(k);</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>case i of 0: newlb(popa); 1: newsp(popa); 2:
newhp(popa) end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end; TRP: trap(pop) end end;</tt></p>
</td>
</table>

<p>20</p>


<p><tt>{---------------------------------------------------------------------------}
{ Main Loop }
{---------------------------------------------------------------------------}</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p><tt>begin initialize; 8888: repeat opcode := nextpc; {
fetch the first byte of the instruction } if opcode=escape1
then iclass:=second else if opcode=escape2 then iclass:=tert
else iclass:=prim; if iclass&lt;&gt;prim then opcode :=
nextpc; with dispat[iclass][opcode] do begin
insr:=instr;</tt></p>
</td>
<td width="89%">

<p><tt>if not (zbit in iflag) then</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if ibit in iflag then k:=pop else</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if mini in iflag then k:=implicit else</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if short in iflag then k:=implicit+nextpc
else</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>begin k:=nextpc;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if (sbit in iflag) and (k&gt;=128) then
k:=k-256;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>for i:=2 to ilength do k:=256*k + nextpc</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>if wbit in iflag then k:=k*wsize;</tt></p>
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">

<p><tt>end end; case insr of</tt></p>
</td>
</table>

<p><tt>NON: trap(EILLINS);</tt></p>

<p><tt>{ LOAD GROUP }
LDC,LOC,LOL,LOE,LIL,LOF,LAL,LAE,LXL,LXA,LOI,LOS,LDL,LDE,LDF,LPI:
loadops;</tt></p>

<p><tt>{ STORE GROUP } STL,STE,SIL,STF,STI,STS,SDL,SDE,SDF:
storeops;</tt></p>

<p><tt>{ SIGNED INTEGER ARITHMETIC }
ADI,SBI,MLI,DVI,RMI,NGI,SLI,SRI: intarith;</tt></p>

<p><tt>{ UNSIGNED INTEGER ARITHMETIC }
ADU,SBU,MLU,DVU,RMU,SLU,SRU: unsarith;</tt></p>

<p><tt>{ FLOATING POINT ARITHMETIC }
ADF,SBF,MLF,DVF,NGF,FIF,FEF: fltarith;</tt></p>

<p><tt>{ POINTER ARITHMETIC } ADP,ADS,SBS:
ptrarith;</tt></p>

<p><tt>{ INCREMENT/DECREMENT/ZERO }
INC,INL,INE,DEC,DEL,DEE,ZRL,ZRE,ZER,ZRF: incops;</tt></p>

<p><tt>{ CONVERT GROUP }
CII,CIU,CIF,CUI,CUU,CUF,CFI,CFU,CFF: convops;</tt></p>

<p><tt>{ LOGICAL GROUP } XAND,IOR,XOR,COM,ROL,ROR:
logops;</tt></p>

<p><tt>{ SET GROUP } INN,XSET: setops;</tt></p>

<p><tt>{ ARRAY GROUP } LAR,SAR,AAR: arrops;</tt></p>

<p><tt>{ COMPARE GROUP } CMI,CMU,CMP,CMF,CMS,
TLT,TLE,TEQ,TNE,TGE,TGT: cmpops;</tt></p>

<p><tt>{ BRANCH GROUP } BRA, BLT,BLE,BEQ,BNE,BGE,BGT,
ZLT,ZLE,ZEQ,ZNE,ZGE,ZGT: branchops;</tt></p>

<p><tt>{ PROCEDURE CALL GROUP } CAL,CAI,RET,LFR:
callops;</tt></p>

<p><tt>{ MISCELLANEOUS GROUP }
ASP,ASS,BLM,BLS,CSA,CSB,DCH,DUP,DUS,EXG,FIL,GTO,LIM,
LIN,LNI,LOR,LPB,MON,NOP,RCK,RTT,SIG,SIM,STR,TRP:
miscops;</tt></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p><tt>end; { end of case statement } if not ( (insr=RET)
or (insr=ASP) or (insr=BRA) or (insr=GTO) ) then</tt></p>
<td width="7%"></td>
<td width="2%"></td>
<td width="89%">

<p><tt>retsize:=0 ; until halted; 9999: writeln(&rsquo;halt
with exit status: &rsquo;,exitstatus:1); doident;
end.</tt></p>
</td>
</table>

<p>21</p>

<p><b>B. EM CODE TABLES</b></p>

<p>The following table is used by the assembler for EM
machine language. It specifies the opcodes used for each
instruction and how arguments are mapped to machine language
arguments. The table is presented in three columns, each
line in each column contains three or four fields. Each line
describes a range of interpreter opcodes by specifying for
which instruction the range is used, the type of the opcodes
(mini, shortie, etc..) and range for the instruction
argument.</p>

<p>The first field on each line gives the EM instruction
mnemonic, the second field gives some flags. If the opcodes
are minis or shorties the third field specifies how many
minis/shorties are used. The last field gives the number of
the (first) interpreter opcode.</p>

<p>Flags :</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Opcode type, only one of the following may be
specified.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>&minus;</p>
</td>
<td width="8%"></td>
<td width="16%">

<p>opcode without argument</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>m</p>
</td>
<td width="8%"></td>
<td width="16%">

<p>mini</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>s</p>
</td>
<td width="8%"></td>
<td width="16%">

<p>shortie</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>2</p>
</td>
<td width="8%"></td>
<td width="16%">

<p>opcode with 2-byte signed argument</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>4</p>
</td>
<td width="8%"></td>
<td width="16%">

<p>opcode with 4-byte signed argument</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>8</p>
</td>
<td width="8%"></td>
<td width="16%">

<p>opcode with 8-byte signed argument</p>
</td>
<td width="63%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>u</p>
</td>
<td width="8%"></td>
<td width="16%">

<p>opcode with 2-byte unsigned argument</p>
</td>
<td width="63%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Secondary (escaped) opcodes.</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>e</p>
</td>
<td width="8%"></td>
<td width="18%">

<p>The opcode thus marked is in the secondary opcode group
instead of the primary</p>
</td>
<td width="61%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>restrictions on arguments</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>N</p>
</td>
<td width="8%"></td>
<td width="18%">

<p>Negative arguments only</p>
</td>
<td width="61%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>P</p>
</td>
<td width="8%"></td>
<td width="18%">

<p>Positive and zero arguments only</p>
</td>
<td width="61%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>mapping of arguments</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>w</p>
</td>
<td width="8%"></td>
<td width="22%">

<p>argument must be divisible by the wordsize and is
divided by the wordsize before use as opcode argument.</p>
</td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="9%"></td>
<td width="2%">

<p>o</p>
</td>
<td width="8%"></td>
<td width="22%">

<p>argument ( possibly after division ) must be &gt;= 1 and
is decremented before use as opcode argument</p>
</td>
<td width="57%">
</td>
</table>

<p>If the opcode type is 2,4 or 8 the resulting argument is
used as opcode argument (least significant byte first). If
the opcode type is mini, the argument is added to the first
opcode &minus; if in range &minus; . If the argument is
negative, the absolute value minus one is used in the
algorithm above.<br>
For shorties with positive arguments the first opcode is
used for arguments in the range 0..255, the second for the
range 256..511, etc.. For shorties with negative arguments
the first opcode is used for arguments in the range
&minus;1..&minus;256, the second for the range
&minus;257..&minus;512, etc.. The byte following the opcode
contains the least significant byte of the argument. First
some examples of these specifications.</p>

<p>aar mwPo 1 34</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Indicates that opcode 34 is used as a mini for Positive
instruction arguments only. The w and o indicate division
and decrementing of the instruction argument. Because the
resulting argument must be zero ( only opcode 34 may be
used), this mini can only be used for instruction argument
2. Conclusion: opcode 34 is for &quot;AAR 2&quot;.</p>
</td>
</table>

<p>adp sP 1 41</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Opcode 41 is used as shortie for ADP with arguments in
the range 0..255.</p>
</td>
</table>

<p>bra sN 2 60</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Opcode 60 is used as shortie for BRA with arguments
&minus;1..&minus;256, 61 is used for arguments
&minus;257..&minus;512.</p>
</td>
</table>

<p>zer e&minus; 145</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>Escaped opcode 145 is used for ZER.</p>
</td>
</table>

<p>The interpreter opcode table:</p>

<p align=center><img src="grohtml-974416.png"></p>

<p>The table above results in the following dispatch
tables. Dispatch tables are used by interpreters to jump to
the routines implementing the EM instructions, indexed by
the next opcode. Each line of the dispatch tables gives the
routine names of eight consecutive opcodes, preceded by the
first opcode number on that line. Routine names consist of
an EM mnemonic followed by a suffix. The suffices show the
encoding used for each opcode.</p>

<p>The following suffices exist:</p>

<p>&lt;num&gt; is a possibly negative integer.</p>

<p>The dispatch table for the 256 primary opcodes:</p>

<p align=center><img src="grohtml-974418.png"></p>

<p>The list of secondary opcodes (escape1):</p>

<p align=center><img src="grohtml-974419.png"></p>

<p>Finally, the list of opcodes with four byte arguments
(escape2).</p>

<p align=center><img src="grohtml-974420.png"></p>

<p>22</p>

<p><b>C. AN EXAMPLE PROGRAM</b></p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>1</p>
<td width="1%"></td>
<td width="6%"></td>
<td width="92%">

<p>program example(output);<br>
2</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="6%"></td>
<td width="92%">

<p>{This program just demonstrates typical EM code.}<br>
3</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="6%"></td>
<td width="92%">

<p>type rec = record r1: integer; r2:real; r3: boolean
end;<br>
4</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="6%"></td>
<td width="92%">

<p>var mi: integer; mx:real; r:rec;</p>
</td>
</table>

<p>5</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">

<p>6</p>
<td width="1%"></td>
<td width="6%"></td>
<td width="92%">

<p>function sum(a,b:integer):integer;<br>
7</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="6%"></td>
<td width="92%">

<p>begin<br>
8</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="6%"></td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="6%"></td>
<td width="92%">

<p>sum := a + b<br>
9</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="6%"></td>
<td width="92%">

<p>end;</p>
</td>
</table>

<p>10</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>11</p>
</td>
<td width="92%">

<p>procedure test(var r: rec);</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>12</p>
</td>
<td width="92%">

<p>label 1;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>13</p>
</td>
<td width="92%">

<p>var i,j: integer;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>14</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>x,y: real;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>15</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>b: boolean;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>16</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>c: char;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>17</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>a: array[1..100] of integer;</p>
</td>
</table>

<p>18</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>19</p>
</td>
<td width="92%">

<p>begin</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>20</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>j := 1;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>21</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>i := 3 * j + 6;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>22</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>x := 4.8;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>23</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>y := x/0.5;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>24</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>b := true;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>25</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>c := &rsquo;z&rsquo;;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>26</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>for i:= 1 to 100 do a[i] := i * i;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>27</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>r.r1 := j+27;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>28</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>r.r3 := b;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>29</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>r.r2 := x+y;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>30</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>i := sum(r.r1, a[j]);</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>31</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>while i &gt; 0 do begin j := j + r.r1; i := i - 1
end;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>32</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>with r do begin r3 := b; r2 := x+y; r1 := 0 end;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>33</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>goto 1;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>34</p>
</td>
<td width="92%">

<p>1:</p>
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>writeln(j, i:6, x:9:3, b)</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>35</p>
</td>
<td width="92%">

<p>end; {test}</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>36</p>
</td>
<td width="92%">

<p>begin {main program}</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>37</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>mx := 15.96;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>38</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>mi := 99;</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>39</p>
</td>
<td width="92%">
</td>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">

<p>test(r)</p>
</td>
<tr valign="top" align="left">
<td width="8%">

<p>40</p>
</td>
<td width="92%">

<p>end.</p>
</td>
</table>

<p>23</p>

<p>The EM code as produced by the Pascal-VU compiler is
given below. Comments have been added manually. Note that
this code has already been optimized.</p>
<!-- TABS -->

<p>mes 2,2,2 ; wordsize 2, pointersize 2<br>
.1</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>rom &rsquo;t.p\000&rsquo;</p>
</td>
<td width="52%">

<p>; the name of the source file</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>hol 552,&minus;32768,0</p>
</td>
<td width="52%">

<p>; externals and buf occupy 552 bytes</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>exp $sum</p>
</td>
<td width="52%">

<p>; sum can be called from other modules</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>pro $sum,2</p>
</td>
<td width="52%">

<p>; procedure sum; 2 bytes local storage</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>lin 8</p>
</td>
<td width="52%">

<p>; code from source line 8</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>ldl 0</p>
</td>
<td width="52%">

<p>; load two locals ( a and b )</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>adi 2</p>
</td>
<td width="52%">

<p>; add them</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>ret 2</p>
</td>
<td width="52%">

<p>; return the result</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>end 2</p>
</td>
<td width="52%">

<p>; end of procedure ( still two bytes local storage )</p>
</td>
</table>

<p>.2</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>rom 1,99,2</p>
</td>
<td width="52%">

<p>; descriptor of array a[]</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>exp $test</p>
</td>
<td width="52%">

<p>; the compiler exports all level 0 procedures</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>pro $test,226</p>
</td>
<td width="52%">

<p>; procedure test, 226 bytes local storage</p>
</td>
</table>

<p>.3</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>rom 4.8F8</p>
</td>
<td width="52%">

<p>; assemble Floating point 4.8 (8 bytes) in</p>
</td>
<tr valign="top" align="left">
<td width="2%">

<p>.4</p>
</td>
<td width="46%"></td>
<td width="52%">

<p>; global storage</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>rom 0.5F8</p>
</td>
<td width="52%">

<p>; same for 0.5</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>mes 3,&minus;226,2,2</p>
</td>
<td width="52%">

<p>; compiler temporary not referenced by address</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>mes 3,&minus;24,2,0</p>
</td>
<td width="52%">

<p>; the same is true for i, j, b and c in test</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>mes 3,&minus;22,2,0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>mes 3,&minus;4,2,0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>mes 3,&minus;2,2,0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>mes 3,&minus;20,8,0</p>
</td>
<td width="52%">

<p>; and for x and y</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>mes 3,&minus;12,8,0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lin 20</p>
</td>
<td width="52%">

<p>; maintain source line number</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>loc 1</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>stl &minus;4</p>
</td>
<td width="52%">

<p>; j := 1</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 21 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>lol &minus;4</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>loc 3</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>mli 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>loc 6</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>adi 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>stl &minus;2</p>
</td>
<td width="52%">

<p>; i := 3 * j + 6</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 22 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>lae .3</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>loi 8</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>lal &minus;12</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>sti 8</p>
</td>
<td width="52%">

<p>; x := 4.8</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 23 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>lal &minus;12</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>loi 8</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>lae .4</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>loi 8</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>dvf 8</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>lal &minus;20</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>sti 8</p>
</td>
<td width="52%">

<p>; y := x / 0.5</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 24 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>loc 1</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>stl &minus;22</p>
</td>
<td width="52%">

<p>; b := true</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 25 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>loc 122</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>stl &minus;24</p>
</td>
<td width="52%">

<p>; c := &rsquo;z&rsquo;</p>
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 26 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="2%"></td>
<td width="46%">

<p>loc 1</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="2%">
</td>
<td width="46%">

<p>stl &minus;2</p>
</td>
<td width="52%">

<p>; for i:= 1</p>
</td>
</table>

<p>2</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>dup 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>mli 2</p>
</td>
<td width="52%">

<p>; i*i</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lal &minus;224</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae .2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>sar 2</p>
</td>
<td width="52%">

<p>; a[i] :=</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loc 100</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>beq *3</p>
</td>
<td width="52%">

<p>; to 100 do</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>inl &minus;2</p>
</td>
<td width="52%">

<p>; increment i and loop</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>bra *2</p>
</td>
<td width="52%">
</td>
</table>

<p>3</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lin 27</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;4</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loc 27</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>adi 2</p>
</td>
<td width="52%">

<p>; j + 27</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>sil 0</p>
</td>
<td width="52%">

<p>; r.r1 :=</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 28 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;22</p>
</td>
<td width="52%">

<p>; b</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol 0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>stf 10</p>
</td>
<td width="52%">

<p>; r.r3 :=</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 29 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lal &minus;20</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loi 16</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>adf 8</p>
</td>
<td width="52%">

<p>; x + y</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol 0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>adp 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>sti 8</p>
</td>
<td width="52%">

<p>; r.r2 :=</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 30 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lal &minus;224</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;4</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae .2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lar 2</p>
</td>
<td width="52%">

<p>; a[j]</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lil 0</p>
</td>
<td width="52%">

<p>; r.r1</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>cal $sum</p>
</td>
<td width="52%">

<p>; call now</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>asp 4</p>
</td>
<td width="52%">

<p>; remove parameters from stack</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lfr 2</p>
</td>
<td width="52%">

<p>; get function result</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>stl &minus;2</p>
</td>
<td width="52%">

<p>; i :=</p>
</td>
</table>

<p>4</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lin 31</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>zle *5</p>
</td>
<td width="52%">

<p>; while i &gt; 0 do</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;4</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lil 0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>adi 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>stl &minus;4</p>
</td>
<td width="52%">

<p>; j := j + r.r1</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>del &minus;2</p>
</td>
<td width="52%">

<p>; i := i - 1</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>bra *4</p>
</td>
<td width="52%">

<p>; loop</p>
</td>
</table>

<p>5</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lin 32</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol 0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>stl &minus;226</p>
</td>
<td width="52%">

<p>; make copy of address of r</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;22</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;226</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>stf 10</p>
</td>
<td width="52%">

<p>; r3 := b</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lal &minus;20</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loi 16</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>adf 8</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;226</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>adp 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>sti 8</p>
</td>
<td width="52%">

<p>; r2 := x + y</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loc 0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>sil &minus;226</p>
</td>
<td width="52%">

<p>; r1 := 0</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lin 34</p>
</td>
<td width="52%">

<p>; note the absence of the unnecessary jump</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae 22</p>
</td>
<td width="52%">

<p>; address of output structure</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;4</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>cal $_wri</p>
</td>
<td width="52%">

<p>; write integer with default width</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>asp 4</p>
</td>
<td width="52%">

<p>; pop parameters</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae 22</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loc 6</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>cal $_wsi</p>
</td>
<td width="52%">

<p>; write integer width 6</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>asp 6</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae 22</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lal &minus;12</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loi 8</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loc 9</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loc 3</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>cal $_wrf</p>
</td>
<td width="52%">

<p>; write fixed format real, width 9, precision 3</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>asp 14</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae 22</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lol &minus;22</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>cal $_wrb</p>
</td>
<td width="52%">

<p>; write boolean, default width</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>asp 4</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae 22</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>cal $_wln</p>
</td>
<td width="52%">

<p>; writeln</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>asp 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>ret 0</p>
</td>
<td width="52%">

<p>; return, no result</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>end 226</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>exp $_main</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>pro $_main,0</p>
</td>
<td width="52%">

<p>; main program</p>
</td>
</table>

<p>.6</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="46%">

<p>con 2,&minus;1,22</p>
</td>
<td width="52%">

<p>; description of external files</p>
</td>
</table>

<p>.5</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>rom 15.96F8</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>fil .1</p>
</td>
<td width="52%">

<p>; maintain source file name</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae .6</p>
</td>
<td width="52%">

<p>; description of external files</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae 0</p>
</td>
<td width="52%">

<p>; base of hol area to relocate buffer addresses</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>cal $_ini</p>
</td>
<td width="52%">

<p>; initialize files, etc...</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>asp 4</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lin 37</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae .5</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loi 8</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>sti 8</p>
</td>
<td width="52%">

<p>; mx := 15.96</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 38 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loc 99</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>ste 0</p>
</td>
<td width="52%">

<p>; mi := 99</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lni</p>
</td>
<td width="52%">

<p>; lin 39 prior to optimization</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>lae 10</p>
</td>
<td width="52%">

<p>; address of r</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>cal $test</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>asp 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>loc 0</p>
</td>
<td width="52%">

<p>; normal exit</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>cal $_hlt</p>
</td>
<td width="52%">

<p>; cleanup and finish</p>
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>asp 2</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>end 0</p>
</td>
<td width="52%">
</td>
<tr valign="top" align="left">
<td width="1%"></td>
<td width="0%"></td>
<td width="46%">

<p>mes 5</p>
</td>
<td width="52%">

<p>; reals were used</p>
</td>
</table>

<p>The compact code corresponding to the above program is
listed below. Read it horizontally, line by line, not column
by column. Each number represents a byte of compact code,
printed in decimal. The first two bytes form the magic
word.</p>

<p><tt>173 0 159 122 122 122 255 242 1 161 250 124 116 46
112 0 255 156 245 40 2 245 0 128 120 155 249 123 115 117 109
160 249 123 115 117 109 122 67 128 63 120 3 122 88 122 152
122 242 2 161 121 219 122 255 155 249 124 116 101 115 116
160 249 124 116 101 115 116 245 226 0 242 3 161 253 128 123
52 46 56 255 242 4 161 253 128 123 48 46 53 255 159 123 245
30 255 122 122 255 159 123 96 122 120 255 159 123 98 122 120
255 159 123 116 122 120 255 159 123 118 122 120 255 159 123
100 128 120 255 159 123 108 128 120 255 67 140 69 121 113
116 68 73 116 69 123 81 122 69 126 3 122 113 118 68 57 242 3
72 128 58 108 112 128 68 58 108 72 128 57 242 4 72 128 44
128 58 100 112 128 68 69 121 113 98 68 69 245 122 0 113 96
68 69 121 113 118 182 73 118 42 122 81 122 58 245 32 255 73
118 57 242 2 94 122 73 118 69 220 10 123 54 118 18 122 183
67 147 73 116 69 147 3 122 104 120 68 73 98 73 120 111 130
68 58 100 72 136 2 128 73 120 4 122 112 128 68 58 245 32 255
73 116 57 242 2 59 122 65 120 20 249 123 115 117 109 8 124
64 122 113 118 184 67 151 73 118 128 125 73 116 65 120 3 122
113 116 41 118 18 124 185 67 152 73 120 113 245 30 255 73 98
73 245 30 255 111 130 58 100 72 136 2 128 73 245 30 255 4
122 112 128 69 120 104 245 30 255 67 154 57 142 73 116 20
249 124 95 119 114 105 8 124 57 142 73 118 69 126 20 249 124
95 119 115 105 8 126 57 142 58 108 72 128 69 129 69 123 20
249 124 95 119 114 102 8 134 57 142 73 98 20 249 124 95 119
114 98 8 124 57 142 20 249 124 95 119 108 110 8 122 88 120
152 245 226 0 155 249 125 95 109 97 105 110 160 249 125 95
109 97 105 110 120 242 6 151 122 119 142 255 242 5 161 253
128 125 49 53 46 57 54 255 50 242 1 57 242 6 57 120 20 249
124 95 105 110 105 8 124 67 157 57 242 5 72 128 57 122 112
128 68 69 219 110 120 68 57 130 20 249 124 116 101 115 116 8
122 69 120 20 249 124 95 104 108 116 8 122 152 120 159 124
160 255 159 125 255</tt></p>

<p>1. INTRODUCTION ............. 1</p>

<p>2. MEMORY ....... 2</p>

<p>3. INSTRUCTION ADDRESS SPACE ........................
3</p>

<p>4. DATA ADDRESS SPACE ................. 4<br>
__4.1 Global data area .................. 4<br>
__4.2 Local data area ................. 4<br>
__4.3 Heap data area ................ 4</p>

<p>5. MAPPING OF EM DATA MEMORY ONTO TARGET MACHINE MEMORY
............................................. 5</p>

<p>6. TYPE REPRESENTATIONS .................... 6<br>
__6.1 Unsigned integers .................... 6<br>
__6.2 Signed Integers .................. 6<br>
__6.3 Floating point values ....................... 6<br>
__6.4 Pointers ............ 6<br>
__6.5 Bit sets ........... 6</p>

<p>7. DESCRIPTORS ............ 7<br>
__7.1 Range check descriptors .........................
7<br>
__7.2 Array descriptors .................... 7<br>
__7.3 Non-local goto descriptors
............................ 7<br>
__7.4 Case descriptors ................... 7</p>

<p>8. ENVIRONMENT INTERACTIONS ........................
8<br>
__8.1 Program starting and stopping
.............................. 8<br>
__8.2 Input/Output and other monitor calls
.................................... 8</p>

<p>9. TRAPS AND INTERRUPTS ................... 9</p>

<p>10. EM MACHINE LANGUAGE .................... 10<br>
__10.1 Instruction encoding ......................... 10<br>
__10.2 Procedure descriptors ..........................
10<br>
__10.3 Load format ................ 10</p>

<p>11. EM ASSEMBLY LANGUAGE ..................... 11<br>
__11.1 ASCII assembly language ...........................
11<br>
____11.1.1 Instruction arguments
.............................. 11<br>
____11.1.2 Pseudoinstruction arguments
.................................... 11<br>
____11.1.3 Notation .................. 11<br>
____11.1.4 Pseudoinstructions ............................
11<br>
______11.1.4.1 Storage declaration
................................ 11<br>
______11.1.4.2 Partitioning ..........................
11<br>
______11.1.4.3 Visibility ........................ 11<br>
______11.1.4.4 Miscellaneous ...........................
11<br>
__11.2 The Compact Assembly Language
................................ 11<br>
__11.3 Assembly language instruction list
..................................... 11</p>

<p>A. EM INTERPRETER ............... 12</p>

<p>B. EM CODE TABLES .............. 21</p>

<p>C. AN EXAMPLE PROGRAM .................. 22</p>
<hr>
</body>
</html>

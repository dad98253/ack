<!-- Creator     : groff version 1.18.1 -->
<!-- CreationDate: Fri Feb 11 22:17:18 2005 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title>The ACK Target Optimizer</title>
</head>
<body>

<h1 align=center>The ACK Target Optimizer</h1>
<a href="#1. Introduction">1. Introduction</a><br>
<a href="#2. Global structure of the target optimizer">2. Global structure of the target optimizer</a><br>
<a href="#2.1. Assumptions about the assembly code format">2.1. Assumptions about the assembly code format</a><br>
<a href="#2.2. Informal description of the machine-dependent tables">2.2. Informal description of the machine-dependent tables</a><br>
<a href="#2.3. Examples">2.3. Examples</a><br>
<a href="#2.3.1. Vax examples">2.3.1. Vax examples</a><br>
<a href="#2.3.2. PDP-11 examples">2.3.2. PDP-11 examples</a><br>
<a href="#3. Implementation of the target optimizer">3. Implementation of the target optimizer</a><br>
<a href="#3.1. The window mechanism">3.1. The window mechanism</a><br>
<a href="#3.2. Pattern matching">3.2. Pattern matching</a><br>
<a href="#3.3. Data structures">3.3. Data structures</a><br>
<a href="#4. Implementation of the target optimizer generator">4. Implementation of the target optimizer generator</a><br>
<a href="#5. References">5. References</a><br>
<a href="#References">References</a><br>
<a href="#Appendix A">Appendix A</a><br>

<hr>

<p align=center><i>ABSTRACT</i></p>

<p align=center><i>H.E. Bal</i><br>
Vrije Universiteit<br>
Wiskundig Seminarium, Amsterdam</p>

<p>The Target Optimizer is one of several optimizers that
are part of the Amsterdam Compiler Kit. It operates directly
on assembly code, rather than on a higher level intermediate
code, as the Peephole Optimizer and Global Optimizer do.
Consequently, the Target Optimizer can do optimizations that
are highly machine-dependent.</p>

<p>Each target machine has its own Target Optimizer. New
optimizers are generated by the Target Optimizer Generator,
which uses a machine-dependent table as input. This document
contains full information on how to write such a table for a
new machine. It also discusses the implementation of the
Target Optimizer and its generator.</p>
<a name="1. Introduction"></a>
<h2>1. Introduction</h2>

<p align=center><img src="grohtml-102411.png"></p>

<p>This document describes the target optimizer component
of the Amsterdam Compiler Kit (ACK) .[Tane81a, Tane83a,
Tane83b] Optimization takes place in several parts of ACK
compilers, most notably in the Peephole Optimizer[Tane82a]
and the Global Optimizer,[Bal85b, Bal85a] which are both
language- and machine-independent, and in the
machine-specific code generators.[Tane84a] The target
optimizer is the finishing touch in this sequence of
optimizers. It can be used to capture those optimizations
that are hard to express in the other parts of ACK. These
optimizations will typically be very machine-specific.</p>

<p>The target optimizer operates on the assembly code of
some target machine. Hence there is one target optimizer per
machine. However, just as for the ACK code generators and
assemblers, a framework has been build that allows easy
generation of target optimizers out of machine-independent
parts and a machine-dependent description table (see figure
1.). So the major part of the code of a target optimizer is
shared among all target optimizers.</p>
<pre>                                            |-------------------------|
                                            | machine-independent     |
                                            | code                    |
                                            |                         |
               |-----------------|          |-------------------------|
     descrip-  |target optimizer |          | machine-dependent code  |
      tion --&gt; |generator        | ----&gt;    | + tables                |
     table     |                 |          |                         |
               |-----------------|          |-------------------------|


                                                   target optimizer


         Figure 1: Generation of a target optimizer.


</pre>

<p>This document focusses on the description of the
machine-dependent table. In chapter 2 we give an informal
introduction to the optimization algorithm and to the
definition of the table format. Chapters 3 and 4 discuss the
implementation of the target optimizer and the target
optimizer generator. Appendix A gives full information for
writing a description table.</p>
<a name="2. Global structure of the target optimizer"></a>
<h2>2. Global structure of the target optimizer</h2>

<p>The target optimizer is based on the well understood
model of a <i>peephole optimizer</i>.[Aho78a] It contains a
machine-dependent table of (pattern,replacement) pairs. Each
pattern describes a sequence of one or more assembler
instructions that can be replaced by zero or more
equivalent, yet cheaper, instructions (the
&rsquo;replacement&rsquo;). The optimizer maintains a
<i>window</i> that moves over the input. At any moment, the
window contains some contiguous part of the input. If the
instructions in the current window match some pattern in the
table, they are replaced by the corresponding replacement;
else, the window moves one instruction to the right.</p>

<p>In the remainder of this section we will give an
informal description of the machine-dependent table. A more
precise definition is given in appendix A. We will first
discuss the restrictions put on the format of the assembly
code.</p>
<a name="2.1. Assumptions about the assembly code format"></a>
<h2>2.1. Assumptions about the assembly code format</h2>

<p>We assume that a line of assembly code begins with an
instruction <i>mnemonic</i> (opcode), followed by zero or
more <i>operands</i>. The mnemonic and the first operand
must be separated by a special character (e.g. a space or a
tab). Likewise, the operands must be separated by a special
character (e.g. a comma). These separators need not be the
same for all machines.</p>
<a name="2.2. Informal description of the machine-dependent tables"></a>
<h2>2.2. Informal description of the machine-dependent tables</h2>

<p>The major part of the table consists of
(pattern,replacement) pairs called <i>entries</i>.</p>

<p>A pattern is a list of instruction descriptions. Each
instruction description describes the instruction mnemonic
and the operands.</p>

<p>A mnemonic is described either by a string constant or
by the keyword ANY. As all entities dealt with by the target
optimizer are strings, string constants do not contain
quotes. A string constant matches only itself. ANY matches
every instruction mnemonic.</p>
<pre>Examples of mnemonic descriptions:

       add
        sub.l
        mulw3
        ANY
</pre>

<p>An operand can also be described by a string
constant.</p>
<pre>Examples:

      (sp)+
       r5
       -4(r6)

</pre>

<p>Alternatively, it can be described by means of a
<i>variable name</i>. Variables have values which are
strings. They have to be declared in the table before the
patterns. Each such declaration defines the name of a
variable and a <i>restriction</i> to which its value is
subjected.</p>
<pre>Example of variable declarations:

     CONST       { VAL[0] == &rsquo;$&rsquo; };
      REG         { VAL[0] == &rsquo;r&rsquo; &amp;&amp; VAL[1] &gt;= &rsquo;0&rsquo; &amp;&amp; VAL[1] &lt;= &rsquo;3&rsquo; &amp;&amp;
                    VAL[2] == &rsquo;\0&rsquo; };
      X           { TRUE };

</pre>

<p>The keyword VAL denotes the value of the variable, which
is a null-terminated string. An operand description given
via a variable name matches an actual operand if the actual
operand obeys the associated restriction.</p>
<pre>     CONST  matches   $1, $-5, $foo etc.
     REG    matches   r0, r1, r2 and r3
     X      matches   anything

</pre>

<p>The restriction (between curly braces) may be any legal
&quot;C&quot;[Kern78a] expression. It may also contain calls
to user-defined procedures. These procedures must be added
to the table after the patterns.</p>
<pre>Example:

    FERMAT_NUMBER    { VAL[0] == &rsquo;$&rsquo; &amp;&amp; is_fermat_number(&amp;VAL[1]) };

</pre>

<p>An operand can also be described by a mixture of a
string constant and a variable name. The most general form
allowed is:</p>
<pre>       string_constant1 variable_name string_constant2

Example:

      (REG)+  matches  (r0)+, (r1)+, (r2)+ and (r3)+

</pre>

<p>Any of the three components may be omitted, so the first
two forms are just special cases of the general form. The
name of a variable can not be used as a string constant. In
the above context, it is impossible to define an operand
that matches the string &quot;REG&quot;. This limitation is
of little consequence, as the table writer is free to choose
the names of variables. This approach, however, avoids the
need for awkward escape sequences.</p>

<p>A pattern consists of one or more instruction
descriptions (separated by a colon) followed by an optional
constraint. A pattern &quot;P1 : P2 : .. : Pn C&quot;
matches the sequence of instructions &quot;I1 I2 .. In&quot;
if:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p>(i)</p>
</td>
<td width="8%"></td>
<td width="86%">

<p>for each i, 1 &lt;= i &lt;= n, Pi matches Ii, as
described above;</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>(ii)</p>
</td>
<td width="6%"></td>
<td width="86%">

<p>multiple occurrences of the same variable name or of the
keyword ANY stand for the same values throughout the
pattern;</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p>(iii)</p>
</td>
<td width="4%"></td>
<td width="86%">

<p>the optional constraint C is satisfied, i.e. it
evaluates to TRUE.</p>
</td>
</table>
<pre>The pattern:

     dec REG : move.b CONST,(REG)

matches:

     dec r0 : move.b $4,(r0)

but not:

     dec r0 : move.b $4,(r1)

(as the variable REG matches two different strings).
</pre>

<p>If a pattern containing different registers must be
described, extra names for a register should be declared,
all sharing the same restriction.</p>
<pre>Example:

    REG1,REG2  { VAL[0] == &rsquo;r&rsquo; &amp;&amp;  .....  };

    addl3 REG1,REG1,REG2 : subl2 REG2,REG1
</pre>

<p>The optional constraint is an auxiliary &quot;C&quot;
expression (just like the parameter restrictions). The
expression may refer to the variables and to ANY.</p>
<pre>Example:

   move REG1,REG2    { REG1[1] == REG2[1] + 1 }

matches

   move r1,r0
    move r2,r1
    move r3,r2
</pre>

<p>The replacement part of a (pattern,replacement) table
entry has the same structure as a pattern, except that:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p>(i)</p>
</td>
<td width="4%"></td>
<td width="88%">

<p>it may not contain an additional constraint;</p>
</td>
<td width="1%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>(ii)</p>
</td>
<td width="2%"></td>
<td width="32%">

<p>it may be empty.</p>
</td>
<td width="57%">
</td>
</table>

<p>A replacement may also refer to the values of variables
and ANY.</p>
<a name="2.3. Examples"></a>
<h2>2.3. Examples</h2>

<p>This section contains some realistic examples for
optimization on PDP-11 and Vax assembly code.</p>
<a name="2.3.1. Vax examples"></a>
<h2>2.3.1. Vax examples</h2>

<p>Suppose the table contains the following
declarations:</p>
<pre>         X, LOG        { TRUE };
         LAB           { VAL[0] == &rsquo;L&rsquo; };   /* e.g. L0017 */
         A             { no_side_effects(VAL) };
         NUM           { is_number(VAL) };

</pre>

<p>The procedure &quot;no_side_effects&quot; checks if its
argument contains any side effects, i.e. auto increment or
auto decrement. The procedure &quot;is_number&quot; checks
if its argument contains only digits. These procedures must
be supplied by the table-writer and must be included in the
table.</p>
<pre><i>entry:</i>  addl3 X,A,A    -&gt; addl2 X,A;

</pre>

<p>This entry changes a 3-operand instruction into a
cheaper 2-operand instruction. An optimization like:</p>
<pre>        addl3 r0,(r2)+,(r2)+   -&gt; addl2 r0,(r2)+

</pre>

<p>is illegal, as r2 should be incremented twice. Hence the
second argument is required to be side-effect free.</p>
<pre><i>entry:</i>  addw2 $-NUM,X  -&gt; subw2 $NUM,X;

</pre>

<p>An instruction like &quot;subw2 $5,r0&quot; is cheaper
than &quot;addw2 $-5,r0&quot;, because constants in the
range 0 to 63 are represented very efficiently on the
Vax.</p>
<pre><i>entry:</i>  bitw $NUM,A : jneq LAB
                { is_poweroftwo(NUM,LOG) }  -&gt; jbs $LOG,A,LAB;

</pre>

<p>A &quot;bitw x,y&quot; sets the condition codes to the
bitwise &quot;and&quot; of x and y. A &quot;jbs n,x,l&quot;
branches to l if bit n of x is set. So, for example, the
following transformation is possible:</p>
<pre>      bitw $32,r0 : jneq L0017 -&gt;  jbs $5,r0,L0017

</pre>

<p>The user-defined procedure &quot;is_poweroftwo&quot;
checks if its first argument is a power of 2 and, if so,
sets its second argument to the logarithm of the first
argument. (Both arguments are strings). Note that the
variable LOG is not used in the pattern itself. It is
assigned a (string) value by &quot;is_poweroftwo&quot; and
is used in the replacement.</p>
<a name="2.3.2. PDP-11 examples"></a>
<h2>2.3.2. PDP-11 examples</h2>

<p>Suppose we have the following declarations:</p>
<pre>         X             { TRUE };
         A             { no_side_effects(VAL) };
         L1, L2        { VAL[0] == &rsquo;I&rsquo; };
         REG           { VAL[0] == &rsquo;r&rsquo; &amp;&amp; VAL[1] &gt;= &rsquo;0&rsquo; &amp;&amp; VAL[1] &lt;= &rsquo;5&rsquo; &amp;&amp;
                         VAL[2] == &rsquo;\0&rsquo; };

</pre>

<p>The implementation of &quot;no_side_effects&quot; may of
course differ for the PDP-11 and the Vax.</p>
<pre><i>entry:</i>  mov REG,A : ANY A,X  -&gt;  mov REG,A : ANY REG,X ;

</pre>

<p>This entry implements register subsumption. If A and REG
hold the same value (which is true after &quot;mov
REG,A&quot;) and A is used as source (first) operand, it is
cheaper to use REG instead.</p>
<pre><i>entry:</i>  jeq L1 : jbr L2 : labdef L1  -&gt;  jne L2 : labdef L1;

</pre>

<p>The &quot;jeq L1&quot; is a &quot;skip over an
unconditional jump&quot;. &quot;labdef L1&quot; denotes the
definition (i.e. defining occurrence) of label L1. As the
target optimizer has to know how such a definition looks
like, this must be expressed in the table (see Appendix
A).</p>
<pre><i>entry:</i>  add $01,X { carry_dead(REST) }  -&gt; inc X;

</pre>

<p>On the PDP-11, an add-one is not equivalent to an
increment. The latter does not set the carry-bit of the
condition codes, while the former does. So a look-ahead is
needed to see if the rest of the input uses the carry-bit
before changing the condition codes. A look-ahead of one
instruction is provided by the target optimizer. This will
normally be sufficient for compiler-generated code. The
keyword REST contains the mnemonic of the first instruction
of the rest of the input. If this instruction uses the
carry-bit (e.g. an adc, subc, bhis) the transformation is
not allowed.</p>
<a name="3. Implementation of the target optimizer"></a>
<h2>3. Implementation of the target optimizer</h2>

<p>The target optimizer reads one input file of assembler
instructions, processes it, and writes the optimized code to
the output file. So it performs one pass over the input.</p>
<a name="3.1. The window mechanism"></a>
<h2>3.1. The window mechanism</h2>

<p>The optimizer uses a <i>window</i> that moves over the
input. It repeatedly tries to match the instructions in the
window with the patterns in the table. If no match is
possible, the window moves one instruction forwards (to the
right). After a successful match the matched instructions
are removed from the window and are replaced by the
replacement part of the table entry. Furthermore, the window
is moved a few instructions backwards, as it is possible
that instructions that were rejected earlier now do match.
For example, consider the following patterns:</p>
<pre>     cmp $0, X           -&gt; tst X ;
     mov REG,X : tst X   -&gt; move REG.X ;   /* redundant test */
</pre>

<p>If the input is:</p>
<pre>     mov r0,foo : cmp $0,foo
</pre>

<p>then the first instruction is initially rejected.
However, after the transformation</p>
<pre>     cmp $0,foo   -&gt;  tst foo
</pre>

<p>the following optimization is possible:</p>
<pre>     mov r0,foo : tst foo  -&gt;  mov r0,foo
</pre>

<p>The window is implemented as a <i>queue</i>. Matching
takes place at the head of the queue. New instructions are
added at the tail. If the window is moved forwards, the
instruction at the head is not yet written to the output, as
it may be needed later on. Instead it is added to a second
queue, the <i>backup queue</i>. After a successful match,
the entire backup queue is inserted at the front of the
window queue, which effectively implements the shift
backwards.</p>

<p>Both queues have the length of the longest pattern in
the table. If, as a result of a forward window move, the
backup queue gets full, the instruction at its head is
outputted and removed. Instructions are read from the input
whenever the window queue contains fewer elements than the
length of the longest pattern.</p>
<a name="3.2. Pattern matching"></a>
<h2>3.2. Pattern matching</h2>

<p>Pattern matching is done in three steps:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p>(i)</p>
</td>
<td width="8%"></td>
<td width="86%">

<p>find patterns in the table whose instruction mnemonics
match the mnemonics of the instructions in the current
window;</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>(ii)</p>
</td>
<td width="6%"></td>
<td width="86%">

<p>check if the operands of the pattern match the operands
of the instructions in the current window;</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p>(iii)</p>
</td>
<td width="4%"></td>
<td width="86%">

<p>check if the optional constraint is satisfied.</p>
</td>
</table>

<p>For step (i) hashing is used. The mnemonic of the first
instruction of the window is used to determine a list of
possible patterns. Patterns starting with ANY are always
tried.</p>

<p>Matching of operand descriptions against actual operands
takes place as follows. The general form of an operand
description is:</p>
<pre>     string_constant1 variable_name string_constant2
</pre>

<p>The actual operand should begin with string_constant1
and end on string_constant2. If so, these strings are
stripped from it and the remaining string is matched against
the variable. Matching a string against a variable is
defined as follows:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>1.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>initially (before the entire pattern match) all
variables are uninstantiated;</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>2.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>matching a string against an uninstantiated variable
succeeds if the restriction associated with the variable is
satisfied. As a side effect, it causes the variable to be
instantiated to the string;</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="4%">

<p>3.</p>
</td>
<td width="6%"></td>
<td width="90%">

<p>matching a string against an instantiated variable
succeeds only if the variable was instantiated to the same
string.</p>
</td>
</table>

<p>Matching an actual mnemonic against the keyword ANY is
defined likewise.</p>

<p>The matching scheme implements the requirement that
multiple occurrences of the same variable name or of the
keyword ANY should stand for the same values throughout the
entire pattern (see section 2.).</p>

<p>Both the parameter restriction of 2. and the constraint
of step (iii) are checked by executing the &quot;C&quot;
expression.</p>
<a name="3.3. Data structures"></a>
<h2>3.3. Data structures</h2>

<p>The most important data structure is the representation
of the input instructions. For every instruction we use two
representations:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p>(i)</p>
</td>
<td width="4%"></td>
<td width="90%">

<p>the textual representation, i.e. the exact code as it
appeared in the input;</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>(ii)</p>
</td>
<td width="2%"></td>
<td width="90%">

<p>a structural representation, containing the opcode and
the operands.</p>
</td>
</table>

<p>The opcode of an instruction is determined as soon as it
is read. If the line contains a label definition, the opcode
is set to &quot;labdef&quot;, so a label definition is
treated like a normal instruction.</p>

<p>The operands of an instruction are not determined until
they are needed, i.e. until step (i) of the pattern matching
process has succeeded. For every instruction we keep track
of a <i>state</i>. After the opcode has successfully been
determined, the state is OPC_ONLY. Once the operands have
been recognized, the state is set to DONE. If the opcode or
operands can not be determined, or if the instruction cannot
be optimized for any other reason (see Appendix A), the
state is set to JUNK and any attempt to match it will
fail.</p>

<p>For each table entry we record the following
information:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p>(i)</p>
</td>
<td width="8%"></td>
<td width="86%">

<p>the length of the pattern (i.e. the number of
instruction descriptions)</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>(ii)</p>
</td>
<td width="6%"></td>
<td width="86%">

<p>a description of the instructions of the pattern</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%">

<p>(iii)</p>
</td>
<td width="4%"></td>
<td width="58%">

<p>the length of the replacement</p>
</td>
<td width="27%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>(iv)</p>
</td>
<td width="6%"></td>
<td width="86%">

<p>a description of the instructions of the
replacement.</p>
</td>
</table>

<p>The description of an instruction consists of:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p>(i)</p>
</td>
<td width="4%"></td>
<td width="20%">

<p>the opcode</p>
</td>
<td width="69%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>(ii)</p>
</td>
<td width="2%"></td>
<td width="90%">

<p>for each operand, a description of the operand.</p>
</td>
</table>

<p>The description of an operand of the form:</p>
<pre>     string_constant1 variable_name string_constant2
</pre>

<p>contains:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p>(i)</p>
</td>
<td width="4%"></td>
<td width="42%">

<p>both string constants</p>
</td>
<td width="47%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>(ii)</p>
</td>
<td width="2%"></td>
<td width="54%">

<p>the number of the variable.</p>
</td>
<td width="35%">
</td>
</table>

<p>Each declared variable is assigned a unique number. For
every variable we maintain:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="6%">

<p>(i)</p>
</td>
<td width="4%"></td>
<td width="88%">

<p>its state (instantiated or not instantiated)</p>
</td>
<td width="1%">
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%">

<p>(ii)</p>
</td>
<td width="2%"></td>
<td width="58%">

<p>its current value (a string).</p>
</td>
<td width="31%">
</td>
</table>

<p>The restrictions on variables and the constraints are
stored in a switch-statement, indexed by variable number and
entry number respectively.</p>
<a name="4. Implementation of the target optimizer generator"></a>
<h2>4. Implementation of the target optimizer generator</h2>

<p>The target optimizer generator (<i>topgen</i>) reads a
target machine description table and produces two files:</p>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%">

<p>gen.h:</p>
</td>
<td width="6%"></td>
<td width="82%">

<p>contains macro definitions for machine parameters that
were changed in the parameter section of the table (see
appendix A) and for some attributes derived from the table
(longest pattern, number of patterns, number of
variables).</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="3" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%">

<p>gen.c:</p>
</td>
<td width="6%"></td>
<td width="82%">

<p>contains the entry description tables, code for checking
the parameter restrictions and constraints (switch
statements) and the user-defined procedures.</p>
</td>
</table>

<p>These two files are compiled together with some
machine-independent files to produce a target optimizer.</p>

<p>Topgen is implemented using the LL(1) parser generator
system LLgen ,[Jaco85a] a powerful tool of the Amsterdam
Compiler Kit. This system provides a flexible way of
describing the syntax of the tables. The syntactical
description of the table format included in Appendix A was
derived from the LLgen syntax rules.</p>

<p>The parser uses a simple, hand-written, lexical analyzer
(scanner). The scanner returns a single character in most
cases. The recognition of identifiers is left to the parser,
as this eases the analysis of operand descriptions. Comments
are removed from the input by the scanner, but white space
is passed to the parser, as it is meaningful in some
contexts (it separates the opcode description from the
description of the first operand).</p>

<p>Topgen maintains two symbol tables, one for variable
names and one for tunable parameters. The symbol tables are
organized as binary trees.</p>
<a name="5. References"></a>
<h2>5. References</h2>
<a name="References"></a>
<h2>References</h2>

<p>Aho78a.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>A.V. Aho and J.D. Ullman, <i>Principles of compiler
design,</i> Addison-Wesley, Reading, Massachusetts
(1978).</p>
</td>
</table>

<p>Bal85a.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>H.E. Bal, &ldquo;The Design and Implementation of the EM
Global Optimizer,&rdquo; Rapport IR-99, Vrije Universiteit,
Amsterdam (March 1985).</p>
</td>
</table>

<p>Bal85b.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>H.E. Bal and A.S. Tanenbaum, &ldquo;Language- and
Machine-independant Global Optimization on Intermediate
Code,&rdquo; Rapport IR-98, Vrije Universiteit, Amsterdam
(March 1985).</p>
</td>
</table>

<p>Jaco85a.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>C.J.H. Jacobs, &ldquo;Some Topics in Parser
Generation,&rdquo; Rapport IR-105, Vrije Universiteit,
Amsterdam (October 1985).</p>
</td>
</table>

<p>Kern78a.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>B.W. Kernighan and D.M. Ritchie, <i>The C Programming
Language,</i> Prentice-Hall, Inc, Englewood Cliffs,NJ
(1978).</p>
</td>
</table>

<p>Tane84a.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>A.S. Tanenbaum, E.G. Keizer, J.M. van Staveren, and J.W.
Stevenson, &ldquo;Amsterdam Compiler Kit
documentation,&rdquo; Rapport nr IR-90, Vrije Universiteit,
Amsterdam (June 1984).</p>
</td>
</table>

<p>Tane81a.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>A.S. Tanenbaum, J.M. van Staveren, E.G. Keizer, and J.W.
Stevenson, &ldquo;A Practical Toolkit for Making Portable
Compilers,&rdquo; Rapport nr IR-74, Vrije Universiteit,
Amsterdam (October 1981).</p>
</td>
</table>

<p>Tane83a.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>A.S. Tanenbaum, J.M. van Staveren, E.G. Keizer, and J.W.
Stevenson, &ldquo;A Practical Toolkit for Making Portable
Compilers,&rdquo; <i>CACM,</i> 26, 9, pp. 654-660 (September
1983).</p>
</td>
</table>

<p>Tane83b.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>A.S. Tanenbaum, J.M. van Staveren, E.G. Keizer, and J.W.
Stevenson, &ldquo;A Unix Toolkit for Making Portable
Compilers,&rdquo; <i>Proceedings USENIX conf.,</i> 26, pp.
255-261, Toronto, Canada (July 1983).</p>
</td>
</table>

<p>Tane82a.</p>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="9%"></td>
<td width="90%">
<p>A.S. Tanenbaum, J.M. van Staveren, and J.W. Stevenson,
&ldquo;Using Peephole Optimization on Intermediate
Code,&rdquo; <i>TOPLAS,</i> 4, 1, pp. 21-36 (January
1982).</p>
</td>
</table>
<a name="Appendix A"></a>
<h2>Appendix A</h2>

<p>In this appendix we present a complete definition of the
target optimizer description table format. This appendix is
intended for table-writers. We use syntax rules for the
description of the table format. The following notation is
used:</p>

<p align=center><img src="grohtml-102412.png"></p>

<p>Terminals are given in quotes, as in
&rsquo;;&rsquo;.</p>

<p>The table may contain white space and comment at all
reasonable places. Comments are as in &quot;C&quot;, so they
begin with /* and end on */. Identifiers are sequences of
letters, digits and the underscore (&rsquo;_&rsquo;),
beginning with a letter.</p>
<pre>     table   -&gt;   {parameter_line} &rsquo;%%;&rsquo; {variable_declaration} &rsquo;%%;&rsquo;
                  {entry} &rsquo;%%;&rsquo; user_routines.
</pre>

<p>A table consists of four sections, containing
machine-dependent constants, variable declarations, pattern
rules and user-supplied subroutines.</p>
<pre>     parameter_line -&gt;  identifier value &rsquo;;&rsquo; .
</pre>

<p>A parameter line defines some attributes of the target
machines assembly code. For unspecified parameters default
values apply. The names of the parameters and the
corresponding defaults are shown in table 1.</p>

<p align=center><img src="grohtml-102413.png"></p>

<p align=center>table 1: parameter names and defaults</p>

<p>The OPC_TERMINATOR is the character that separates the
instruction mnemonic from the first operand (if any). The
OP_SEPARATOR separates adjacent operands. A LABEL_STARTER is
the first character of an instruction label. (Instruction
labels are assumed to start with the same character). The
LABEL_TERMINATOR is the last character of a label
definition. It is assumed that this character is not used in
an applied occurrence of the label identifier. For example,
the defining occurrence may be &quot;I0017:&quot; and the
applied occurrence may be &quot;I0017&quot; as in &quot;jmp
I0017&quot;. MAXOP defines the maximum number of operands an
instruction can have. MAXOPLEN is the maximum length (in
characters) of an operand. MAX_OPC_LEN is the maximum length
of an instruction opcode. MAXVARLEN is the maximum length of
a declared string variable. As variables may be set by user
routines (see &quot;bitw&quot; example for the Vax) the
table-writer must have access to this length and must be
able to change it. MAXLINELEN denotes the maximum length of
a line of assembly code. PAREN_OPEN and PAREN_CLOSE must be
used when the operand separator can also occur within
operands, between parentheses of some kind. In this case,
PAREN_OPEN must be set to a string containing the opening
parentheses, and PAREN_CLOSE must be set to a string
containing the closing parentheses.</p>

<p>If a line of assembly code violates any of the
assumptions or exceeds some limit, the line is not
optimized. Optimization does, however, proceed with the rest
of the input.</p>
<pre>     variable_declaration  -&gt; identifier {&rsquo;,&rsquo; identifier} restriction &rsquo;;&rsquo; .


     restriction           -&gt;  &rsquo;{&rsquo; anything &rsquo;}&rsquo; .
</pre>

<p>A variable declaration declares one or more string
variables that may be used in the patterns and in the
replacements. If a variable is used as part of an operand
description in a pattern, the entire pattern can only match
if the restriction evaluates to TRUE. If the pattern does
match, the variable is assigned the matching part of the
actual operand. Variables that are not used in a pattern are
initialized to null-strings and may be assigned a value in
the constraint-part of the pattern.</p>

<p>The restriction must be a legal &quot;C&quot;
expression. It may not contain a closing bracket
(&rsquo;}&rsquo;). Inside the expression, the name VAL
stands for the part of the actual (matching) operand. The
expression may contain calls to procedures that are defined
in the user-routines section.</p>
<pre>     entry             -&gt;  pattern &rsquo;-&gt;&rsquo; replacement &rsquo;;&rsquo; .


     pattern           -&gt;  instruction_descr
                     { &rsquo;:&rsquo; instruction_descr }
                     constraint .


     replacement       -&gt;  [ instruction_descr { &rsquo;:&rsquo; instruction_descr } ] .


     instruction_descr -&gt; opcode
                    white
                    [ operand_descr { &rsquo;,&rsquo; operand_descr } ] .


     constraint        -&gt; &rsquo;{&rsquo; anything &rsquo;}&rsquo; .


     operand_descr     -&gt; [ string_constant ]
                    [ variable_name ]
                    [ string_constant ] .


     variable_name     -&gt; identifier .


     opcode            -&gt; anything .
</pre>

<p>The symbol &rsquo;white&rsquo; stands for white space
(space or tab). An opcode can be any string not containing
the special symbols &rsquo;;&rsquo;, &rsquo;{&rsquo;,
&rsquo;}&rsquo;, &rsquo;:&rsquo;, &rsquo;,&rsquo;,
&rsquo;-&gt;&rsquo; or white space. To be recognized, it
must begin with a letter. The opcode should either be a
mnemonic of a target machine instruction or it should be one
of the keywords ANY and labdef. ANY matches any actual
opcode. labdef matches only label definitions.</p>

<p>If an operand description contains an identifier (as
defined earlier), it is checked if the identifier is the
name of a declared variable. This effects the semantics of
the matching rules for the operand, as described in section
2. An operand may contain at most one such variable
name.</p>

<p>The constraint must be a legal &quot;C&quot; expression,
just as the operand restriction. It may call user-defined
procedures and use or change the value of declared
variables. It may also use the string variable REST, which
contains the mnemonic of the first instruction of the rest
of the input. (REST is a null-string if this mnemonic can
not be determined).</p>
<pre>     user_routines -&gt; anything .
</pre>

<p>The remainder of the table consists of user-defined
subroutines.</p>
<hr>
</body>
</html>
